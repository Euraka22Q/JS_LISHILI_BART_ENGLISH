#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2025.1.0),
    on 七月 02, 2025, at 17:02
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import plugins
plugins.activatePlugins()
prefs.hardware['audioLib'] = 'ptb'
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout, hardware
from psychopy.tools import environmenttools
from psychopy.constants import (
    NOT_STARTED, STARTED, PLAYING, PAUSED, STOPPED, STOPPING, FINISHED, PRESSED, 
    RELEASED, FOREVER, priority
)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

import psychopy.iohub as io
from psychopy.hardware import keyboard

# --- Setup global variables (available in all functions) ---
# create a device manager to handle hardware (keyboards, mice, mirophones, speakers, etc.)
deviceManager = hardware.DeviceManager()
# ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
# store info about the experiment session
psychopyVersion = '2025.1.0'
expName = 'BartOSF'  # from the Builder filename that created this script
expVersion = ''
# a list of functions to run when the experiment ends (starts off blank)
runAtExit = []
# information about this experiment
expInfo = {
    'participant': '',
    'date|hid': data.getDateStr(),
    'expName|hid': expName,
    'expVersion|hid': expVersion,
    'psychopyVersion|hid': psychopyVersion,
}

# --- Define some variables which will change depending on pilot mode ---
'''
To run in pilot mode, either use the run/pilot toggle in Builder, Coder and Runner, 
or run the experiment with `--pilot` as an argument. To change what pilot 
#mode does, check out the 'Pilot mode' tab in preferences.
'''
# work out from system args whether we are running in pilot mode
PILOTING = core.setPilotModeFromArgs()
# start off with values from experiment settings
_fullScr = True
_winSize = [1536, 960]
# if in pilot mode, apply overrides according to preferences
if PILOTING:
    # force windowed mode
    if prefs.piloting['forceWindowed']:
        _fullScr = False
        # set window size
        _winSize = prefs.piloting['forcedWindowSize']
    # replace default participant ID
    if prefs.piloting['replaceParticipantID']:
        expInfo['participant'] = 'pilot'

def showExpInfoDlg(expInfo):
    """
    Show participant info dialog.
    Parameters
    ==========
    expInfo : dict
        Information about this experiment.
    
    Returns
    ==========
    dict
        Information about this experiment.
    """
    # show participant info dialog
    dlg = gui.DlgFromDict(
        dictionary=expInfo, sortKeys=False, title=expName, alwaysOnTop=True
    )
    if dlg.OK == False:
        core.quit()  # user pressed cancel
    # return expInfo
    return expInfo


def setupData(expInfo, dataDir=None):
    """
    Make an ExperimentHandler to handle trials and saving.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    dataDir : Path, str or None
        Folder to save the data to, leave as None to create a folder in the current directory.    
    Returns
    ==========
    psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    # remove dialog-specific syntax from expInfo
    for key, val in expInfo.copy().items():
        newKey, _ = data.utils.parsePipeSyntax(key)
        expInfo[newKey] = expInfo.pop(key)
    
    # data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
    if dataDir is None:
        dataDir = _thisDir
    filename = 'data' + os.sep + '%s_%s' % (expInfo['participant'], expInfo['date'])
    # make sure filename is relative to dataDir
    if os.path.isabs(filename):
        dataDir = os.path.commonprefix([dataDir, filename])
        filename = os.path.relpath(filename, dataDir)
    
    # an ExperimentHandler isn't essential but helps with data saving
    thisExp = data.ExperimentHandler(
        name=expName, version=expVersion,
        extraInfo=expInfo, runtimeInfo=None,
        originPath='D:\\bart and fishing\\addballoon and fishingbadit\\BartOSF.py',
        savePickle=True, saveWideText=True,
        dataFileName=dataDir + os.sep + filename, sortColumns='time'
    )
    thisExp.setPriority('thisRow.t', priority.CRITICAL)
    thisExp.setPriority('expName', priority.LOW)
    # return experiment handler
    return thisExp


def setupLogging(filename):
    """
    Setup a log file and tell it what level to log at.
    
    Parameters
    ==========
    filename : str or pathlib.Path
        Filename to save log file and data files as, doesn't need an extension.
    
    Returns
    ==========
    psychopy.logging.LogFile
        Text stream to receive inputs from the logging system.
    """
    # set how much information should be printed to the console / app
    if PILOTING:
        logging.console.setLevel(
            prefs.piloting['pilotConsoleLoggingLevel']
        )
    else:
        logging.console.setLevel('warning')
    # save a log file for detail verbose info
    logFile = logging.LogFile(filename+'.log')
    if PILOTING:
        logFile.setLevel(
            prefs.piloting['pilotLoggingLevel']
        )
    else:
        logFile.setLevel(
            logging.getLevel('warning')
        )
    
    return logFile


def setupWindow(expInfo=None, win=None):
    """
    Setup the Window
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    win : psychopy.visual.Window
        Window to setup - leave as None to create a new window.
    
    Returns
    ==========
    psychopy.visual.Window
        Window in which to run this experiment.
    """
    if PILOTING:
        logging.debug('Fullscreen settings ignored as running in pilot mode.')
    
    if win is None:
        # if not given a window to setup, make one
        win = visual.Window(
            size=_winSize, fullscr=_fullScr, screen=0,
            winType='pyglet', allowGUI=False, allowStencil=True,
            monitor='myMonitor', color=[0.6549, 0.6549, 0.6549], colorSpace='rgb',
            backgroundImage='', backgroundFit='contain',
            blendMode='avg', useFBO=True,
            units=None,
            checkTiming=False  # we're going to do this ourselves in a moment
        )
    else:
        # if we have a window, just set the attributes which are safe to set
        win.color = [0.6549, 0.6549, 0.6549]
        win.colorSpace = 'rgb'
        win.backgroundImage = ''
        win.backgroundFit = 'contain'
        win.units = None
    if expInfo is not None:
        # get/measure frame rate if not already in expInfo
        if win._monitorFrameRate is None:
            win._monitorFrameRate = win.getActualFrameRate(infoMsg='Attempting to measure frame rate of screen, please wait...')
        expInfo['frameRate'] = win._monitorFrameRate
    win.hideMessage()
    if PILOTING:
        # show a visual indicator if we're in piloting mode
        if prefs.piloting['showPilotingIndicator']:
            win.showPilotingIndicator()
        # always show the mouse in piloting mode
        if prefs.piloting['forceMouseVisible']:
            win.mouseVisible = True
    
    return win


def setupDevices(expInfo, thisExp, win):
    """
    Setup whatever devices are available (mouse, keyboard, speaker, eyetracker, etc.) and add them to 
    the device manager (deviceManager)
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window in which to run this experiment.
    Returns
    ==========
    bool
        True if completed successfully.
    """
    # --- Setup input devices ---
    ioConfig = {}
    
    # Setup iohub keyboard
    ioConfig['Keyboard'] = dict(use_keymap='psychopy')
    
    # Setup iohub experiment
    ioConfig['Experiment'] = dict(filename=thisExp.dataFileName)
    
    # Start ioHub server
    ioServer = io.launchHubServer(window=win, **ioConfig)
    
    # store ioServer object in the device manager
    deviceManager.ioServer = ioServer
    
    # create a default keyboard (e.g. to check for escape)
    if deviceManager.getDevice('defaultKeyboard') is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='iohub'
        )
    if deviceManager.getDevice('key_resp_13') is None:
        # initialise key_resp_13
        key_resp_13 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_13',
        )
    if deviceManager.getDevice('key_resp_4') is None:
        # initialise key_resp_4
        key_resp_4 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_4',
        )
    if deviceManager.getDevice('key_resp_5') is None:
        # initialise key_resp_5
        key_resp_5 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_5',
        )
    if deviceManager.getDevice('key_resp_6') is None:
        # initialise key_resp_6
        key_resp_6 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_6',
        )
    if deviceManager.getDevice('key_resp_7') is None:
        # initialise key_resp_7
        key_resp_7 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_7',
        )
    if deviceManager.getDevice('key_resp_8') is None:
        # initialise key_resp_8
        key_resp_8 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_8',
        )
    if deviceManager.getDevice('key_resp_12') is None:
        # initialise key_resp_12
        key_resp_12 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_12',
        )
    if deviceManager.getDevice('key_resp_9') is None:
        # initialise key_resp_9
        key_resp_9 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_9',
        )
    if deviceManager.getDevice('key_resp_10') is None:
        # initialise key_resp_10
        key_resp_10 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_10',
        )
    if deviceManager.getDevice('key_resp_11') is None:
        # initialise key_resp_11
        key_resp_11 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_11',
        )
    if deviceManager.getDevice('resp_2') is None:
        # initialise resp_2
        resp_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='resp_2',
        )
    if deviceManager.getDevice('resp') is None:
        # initialise resp
        resp = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='resp',
        )
    # create speaker 'pop_sound'
    deviceManager.addDevice(
        deviceName='pop_sound',
        deviceClass='psychopy.hardware.speaker.SpeakerDevice',
        index='-1',
        resample='True',
        latencyClass=1,
    )
    if deviceManager.getDevice('practice_bankButton') is None:
        # initialise practice_bankButton
        practice_bankButton = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='practice_bankButton',
        )
    if deviceManager.getDevice('key_resp') is None:
        # initialise key_resp
        key_resp = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp',
        )
    if deviceManager.getDevice('key_resp_comprehension') is None:
        # initialise key_resp_comprehension
        key_resp_comprehension = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_comprehension',
        )
    if deviceManager.getDevice('key_resp_comprehension_2') is None:
        # initialise key_resp_comprehension_2
        key_resp_comprehension_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_comprehension_2',
        )
    if deviceManager.getDevice('bankButton') is None:
        # initialise bankButton
        bankButton = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='bankButton',
        )
    if deviceManager.getDevice('key_resp_2') is None:
        # initialise key_resp_2
        key_resp_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_2',
        )
    # return True if completed successfully
    return True

def pauseExperiment(thisExp, win=None, timers=[], currentRoutine=None):
    """
    Pause this experiment, preventing the flow from advancing to the next routine until resumed.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    timers : list, tuple
        List of timers to reset once pausing is finished.
    currentRoutine : psychopy.data.Routine
        Current Routine we are in at time of pausing, if any. This object tells PsychoPy what Components to pause/play/dispatch.
    """
    # if we are not paused, do nothing
    if thisExp.status != PAUSED:
        return
    
    # start a timer to figure out how long we're paused for
    pauseTimer = core.Clock()
    # pause any playback components
    if currentRoutine is not None:
        for comp in currentRoutine.getPlaybackComponents():
            comp.pause()
    # make sure we have a keyboard
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        defaultKeyboard = deviceManager.addKeyboard(
            deviceClass='keyboard',
            deviceName='defaultKeyboard',
            backend='ioHub',
        )
    # run a while loop while we wait to unpause
    while thisExp.status == PAUSED:
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=['escape']):
            endExperiment(thisExp, win=win)
        # dispatch messages on response components
        if currentRoutine is not None:
            for comp in currentRoutine.getDispatchComponents():
                comp.device.dispatchMessages()
        # sleep 1ms so other threads can execute
        clock.time.sleep(0.001)
    # if stop was requested while paused, quit
    if thisExp.status == FINISHED:
        endExperiment(thisExp, win=win)
    # resume any playback components
    if currentRoutine is not None:
        for comp in currentRoutine.getPlaybackComponents():
            comp.play()
    # reset any timers
    for timer in timers:
        timer.addTime(-pauseTimer.getTime())


def run(expInfo, thisExp, win, globalClock=None, thisSession=None):
    """
    Run the experiment flow.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    psychopy.visual.Window
        Window in which to run this experiment.
    globalClock : psychopy.core.clock.Clock or None
        Clock to get global time from - supply None to make a new one.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    # mark experiment as started
    thisExp.status = STARTED
    # make sure window is set to foreground to prevent losing focus
    win.winHandle.activate()
    # make sure variables created by exec are available globally
    exec = environmenttools.setExecEnvironment(globals())
    # get device handles from dict of input devices
    ioServer = deviceManager.ioServer
    # get/create a default keyboard (e.g. to check for escape)
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='ioHub'
        )
    eyetracker = deviceManager.getDevice('eyetracker')
    # make sure we're running in the directory for this experiment
    os.chdir(_thisDir)
    # get filename from ExperimentHandler for convenience
    filename = thisExp.dataFileName
    frameTolerance = 0.001  # how close to onset before 'same' frame
    endExpNow = False  # flag for 'escape' or other condition => quit the exp
    # get frame duration from frame rate in expInfo
    if 'frameRate' in expInfo and expInfo['frameRate'] is not None:
        frameDur = 1.0 / round(expInfo['frameRate'])
    else:
        frameDur = 1.0 / 60.0  # could not measure, so guess
    
    # Start Code - component code to be run after the window creation
    
    # --- Initialize components for Routine "Welcome_to_experiment" ---
    Welcome_eng_image = visual.ImageStim(
        win=win,
        name='Welcome_eng_image', 
        image='intro/Welcome_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 1.6),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    
    # --- Initialize components for Routine "Gender" ---
    Q_gender_text = visual.TextStim(win=win, name='Q_gender_text',
        text='1.What is your gender?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.15, wrapWidth=1.3, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    gender_female_button = visual.ButtonStim(win, 
        text='Female', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='gender_female_button',
        depth=-1
    )
    gender_female_button.buttonClock = core.Clock()
    gender_male_button = visual.ButtonStim(win, 
        text='Male', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='gender_male_button',
        depth=-2
    )
    gender_male_button.buttonClock = core.Clock()
    gender_nonbinary_button = visual.ButtonStim(win, 
        text='Non-binary/Transgender', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='gender_nonbinary_button',
        depth=-3
    )
    gender_nonbinary_button.buttonClock = core.Clock()
    gender_prefernot_button = visual.ButtonStim(win, 
        text='Prefer not to say', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='gender_prefernot_button',
        depth=-4
    )
    gender_prefernot_button.buttonClock = core.Clock()
    Q1 = visual.TextStim(win=win, name='Q1',
        text='Question 1 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "Age" ---
    Q_age_text = visual.TextStim(win=win, name='Q_age_text',
        text='2.What is your year of birth? (e.g., 1999)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.12, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_age = visual.TextBox2(
         win, text=None, placeholder='Enter 4-digit year', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(0.6, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_age',
         depth=-1, autoLog=True,
    )
    enter_hint_age = visual.TextStim(win=win, name='enter_hint_age',
        text='After answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    Q2 = visual.TextStim(win=win, name='Q2',
        text='Question 2 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "relationship_status" ---
    Q_relationship_status = visual.TextStim(win=win, name='Q_relationship_status',
        text='3.What is your current relationship status?',
        font='Arial',
        pos=(0, 0.45), draggable=False, height=0.1, wrapWidth=2.0, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    relationship_single = visual.ButtonStim(win, 
        text='Single ', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='relationship_single',
        depth=-1
    )
    relationship_single.buttonClock = core.Clock()
    relationship_Inarelationship = visual.ButtonStim(win, 
        text='In a relationship', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='relationship_Inarelationship',
        depth=-2
    )
    relationship_Inarelationship.buttonClock = core.Clock()
    relationship_Married = visual.ButtonStim(win, 
        text='Married', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='relationship_Married',
        depth=-3
    )
    relationship_Married.buttonClock = core.Clock()
    relationship_Divorced = visual.ButtonStim(win, 
        text='Divorced or widowed', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='relationship_Divorced',
        depth=-4
    )
    relationship_Divorced.buttonClock = core.Clock()
    Q3 = visual.TextStim(win=win, name='Q3',
        text='Question 3 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "nationality" ---
    nationality_text = visual.TextStim(win=win, name='nationality_text',
        text='4.What is your current nationality (citizenship)?\nPlease answer according to your passport or official document.',
        font='Arial',
        pos=(0, 0.45), draggable=False, height=0.1, wrapWidth=2.0, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    nationality_china = visual.ButtonStim(win, 
        text='China', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='nationality_china',
        depth=-1
    )
    nationality_china.buttonClock = core.Clock()
    nationality_malaysia = visual.ButtonStim(win, 
        text='Malaysia', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='nationality_malaysia',
        depth=-2
    )
    nationality_malaysia.buttonClock = core.Clock()
    nationality_other = visual.ButtonStim(win, 
        text='Other', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='nationality_other',
        depth=-3
    )
    nationality_other.buttonClock = core.Clock()
    nationality_prefernot = visual.ButtonStim(win, 
        text='Prefer not to say', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='nationality_prefernot',
        depth=-4
    )
    nationality_prefernot.buttonClock = core.Clock()
    Q4 = visual.TextStim(win=win, name='Q4',
        text='Question 4 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "Education" ---
    Q_edu_level_text_ = visual.TextStim(win=win, name='Q_edu_level_text_',
        text='5.What is the highest level of formal education you have completed?',
        font='Arial',
        pos=(0, 0.5), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    edu_btn_1 = visual.ButtonStim(win, 
        text='Primary school or below', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='edu_btn_1',
        depth=-1
    )
    edu_btn_1.buttonClock = core.Clock()
    edu_btn_2 = visual.ButtonStim(win, 
        text='Secondary / SPM', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='edu_btn_2',
        depth=-2
    )
    edu_btn_2.buttonClock = core.Clock()
    edu_btn_3 = visual.ButtonStim(win, 
        text='STPM / A level / Diploma', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='edu_btn_3',
        depth=-3
    )
    edu_btn_3.buttonClock = core.Clock()
    edu_btn_4 = visual.ButtonStim(win, 
        text='Degree', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='edu_btn_4',
        depth=-4
    )
    edu_btn_4.buttonClock = core.Clock()
    edu_btn_5 = visual.ButtonStim(win, 
        text='Master/Phd', font='Arial',
        pos=(0, -0.6),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='edu_btn_5',
        depth=-5
    )
    edu_btn_5.buttonClock = core.Clock()
    Q5 = visual.TextStim(win=win, name='Q5',
        text='Question 5 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    
    # --- Initialize components for Routine "religion" ---
    Q_religion_text = visual.TextStim(win=win, name='Q_religion_text',
        text='6.What is your religion or religious affiliation?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.15, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    religion_btn_1 = visual.ButtonStim(win, 
        text='Buddhism', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_1',
        depth=-1
    )
    religion_btn_1.buttonClock = core.Clock()
    religion_btn_2 = visual.ButtonStim(win, 
        text='Christian', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_2',
        depth=-2
    )
    religion_btn_2.buttonClock = core.Clock()
    religion_btn_3 = visual.ButtonStim(win, 
        text='Islam', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_3',
        depth=-3
    )
    religion_btn_3.buttonClock = core.Clock()
    religion_btn_4 = visual.ButtonStim(win, 
        text='Hinduism', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_4',
        depth=-4
    )
    religion_btn_4.buttonClock = core.Clock()
    religion_btn_5 = visual.ButtonStim(win, 
        text='Taoism / Folk religion', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_5',
        depth=-5
    )
    religion_btn_5.buttonClock = core.Clock()
    religion_btn_6 = visual.ButtonStim(win, 
        text='No religion', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_6',
        depth=-6
    )
    religion_btn_6.buttonClock = core.Clock()
    religion_btn_7 = visual.ButtonStim(win, 
        text='Others', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='religion_btn_7',
        depth=-7
    )
    religion_btn_7.buttonClock = core.Clock()
    Q6 = visual.TextStim(win=win, name='Q6',
        text='Question 6 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "ethnicity" ---
    Q_ethnicity_text = visual.TextStim(win=win, name='Q_ethnicity_text',
        text='7.Which ethnic group do you consider yourself to belong to?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    ethnicity_btn_1 = visual.ButtonStim(win, 
        text='Malay', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ethnicity_btn_1',
        depth=-1
    )
    ethnicity_btn_1.buttonClock = core.Clock()
    ethnicity_btn_2 = visual.ButtonStim(win, 
        text='Chinese', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ethnicity_btn_2',
        depth=-2
    )
    ethnicity_btn_2.buttonClock = core.Clock()
    ethnicity_btn_3 = visual.ButtonStim(win, 
        text='Indian', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ethnicity_btn_3',
        depth=-3
    )
    ethnicity_btn_3.buttonClock = core.Clock()
    ethnicity_btn_4 = visual.ButtonStim(win, 
        text='Others', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ethnicity_btn_4',
        depth=-4
    )
    ethnicity_btn_4.buttonClock = core.Clock()
    Q7 = visual.TextStim(win=win, name='Q7',
        text='Question 7 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "HouseholdStructure" ---
    householdstructure_question_text = visual.TextStim(win=win, name='householdstructure_question_text',
        text='8.Who do you currently live with?\n (Select all that apply; but if you select "I", do not select any other options)  \nPlease type the corresponding letter(s), e.g., A,C,E',
        font='Arial',
        pos=(0, 0.7), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_household = visual.TextBox2(
         win, text=None, placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, -0.4), draggable=False,      letterHeight=0.1,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_household',
         depth=-1, autoLog=True,
    )
    textbox_ABCDE = visual.TextBox2(
         win, text='A. Spouse\nB. Children\nC. Parents     \nD. Grandparents\nE. Grandchildren', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.7, 0.4), draggable=False,      letterHeight=0.1,
         size=(0.7, 0.5), borderWidth=3.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='top-left',
         anchor='top-left', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='textbox_ABCDE',
         depth=-2, autoLog=True,
    )
    textbox_FGHI = visual.TextBox2(
         win, text='F. Siblings  \nG. Other relatives  \nH. Non-relatives (e.g., friends)  \nI. I live alone  \n\n', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0.4), draggable=False,      letterHeight=0.1,
         size=(0.9, 0.5), borderWidth=3.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='top-left',
         anchor='top-left', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='textbox_FGHI',
         depth=-3, autoLog=True,
    )
    Q8 = visual.TextStim(win=win, name='Q8',
        text='Question 8 of 89\n',
        font='Arial',
        pos=(-0.7, -0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    hint_household = visual.TextStim(win=win, name='hint_household',
        text='After answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.65), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    
    # --- Initialize components for Routine "occupation_type" ---
    Q_occupation = visual.TextStim(win=win, name='Q_occupation',
        text='9.What is your current main occupation?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.13, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    occupation_Education = visual.ButtonStim(win, 
        text='Education / Training', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Education',
        depth=-1
    )
    occupation_Education.buttonClock = core.Clock()
    occupation_Healthcare = visual.ButtonStim(win, 
        text='Healthcare / Medical', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Healthcare',
        depth=-2
    )
    occupation_Healthcare.buttonClock = core.Clock()
    occupation_Government = visual.ButtonStim(win, 
        text='Government / NGO / Public service', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Government',
        depth=-3
    )
    occupation_Government.buttonClock = core.Clock()
    occupation_Business = visual.ButtonStim(win, 
        text='Business / Commerce / Sales', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Business',
        depth=-4
    )
    occupation_Business.buttonClock = core.Clock()
    occupation_Selfemployed = visual.ButtonStim(win, 
        text='Self-employed / Freelancer', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Selfemployed',
        depth=-5
    )
    occupation_Selfemployed.buttonClock = core.Clock()
    occupation_Homemaker = visual.ButtonStim(win, 
        text='Homemaker / Caregiver', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Homemaker',
        depth=-6
    )
    occupation_Homemaker.buttonClock = core.Clock()
    occupation_Student = visual.ButtonStim(win, 
        text='Student', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Student',
        depth=-7
    )
    occupation_Student.buttonClock = core.Clock()
    occupation_Unemployed = visual.ButtonStim(win, 
        text='Unemployed / Temporary / Seeking job', font='Arial',
        pos=(0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Unemployed',
        depth=-8
    )
    occupation_Unemployed.buttonClock = core.Clock()
    occupation_Retired = visual.ButtonStim(win, 
        text='Retired', font='Arial',
        pos=(0.0, -0.5),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Retired',
        depth=-9
    )
    occupation_Retired.buttonClock = core.Clock()
    occupation_Other = visual.ButtonStim(win, 
        text='Other', font='Arial',
        pos=(0.0, -0.7),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Other',
        depth=-10
    )
    occupation_Other.buttonClock = core.Clock()
    occupation_Prefernottosay = visual.ButtonStim(win, 
        text='Prefer not to say', font='Arial',
        pos=(0.0, -0.85),
        letterHeight=0.07,
        size=(0.7, 0.10), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='occupation_Prefernottosay',
        depth=-11
    )
    occupation_Prefernottosay.buttonClock = core.Clock()
    Q9 = visual.TextStim(win=win, name='Q9',
        text='Question 9 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-12.0);
    
    # --- Initialize components for Routine "family_income" ---
    Q_family_income = visual.TextStim(win=win, name='Q_family_income',
        text="10.What was your household's total income last year (approximate)?\nPlease enter the amount in your local currency according to your nationality.",
        font='Arial',
        pos=(0, 0.7), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    income_20000 = visual.ButtonStim(win, 
        text='20,000 or below', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_20000',
        depth=-1
    )
    income_20000.buttonClock = core.Clock()
    income_20001to50000 = visual.ButtonStim(win, 
        text='20,001 – 50,000', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_20001to50000',
        depth=-2
    )
    income_20001to50000.buttonClock = core.Clock()
    income_50001to100000 = visual.ButtonStim(win, 
        text='50,001 – 100,000', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_50001to100000',
        depth=-3
    )
    income_50001to100000.buttonClock = core.Clock()
    income_100001to150000 = visual.ButtonStim(win, 
        text='100,001 – 150,000', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_100001to150000',
        depth=-4
    )
    income_100001to150000.buttonClock = core.Clock()
    income_150001to200000 = visual.ButtonStim(win, 
        text='150,001 – 200,000', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_150001to200000',
        depth=-5
    )
    income_150001to200000.buttonClock = core.Clock()
    income_Morethan200000 = visual.ButtonStim(win, 
        text='More than 200,000', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_Morethan200000',
        depth=-6
    )
    income_Morethan200000.buttonClock = core.Clock()
    income_Prefernottosay = visual.ButtonStim(win, 
        text='Prefer not to say', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.7, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='income_Prefernottosay',
        depth=-7
    )
    income_Prefernottosay.buttonClock = core.Clock()
    Q10 = visual.TextStim(win=win, name='Q10',
        text='Question 10 of 89\n',
        font='Arial',
        pos=(-0.7, -0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "height" ---
    Q_height_text = visual.TextStim(win=win, name='Q_height_text',
        text='11.Please enter your height in cm (e.g., 165)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.12, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_height = visual.TextBox2(
         win, text=None, placeholder='Type Here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(0.5, 0.15), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_height',
         depth=-1, autoLog=True,
    )
    height_hint = visual.TextStim(win=win, name='height_hint',
        text='This item is optional and will only be used for calculating health indicators, not for identification.\n\nAfter answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.08, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    Q11 = visual.TextStim(win=win, name='Q11',
        text='Question 11 of 89\n',
        font='Arial',
        pos=(-0.5, 0.8), draggable=False, height=0.08, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "weight" ---
    Q_weight_text = visual.TextStim(win=win, name='Q_weight_text',
        text='12.Please enter your weight in kg (e.g., 55)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.13, wrapWidth=2.0, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_weight = visual.TextBox2(
         win, text=None, placeholder='Type Here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(0.7, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_weight',
         depth=-1, autoLog=True,
    )
    weight_hint = visual.TextStim(win=win, name='weight_hint',
        text='This item will only be used for calculating health indicators, not for identification.\n\nAfter answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.07, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    Q12 = visual.TextStim(win=win, name='Q12',
        text='Question 12 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "waistline" ---
    Q_waistline_text = visual.TextStim(win=win, name='Q_waistline_text',
        text='13.What is your waist circumference? (cm)\n(Please fill in a number, for example, 90)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_waistline = visual.TextBox2(
         win, text=None, placeholder='Please enter...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(0.7, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_waistline',
         depth=-1, autoLog=True,
    )
    waistline_hint = visual.TextStim(win=win, name='waistline_hint',
        text='This project is only used for calculating health indicators, not for identity verification. Please feel free to fill in. \nAfter answering, please press the Enter key to move to the next question.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.07, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    Q13 = visual.TextStim(win=win, name='Q13',
        text='Question 13 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "ever_drink_alcohol" ---
    Q_ever_drink_alcohol = visual.TextStim(win=win, name='Q_ever_drink_alcohol',
        text='14.Have you ever consumed any type of alcoholic beverage\n(e.g., rice wine, yellow wine, red wine, or other alcohol-containing drinks)?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    ever_drink_alcohol_yes = visual.ButtonStim(win, 
        text='Yes', font='Arial',
        pos=(0, 0.1),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ever_drink_alcohol_yes',
        depth=-1
    )
    ever_drink_alcohol_yes.buttonClock = core.Clock()
    ever_drink_alcohol_no = visual.ButtonStim(win, 
        text='No', font='Arial',
        pos=(0, -0.1),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ever_drink_alcohol_no',
        depth=-2
    )
    ever_drink_alcohol_no.buttonClock = core.Clock()
    Q14 = visual.TextStim(win=win, name='Q14',
        text='Question 14 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "last_drink_time" ---
    Q_last_drink_time = visual.TextStim(win=win, name='Q_last_drink_time',
        text='15.When was the last time you drank alcohol?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.12, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    last_drink_time_30days = visual.ButtonStim(win, 
        text='Within the past 30 days', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.08,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='last_drink_time_30days',
        depth=-1
    )
    last_drink_time_30days.buttonClock = core.Clock()
    last_drink_time_in12mons = visual.ButtonStim(win, 
        text='Within the past 12 months', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.08,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='last_drink_time_in12mons',
        depth=-2
    )
    last_drink_time_in12mons.buttonClock = core.Clock()
    last_drink_time_over12mons = visual.ButtonStim(win, 
        text='More than 12 months ago', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.08,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='last_drink_time_over12mons',
        depth=-3
    )
    last_drink_time_over12mons.buttonClock = core.Clock()
    last_drink_time_never = visual.ButtonStim(win, 
        text='Never drank alcohol', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.08,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='last_drink_time_never',
        depth=-4
    )
    last_drink_time_never.buttonClock = core.Clock()
    Q15 = visual.TextStim(win=win, name='Q15',
        text='Question 15 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "drink_freq_12mo_2" ---
    Q_drink_freq_12mo = visual.TextStim(win=win, name='Q_drink_freq_12mo',
        text='16.In the past 12 months, how often did you usually drink alcohol?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    drink_freq_12mo_Everyday = visual.ButtonStim(win, 
        text='Every day', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_freq_12mo_Everyday',
        depth=-1
    )
    drink_freq_12mo_Everyday.buttonClock = core.Clock()
    drink_freq_12mo_Severaltimesaweek = visual.ButtonStim(win, 
        text='Several times a week', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_freq_12mo_Severaltimesaweek',
        depth=-2
    )
    drink_freq_12mo_Severaltimesaweek.buttonClock = core.Clock()
    drink_freq_12mo_Severaltimesamonth = visual.ButtonStim(win, 
        text='Several times a month', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_freq_12mo_Severaltimesamonth',
        depth=-3
    )
    drink_freq_12mo_Severaltimesamonth.buttonClock = core.Clock()
    drink_freq_12mo_Rarely = visual.ButtonStim(win, 
        text='Rarely', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_freq_12mo_Rarely',
        depth=-4
    )
    drink_freq_12mo_Rarely.buttonClock = core.Clock()
    drink_freq_12mo_Never = visual.ButtonStim(win, 
        text='Never', font='Arial',
        pos=(0, -0.6),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_freq_12mo_Never',
        depth=-5
    )
    drink_freq_12mo_Never.buttonClock = core.Clock()
    Q16 = visual.TextStim(win=win, name='Q16',
        text='Question 16 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    
    # --- Initialize components for Routine "drink_amount_12mo" ---
    Q_drink_amount_12mo = visual.TextStim(win=win, name='Q_drink_amount_12mo',
        text='17.In the past 12 months, how many drinks did you usually consume each time?',
        font='Arial',
        pos=(0, 0.45), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    drink_amount_12mo_0glass = visual.ButtonStim(win, 
        text='0 drink', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_0glass',
        depth=-1
    )
    drink_amount_12mo_0glass.buttonClock = core.Clock()
    drink_amount_12mo_1glass = visual.ButtonStim(win, 
        text='1 drink', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_1glass',
        depth=-2
    )
    drink_amount_12mo_1glass.buttonClock = core.Clock()
    drink_amount_12mo_2glass = visual.ButtonStim(win, 
        text='2 drinks', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_2glass',
        depth=-3
    )
    drink_amount_12mo_2glass.buttonClock = core.Clock()
    drink_amount_12mo_3glasses = visual.ButtonStim(win, 
        text='3 drinks', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_3glasses',
        depth=-4
    )
    drink_amount_12mo_3glasses.buttonClock = core.Clock()
    drink_amount_12mo_4glasses = visual.ButtonStim(win, 
        text='4 drinks', font='Arial',
        pos=(0, -0.6),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_4glasses',
        depth=-5
    )
    drink_amount_12mo_4glasses.buttonClock = core.Clock()
    drink_amount_12mo_5glassesmore = visual.ButtonStim(win, 
        text='5 or more drinks', font='Arial',
        pos=(0, -0.8),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='drink_amount_12mo_5glassesmore',
        depth=-6
    )
    drink_amount_12mo_5glassesmore.buttonClock = core.Clock()
    Q17 = visual.TextStim(win=win, name='Q17',
        text='Question 17 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    
    # --- Initialize components for Routine "ever_smoke" ---
    Q_ever_smoke = visual.TextStim(win=win, name='Q_ever_smoke',
        text='18.Have you ever smoked?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    ever_smoke_yes = visual.ButtonStim(win, 
        text='Yes', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ever_smoke_yes',
        depth=-1
    )
    ever_smoke_yes.buttonClock = core.Clock()
    ever_smoke_no = visual.ButtonStim(win, 
        text='No', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='ever_smoke_no',
        depth=-2
    )
    ever_smoke_no.buttonClock = core.Clock()
    Q18 = visual.TextStim(win=win, name='Q18',
        text='Question 18 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "start_smoke_age" ---
    Q_start_smoke_age = visual.TextStim(win=win, name='Q_start_smoke_age',
        text='19.At approximately what age did you start smoking?(years old)\n(Please fill in the number, for example, 21; if you do not smoke, please fill in 0)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_start_smoke_age = visual.TextBox2(
         win, text=None, placeholder='Please enter...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(0.6, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_start_smoke_age',
         depth=-1, autoLog=True,
    )
    Q19 = visual.TextStim(win=win, name='Q19',
        text='Question 19 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    hit_star_smoke_age = visual.TextStim(win=win, name='hit_star_smoke_age',
        text='After answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "cigs_per_day" ---
    Q_cigs_per_day = visual.TextStim(win=win, name='Q_cigs_per_day',
        text='20.About how many cigarettes do you currently smoke per day?\n(Please fill in the number, for example, 10; if you do not smoke, please fill in 0)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_cigs_per_day = visual.TextBox2(
         win, text=None, placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, -0.2), draggable=False,      letterHeight=0.1,
         size=(0.6, 0.15), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_cigs_per_day',
         depth=-1, autoLog=True,
    )
    Q20 = visual.TextStim(win=win, name='Q20',
        text='Question 20 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    hit_cigs = visual.TextStim(win=win, name='hit_cigs',
        text='After answering, please press the "Enter" key to move to the next question.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.08, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "self_health_status" ---
    Q_self_health_status = visual.TextStim(win=win, name='Q_self_health_status',
        text='21.How would you rate your current health status?',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    self_health_status_Verygood = visual.ButtonStim(win, 
        text='Very good', font='Arial',
        pos=(0, 0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='self_health_status_Verygood',
        depth=-1
    )
    self_health_status_Verygood.buttonClock = core.Clock()
    self_health_status_Good = visual.ButtonStim(win, 
        text='Good', font='Arial',
        pos=(0, 0.0),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='self_health_status_Good',
        depth=-2
    )
    self_health_status_Good.buttonClock = core.Clock()
    self_health_status_Average = visual.ButtonStim(win, 
        text='Average', font='Arial',
        pos=(0, -0.2),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='self_health_status_Average',
        depth=-3
    )
    self_health_status_Average.buttonClock = core.Clock()
    self_health_status_Poor = visual.ButtonStim(win, 
        text='Poor', font='Arial',
        pos=(0, -0.4),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='self_health_status_Poor',
        depth=-4
    )
    self_health_status_Poor.buttonClock = core.Clock()
    self_health_status_Verypoor = visual.ButtonStim(win, 
        text='Very poor', font='Arial',
        pos=(0, -0.6),
        letterHeight=0.1,
        size=(1, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='self_health_status_Verypoor',
        depth=-5
    )
    self_health_status_Verypoor.buttonClock = core.Clock()
    Q21 = visual.TextStim(win=win, name='Q21',
        text='Question 21 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    
    # --- Initialize components for Routine "PHQ9_intro" ---
    PHQ9_intro_image = visual.ImageStim(
        win=win,
        name='PHQ9_intro_image', 
        image='intro/PHQ9_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.8),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_4 = keyboard.Keyboard(deviceName='key_resp_4')
    
    # --- Initialize components for Routine "PHQ_9" ---
    PHQ_9QuestionText = visual.TextStim(win=win, name='PHQ_9QuestionText',
        text='',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    PHQ_9questionslide = visual.Slider(win=win, name='PHQ_9questionslide',
        startValue=None, size=(1.5, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Not at all', 'Several days', 'More than half the days', 'Nearly every day'], ticks=(0, 1, 2, 3), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.06,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q22toQ30 = visual.TextStim(win=win, name='Q22toQ30',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "BPSQI_intro" ---
    BPSQI_intro_image = visual.ImageStim(
        win=win,
        name='BPSQI_intro_image', 
        image='intro/BPSQI_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.8),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_5 = keyboard.Keyboard(deviceName='key_resp_5')
    
    # --- Initialize components for Routine "B_PSQI_Q1_BedTime" ---
    Q1_BedTime = visual.TextStim(win=win, name='Q1_BedTime',
        text='31. When have you usually gone to bed at night?(e.g., 22:30)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_Q1Bedtime = visual.TextBox2(
         win, text=None, placeholder='Please enter the time', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(1.2, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=True, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_Q1Bedtime',
         depth=-1, autoLog=True,
    )
    enter_hint = visual.TextStim(win=win, name='enter_hint',
        text='Press Enter to continue after typing your answer.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    Q31 = visual.TextStim(win=win, name='Q31',
        text='Question 31 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "B_PSQI_Q2_WakeTime" ---
    Q2_WakeTime = visual.TextStim(win=win, name='Q2_WakeTime',
        text='32. When have you usually gotten up in the morning? (e.g., 07:00)',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_Q2WakeTime = visual.TextBox2(
         win, text=None, placeholder='Please enter the time.', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(1.2, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=True, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_Q2WakeTime',
         depth=-1, autoLog=True,
    )
    enter_hint_2 = visual.TextStim(win=win, name='enter_hint_2',
        text='Press Enter to continue after typing your answer.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    Q32 = visual.TextStim(win=win, name='Q32',
        text='Question 32 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "B_PSQI_Q3_SleepLatency" ---
    Q3_SleepLatency = visual.TextStim(win=win, name='Q3_SleepLatency',
        text='33. How long has it usually taken you to fall asleep each night?(minutes） (e.g., 15 minutes)\n',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_Q3SleepLatency = visual.TextBox2(
         win, text=None, placeholder='Please enter the time.', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(1.2, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=True, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_Q3SleepLatency',
         depth=-1, autoLog=True,
    )
    enter_hint_3 = visual.TextStim(win=win, name='enter_hint_3',
        text='Press Enter to continue after typing your answer.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    Q33 = visual.TextStim(win=win, name='Q33',
        text='Question 33 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "B_PSQI_Q4_ActualSleep" ---
    Q4_ActualSleep = visual.TextStim(win=win, name='Q4_ActualSleep',
        text='34. How many hours of actual sleep did you get at night? (e.g., 6 hours)\n※ Please estimate the number of hours you were actually asleep, not the total time you spent in bed.\n\n',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.9, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    textbox_Q4ActualSleep = visual.TextBox2(
         win, text=None, placeholder='Please enter the time.', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.1,
         size=(1.2, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=True, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=True,
         name='textbox_Q4ActualSleep',
         depth=-1, autoLog=True,
    )
    enter_hint_4 = visual.TextStim(win=win, name='enter_hint_4',
        text='Press Enter to continue after typing your answer.',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.1, wrapWidth=1.5, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    Q34 = visual.TextStim(win=win, name='Q34',
        text='Question 34 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "B_PSQI5" ---
    B_PSQIquestionText = visual.TextStim(win=win, name='B_PSQIquestionText',
        text='',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    B_PSQIquestionslide = visual.Slider(win=win, name='B_PSQIquestionslide',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Not during the past month','Less than once a week', 'Once or twice a week', 'Three or more times a week'], ticks=(0, 1, 2, 3), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.06,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q35 = visual.TextStim(win=win, name='Q35',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "B_PSQI6" ---
    B_PSQIquestionText6 = visual.TextStim(win=win, name='B_PSQIquestionText6',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    B_PSQIquestionslide6 = visual.Slider(win=win, name='B_PSQIquestionslide6',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Very bad', 'Fairly bad', 'Fairly good', 'Very good'], ticks=(0, 1, 2, 3), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q36 = visual.TextStim(win=win, name='Q36',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "Durel_intro" ---
    DUREL_intro_image = visual.ImageStim(
        win=win,
        name='DUREL_intro_image', 
        image='intro/DUREL_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_6 = keyboard.Keyboard(deviceName='key_resp_6')
    
    # --- Initialize components for Routine "DUREL1" ---
    DUREL_questionText = visual.TextStim(win=win, name='DUREL_questionText',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    DURELquestionslide = visual.Slider(win=win, name='DURELquestionslide',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Never', 'Once a year or less', 'A few times a year', 'A few times a month', 'Once a week', 'More than once/week'], ticks=(1, 2, 3, 4, 5, 6), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.06,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q37 = visual.TextStim(win=win, name='Q37',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "DUREL2" ---
    DUREL_questionText2 = visual.TextStim(win=win, name='DUREL_questionText2',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    DURELquestionslide2 = visual.Slider(win=win, name='DURELquestionslide2',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Rarely or never', 'A few times a month', 'Once a week', 'Two or more times/week', 'Daily', 'More than once a day'], ticks=(1, 2, 3, 4, 5, 6), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.06,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q38 = visual.TextStim(win=win, name='Q38',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "DUREL345" ---
    DUREL_questionText345 = visual.TextStim(win=win, name='DUREL_questionText345',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    DURELquestionslide345 = visual.Slider(win=win, name='DURELquestionslide345',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Definitely not true', 'Tends not to be true', 'Unsure', 'Tends to be true', 'Definitely true'], ticks=(1, 2, 3, 4, 5), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.06,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q39toQ41 = visual.TextStim(win=win, name='Q39toQ41',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "BMRQ_intro" ---
    BMRQ_intro_image = visual.ImageStim(
        win=win,
        name='BMRQ_intro_image', 
        image='intro/BMRQ_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.7),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_7 = keyboard.Keyboard(deviceName='key_resp_7')
    
    # --- Initialize components for Routine "BMRQ" ---
    BMRQ_questionText = visual.TextStim(win=win, name='BMRQ_questionText',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.8, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    BMRQ_slider = visual.Slider(win=win, name='BMRQ_slider',
        startValue=None, size=(1.45, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Strongly disagree', 'disagree', 'Neutral', 'Agree', 'Strongly agree'], ticks=(1, 2, 3, 4, 5), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q42toQ61 = visual.TextStim(win=win, name='Q42toQ61',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "PAI_intro" ---
    PAI_intro_image = visual.ImageStim(
        win=win,
        name='PAI_intro_image', 
        image='intro/PAI_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.7),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_8 = keyboard.Keyboard(deviceName='key_resp_8')
    
    # --- Initialize components for Routine "PAI" ---
    PAI_questionText = visual.TextStim(win=win, name='PAI_questionText',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.8, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    PAIquestionslide = visual.Slider(win=win, name='PAIquestionslide',
        startValue=None, size=(1.4, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Strongly disagree', 'Disagree', 'Agree', 'Strongly agree'], ticks=(1, 2, 3, 4), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q62toQ65 = visual.TextStim(win=win, name='Q62toQ65',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "SOI_intro" ---
    SOI_intro_image = visual.ImageStim(
        win=win,
        name='SOI_intro_image', 
        image='intro/SOI_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 1.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_12 = keyboard.Keyboard(deviceName='key_resp_12')
    
    # --- Initialize components for Routine "Soi123" ---
    Q_Soi123 = visual.TextStim(win=win, name='Q_Soi123',
        text='',
        font='Arial',
        pos=(0, 0.4), draggable=False, height=0.1, wrapWidth=1.8, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    SOI123_slide = visual.Slider(win=win, name='SOI123_slide',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['0', '1', '2', '3','4', '5~6', '7~9', '10~19', '20 or more'], ticks=(0, 1, 2, 3, 4, 5, 6, 7, 8), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q66toQ68 = visual.TextStim(win=win, name='Q66toQ68',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_3 = visual.TextStim(win=win, name='text_3',
        text='※ Please note: This is a numerical question. The options below represent the number of people.',
        font='Arial',
        pos=(0, -0.65), draggable=False, height=0.08, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "Soi456" ---
    Q_Soi456 = visual.TextStim(win=win, name='Q_Soi456',
        text='',
        font='Arial',
        pos=(0, 0.3), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    SOI456_Slide = visual.Slider(win=win, name='SOI456_Slide',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.1), units=win.units,
        labels=['1  Strongly disagree', '2', '3', '4', '5', '6', '7', '8', '9  Strongly agree'], ticks=(1, 2, 3, 4, 5, 6, 7, 8, 9), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor=[-1.0000, -1.0000, -1.0000], colorSpace='rgb',
        font='Open Sans', labelHeight=0.064,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q69toQ71 = visual.TextStim(win=win, name='Q69toQ71',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_4 = visual.TextStim(win=win, name='text_4',
        text='※ Please note: This is a degree-of-agreement question. Please respond based on how much you disagree or agree.',
        font='Arial',
        pos=(0, -0.75), draggable=False, height=0.08, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "SOI7" ---
    Q_SOI7 = visual.TextStim(win=win, name='Q_SOI7',
        text='72. How often do you have fantasies about having sex with someone you are not in a committed romantic relationship with?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    SOI7_1_never = visual.ButtonStim(win, 
        text='1 – never', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_1_never',
        depth=-1
    )
    SOI7_1_never.buttonClock = core.Clock()
    SOI7_2_veryseldom = visual.ButtonStim(win, 
        text='2 – very seldom ', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_2_veryseldom',
        depth=-2
    )
    SOI7_2_veryseldom.buttonClock = core.Clock()
    SOI7_3_once_every_2or3_months = visual.ButtonStim(win, 
        text='3 – about once every two or three months ', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_3_once_every_2or3_months',
        depth=-3
    )
    SOI7_3_once_every_2or3_months.buttonClock = core.Clock()
    SOI7_4_onceamonth = visual.ButtonStim(win, 
        text='4 – about once a month', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_4_onceamonth',
        depth=-4
    )
    SOI7_4_onceamonth.buttonClock = core.Clock()
    SOI7_5_once_every_two_weeks = visual.ButtonStim(win, 
        text='5 – about once every two weeks ', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_5_once_every_two_weeks',
        depth=-5
    )
    SOI7_5_once_every_two_weeks.buttonClock = core.Clock()
    SOI7_6_onceaweek = visual.ButtonStim(win, 
        text='6 – about once a week ', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_6_onceaweek',
        depth=-6
    )
    SOI7_6_onceaweek.buttonClock = core.Clock()
    SOI7_7_several_times_per_week = visual.ButtonStim(win, 
        text='7 – several times per week ', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_7_several_times_per_week',
        depth=-7
    )
    SOI7_7_several_times_per_week.buttonClock = core.Clock()
    SOI7_8_early_every_day = visual.ButtonStim(win, 
        text='8 – nearly every day', font='Arial',
        pos=(0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_8_early_every_day',
        depth=-8
    )
    SOI7_8_early_every_day.buttonClock = core.Clock()
    SOI7_9_atleastonceaday = visual.ButtonStim(win, 
        text='9 – at least once a day', font='Arial',
        pos=(0.0, -0.5),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI7_9_atleastonceaday',
        depth=-9
    )
    SOI7_9_atleastonceaday.buttonClock = core.Clock()
    Q72 = visual.TextStim(win=win, name='Q72',
        text='Question 72 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "SOI8" ---
    Q_SOI8 = visual.TextStim(win=win, name='Q_SOI8',
        text='73. How often do you experience sexual arousal when you are in contact with someone you are not in a committed romantic relationship with?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    SOI8_1_never = visual.ButtonStim(win, 
        text='1 – never', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_1_never',
        depth=-1
    )
    SOI8_1_never.buttonClock = core.Clock()
    SOI8_2_veryseldom = visual.ButtonStim(win, 
        text='2 – very seldom ', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_2_veryseldom',
        depth=-2
    )
    SOI8_2_veryseldom.buttonClock = core.Clock()
    SOI8_3_once_every_2or3_months = visual.ButtonStim(win, 
        text='3 – about once every two or three months ', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_3_once_every_2or3_months',
        depth=-3
    )
    SOI8_3_once_every_2or3_months.buttonClock = core.Clock()
    SOI8_4_onceamonth = visual.ButtonStim(win, 
        text='4 – about once a month', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_4_onceamonth',
        depth=-4
    )
    SOI8_4_onceamonth.buttonClock = core.Clock()
    SOI8_5_once_every_two_weeks = visual.ButtonStim(win, 
        text='5 – about once every two weeks ', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_5_once_every_two_weeks',
        depth=-5
    )
    SOI8_5_once_every_two_weeks.buttonClock = core.Clock()
    SOI8_6_onceaweek = visual.ButtonStim(win, 
        text='6 – about once a week ', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_6_onceaweek',
        depth=-6
    )
    SOI8_6_onceaweek.buttonClock = core.Clock()
    SOI8_7_several_times_per_week = visual.ButtonStim(win, 
        text='7 – several times per week ', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_7_several_times_per_week',
        depth=-7
    )
    SOI8_7_several_times_per_week.buttonClock = core.Clock()
    SOI8_8_early_every_day = visual.ButtonStim(win, 
        text='8 – nearly every day', font='Arial',
        pos=(0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_8_early_every_day',
        depth=-8
    )
    SOI8_8_early_every_day.buttonClock = core.Clock()
    SOI8_9_atleastonceaday = visual.ButtonStim(win, 
        text='9 – at least once a day', font='Arial',
        pos=(0.0, -0.5),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI8_9_atleastonceaday',
        depth=-9
    )
    SOI8_9_atleastonceaday.buttonClock = core.Clock()
    Q73 = visual.TextStim(win=win, name='Q73',
        text='Question 73 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "SOI9" ---
    Q_SOI9 = visual.TextStim(win=win, name='Q_SOI9',
        text='74. In everyday life, how often do you have spontaneous fantasies about having sex with someone you have just met?',
        font='Arial',
        pos=(0, 0.6), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    SOI9_1_never = visual.ButtonStim(win, 
        text='1 – never', font='Arial',
        pos=(-0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_1_never',
        depth=-1
    )
    SOI9_1_never.buttonClock = core.Clock()
    SOI9_2_veryseldom = visual.ButtonStim(win, 
        text='2 – very seldom ', font='Arial',
        pos=(0.5, 0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_2_veryseldom',
        depth=-2
    )
    SOI9_2_veryseldom.buttonClock = core.Clock()
    SOI9_3_once_every_2or3_months = visual.ButtonStim(win, 
        text='3 – about once every two or three months ', font='Arial',
        pos=(-0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_3_once_every_2or3_months',
        depth=-3
    )
    SOI9_3_once_every_2or3_months.buttonClock = core.Clock()
    SOI9_4_onceamonth = visual.ButtonStim(win, 
        text='4 – about once a month', font='Arial',
        pos=(0.5, 0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_4_onceamonth',
        depth=-4
    )
    SOI9_4_onceamonth.buttonClock = core.Clock()
    SOI9_5_once_every_two_weeks = visual.ButtonStim(win, 
        text='5 – about once every two weeks ', font='Arial',
        pos=(-0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_5_once_every_two_weeks',
        depth=-5
    )
    SOI9_5_once_every_two_weeks.buttonClock = core.Clock()
    SOI9_6_onceaweek = visual.ButtonStim(win, 
        text='6 – about once a week ', font='Arial',
        pos=(0.5, -0.1),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_6_onceaweek',
        depth=-6
    )
    SOI9_6_onceaweek.buttonClock = core.Clock()
    SOI9_7_several_times_per_week = visual.ButtonStim(win, 
        text='7 – several times per week ', font='Arial',
        pos=(-0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_7_several_times_per_week',
        depth=-7
    )
    SOI9_7_several_times_per_week.buttonClock = core.Clock()
    SOI9_8_early_every_day = visual.ButtonStim(win, 
        text='8 – nearly every day', font='Arial',
        pos=(0.5, -0.3),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_8_early_every_day',
        depth=-8
    )
    SOI9_8_early_every_day.buttonClock = core.Clock()
    SOI9_9_atleastonceaday = visual.ButtonStim(win, 
        text='9 – at least once a day', font='Arial',
        pos=(0.0, -0.5),
        letterHeight=0.07,
        size=(0.9, 0.15), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='white', borderColor=None,
        color='black', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='SOI9_9_atleastonceaday',
        depth=-9
    )
    SOI9_9_atleastonceaday.buttonClock = core.Clock()
    Q74 = visual.TextStim(win=win, name='Q74',
        text='Question 74 of 89\n',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "ATAI_intro" ---
    ATAI_intro_image = visual.ImageStim(
        win=win,
        name='ATAI_intro_image', 
        image='intro/ATAI_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.8),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_9 = keyboard.Keyboard(deviceName='key_resp_9')
    
    # --- Initialize components for Routine "ATAI" ---
    ATAI_QuestionText = visual.TextStim(win=win, name='ATAI_QuestionText',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    ATAIquestionslide = visual.Slider(win=win, name='ATAIquestionslide',
        startValue=None, size=(1.6, 0.07), pos=(0, -0.2), units=win.units,
        labels=['0  Strongly disagree', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10   Strongly agree'], ticks=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor=[-1.0000, -1.0000, -1.0000], colorSpace='rgb',
        font='Open Sans', labelHeight=0.05,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q75toQ79 = visual.TextStim(win=win, name='Q75toQ79',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "BSSS4_intro" ---
    BSSS4_intro_image = visual.ImageStim(
        win=win,
        name='BSSS4_intro_image', 
        image='intro/BSSS4_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.7),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_10 = keyboard.Keyboard(deviceName='key_resp_10')
    
    # --- Initialize components for Routine "BSSS" ---
    BSSS_questiontext = visual.TextStim(win=win, name='BSSS_questiontext',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    BSSS_questionslide = visual.Slider(win=win, name='BSSS_questionslide',
        startValue=None, size=(1.45, 0.07), pos=(0, -0.2), units=win.units,
        labels=['Strongly disagree', 'Disagree', 'Neither agree nor disagree', 'Agree', 'Strongly agree'], ticks=(1, 2, 3, 4, 5), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q80toQ87 = visual.TextStim(win=win, name='Q80toQ87',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "BPAAT_intro" ---
    BPAAT_intro_image = visual.ImageStim(
        win=win,
        name='BPAAT_intro_image', 
        image='intro/BPAAT_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 0.7),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_11 = keyboard.Keyboard(deviceName='key_resp_11')
    
    # --- Initialize components for Routine "BPAAT1" ---
    BPAAT_questiontext1 = visual.TextStim(win=win, name='BPAAT_questiontext1',
        text='',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    BPAATquestionslide1 = visual.Slider(win=win, name='BPAATquestionslide1',
        startValue=None, size=(1.4, 0.07), pos=(0, -0.2), units=win.units,
        labels=['none', '1–2 times/week', '>3 times/week'], ticks=(0, 2, 4), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.08,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q88 = visual.TextStim(win=win, name='Q88',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "BPAAT2" ---
    BPAAT_questiontext2 = visual.TextStim(win=win, name='BPAAT_questiontext2',
        text='',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.1, wrapWidth=1.9, ori=0, 
        color='black', colorSpace='rgb', opacity=1, 
        languageStyle='LTR',
        depth=0.0);
    BPAATquestionslide2 = visual.Slider(win=win, name='BPAATquestionslide2',
        startValue=None, size=(1.5, 0.07), pos=(0, -0.2), units=win.units,
        labels=['none', '1–2 times/week', '3–4 times/week', '>5 times/week'], ticks=(0, 1, 2, 3), granularity=1,
        style=['radio'], styleTweaks=(), opacity=1,
        labelColor='black', markerColor='red', lineColor='black', colorSpace='rgb',
        font='Open Sans', labelHeight=0.07,
        flip=False, ori=0, depth=-1, readOnly=False)
    Q89 = visual.TextStim(win=win, name='Q89',
        text='',
        font='Arial',
        pos=(-0.7, 0.8), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "finishQUESTION_intro" ---
    finish_questions_image = visual.ImageStim(
        win=win,
        name='finish_questions_image', 
        image='intro/finishquestions_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.8, 0.9),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    resp_2 = keyboard.Keyboard(deviceName='resp_2')
    
    # --- Initialize components for Routine "instructions" ---
    background = visual.ImageStim(
        win=win,
        name='background', 
        image='intro/Bart_intro_english.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(1.9, 1.8),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    resp = keyboard.Keyboard(deviceName='resp')
    pop_sound = sound.Sound(
        'A', 
        secs=1.0, 
        stereo=True, 
        hamming=True, 
        speaker='pop_sound',    name='pop_sound'
    )
    pop_sound.setVolume(0.0)
    
    # --- Initialize components for Routine "reset_balloon" ---
    
    # --- Initialize components for Routine "practice_trial" ---
    practice_bg = visual.ImageStim(
        win=win,
        name='practice_bg', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    practice_bankButton = keyboard.Keyboard(deviceName='practice_bankButton')
    # Run 'Begin Experiment' code from practice_updateEarnings
    bankedEarnings=0.0
    balloonEarnings = ''
    bankedText = ''
    lastBalloonEarnings=0.0
    thisBalloonEarnings=0.0
    practice_reminder = visual.TextBox2(
         win, text='Press SPACE to pump the balloon\nPress RETURN to bank this sum\n', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_reminder',
         depth=-3, autoLog=True,
    )
    practice_balloonValTxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_balloonValTxt',
         depth=-4, autoLog=True,
    )
    practice_bankedTxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_bankedTxt',
         depth=-5, autoLog=True,
    )
    # Run 'Begin Experiment' code from practice_setBalloonSize
    balloonSize=0.08
    balloonMsgHeight=0.01
    practice_balloonBody = visual.ImageStim(
        win=win,
        name='practice_balloonBody', units='height', 
        image='assets/redBalloon.png', mask=None, anchor='center',
        ori=-90, pos=[0,0], draggable=False, size=1.0,
        color=[1,1,1], colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=-7.0)
    practice_trialcount = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_trialcount',
         depth=-8, autoLog=True,
    )
    
    # --- Initialize components for Routine "practice_feedback" ---
    practice_background_3 = visual.ImageStim(
        win=win,
        name='practice_background_3', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    # Run 'Begin Experiment' code from practice_checkPopped
    feedbackText=""
    
    practice_feedbacktxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0,0), draggable=False,      letterHeight=0.05,
         size=(0.4, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_feedbacktxt',
         depth=-2, autoLog=True,
    )
    practice_bankedTxt_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_bankedTxt_2',
         depth=-3, autoLog=True,
    )
    practice_reminder_2 = visual.TextBox2(
         win, text='Press SPACE to pump the balloon\nPress RETURN to bank this sum', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_reminder_2',
         depth=-4, autoLog=True,
    )
    practice_trialcount_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_trialcount_2',
         depth=-5, autoLog=True,
    )
    
    # --- Initialize components for Routine "practice_finalScore" ---
    practice_background_4 = visual.ImageStim(
        win=win,
        name='practice_background_4', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    practice_scoremsg = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.04,
         size=(1, 0.7), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='practice_scoremsg',
         depth=-2, autoLog=True,
    )
    text = visual.TextStim(win=win, name='text',
        text='请按空格键（Space）',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    key_resp = keyboard.Keyboard(deviceName='key_resp')
    
    # --- Initialize components for Routine "resetmoneypractice" ---
    
    # --- Initialize components for Routine "comprehension_check" ---
    understand_2 = visual.TextStim(win=win, name='understand_2',
        text='Do you understand the experimental rules?\n\n\nIf you have understood the experimental rules, please press the "Y" key to enter the formal experiment;\n\n\nIf you still don\'t quite understand the operation method, please press the "N" key. The system will arrange for you to go through the practice session again.',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_comprehension = keyboard.Keyboard(deviceName='key_resp_comprehension')
    
    # --- Initialize components for Routine "Preparing_to_BART_formally" ---
    understand3_formal_BART = visual.TextStim(win=win, name='understand3_formal_BART',
        text='Are you ready? \nPlease press "Y" again to start the formal experiment.',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_comprehension_2 = keyboard.Keyboard(deviceName='key_resp_comprehension_2')
    
    # --- Initialize components for Routine "resetmoney" ---
    
    # --- Initialize components for Routine "reset_balloon" ---
    
    # --- Initialize components for Routine "trial" ---
    background_2 = visual.ImageStim(
        win=win,
        name='background_2', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    bankButton = keyboard.Keyboard(deviceName='bankButton')
    # Run 'Begin Experiment' code from updateEarnings
    bankedEarnings=0.0
    balloonEarnings = ''
    bankedText = ''
    lastBalloonEarnings=0.0
    thisBalloonEarnings=0.0
    reminder = visual.TextBox2(
         win, text='Press SPACE to pump the balloon\nPress RETURN to bank this sum', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='reminder',
         depth=-3, autoLog=True,
    )
    balloonValTxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='balloonValTxt',
         depth=-4, autoLog=True,
    )
    bankedTxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='bankedTxt',
         depth=-5, autoLog=True,
    )
    # Run 'Begin Experiment' code from setBalloonSize
    balloonSize=0.08
    balloonMsgHeight=0.01
    balloonBody = visual.ImageStim(
        win=win,
        name='balloonBody', units='height', 
        image='assets/redBalloon.png', mask=None, anchor='center',
        ori=-90, pos=[0,0], draggable=False, size=1.0,
        color=[1,1,1], colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=-7.0)
    trialcount = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='trialcount',
         depth=-8, autoLog=True,
    )
    
    # --- Initialize components for Routine "feedback" ---
    background_3 = visual.ImageStim(
        win=win,
        name='background_3', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    # Run 'Begin Experiment' code from checkPopped
    feedbackText=""
    
    feedbacktxt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0,0), draggable=False,      letterHeight=0.05,
         size=(0.4, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='feedbacktxt',
         depth=-2, autoLog=True,
    )
    bankedTxt_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='bankedTxt_2',
         depth=-3, autoLog=True,
    )
    balloonValTxt_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, 0.4), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='balloonValTxt_2',
         depth=-4, autoLog=True,
    )
    reminder_2 = visual.TextBox2(
         win, text='Press SPACE to pump the balloon\nPress RETURN to bank this sum\n', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='reminder_2',
         depth=-5, autoLog=True,
    )
    trialcount_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0.4, -0.3), draggable=False,      letterHeight=0.03,
         size=(0.5, 0.2), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='trialcount_2',
         depth=-6, autoLog=True,
    )
    
    # --- Initialize components for Routine "finalScore" ---
    background_4 = visual.ImageStim(
        win=win,
        name='background_4', 
        image='assets/background.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2.2, 1),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    scoremsg = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.05,
         size=(1, 0.7), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='scoremsg',
         depth=-2, autoLog=True,
    )
    text_2 = visual.TextStim(win=win, name='text_2',
        text='Please press the "SPACE" key',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    key_resp_2 = keyboard.Keyboard(deviceName='key_resp_2')
    
    # --- Initialize components for Routine "instruction_fish" ---
    background_fish = visual.ImageStim(
        win=win,
        name='background_fish', units='norm', 
        image='images/lake5.jpg', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2, 2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    instructions_txt_fish = visual.TextBox2(
         win, text='Welcome to our game!\n\nIn this game you will need to catch as many fish as possible. \n\nYou will be able to choose between three lakes from which to fish. \n\nClick the lake you want to fish from.\n\nTry to maximise the number of fish you catch!', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.06,
         size=(1.5, 0.8), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='instructions_txt_fish',
         depth=-1, autoLog=True,
    )
    mouse_start = event.Mouse(win=win)
    x, y = [None, None]
    mouse_start.mouseClock = core.Clock()
    start_button_fish = visual.ButtonStim(win, 
        text='START', font='Arvo',
        pos=(0, -0.4),
        letterHeight=0.05,
        size=(0.3, 0.1), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='darkgrey', borderColor=None,
        color='white', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='start_button_fish',
        depth=-3
    )
    start_button_fish.buttonClock = core.Clock()
    
    # --- Initialize components for Routine "trial_fish" ---
    instruct_fish = visual.TextBox2(
         win, text='Click a lake to fish!', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0.4), draggable=False,      letterHeight=0.05,
         size=(1, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='instruct_fish',
         depth=0, autoLog=True,
    )
    lake1 = visual.ImageStim(
        win=win,
        name='lake1', 
        image='images/lake1.jpg', mask=None, anchor='center',
        ori=0.0, pos=(-0.5, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    lake2 = visual.ImageStim(
        win=win,
        name='lake2', 
        image='images/lake2.jpg', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    lake3 = visual.ImageStim(
        win=win,
        name='lake3', 
        image='images/lake3.png', mask=None, anchor='center',
        ori=0.0, pos=(0.5, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    mouse = event.Mouse(win=win)
    x, y = [None, None]
    mouse.mouseClock = core.Clock()
    rod = visual.ImageStim(
        win=win,
        name='rod', 
        image='images/rod.png', mask=None, anchor='center',
        ori=0.0, pos=[0,0], draggable=False, size=(0.3, 0.3),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    # Run 'Begin Experiment' code from control_wins
    #initialise the wins (empty to start)
    lake1_wins = []
    lake2_wins = []
    lake3_wins = []
    
    # count number of fish won
    nfish = 0
    fishcountim = visual.ImageStim(
        win=win,
        name='fishcountim', 
        image='images/fish1.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.4, -0.4), draggable=False, size=(0.1, 0.07),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-7.0)
    fishcount = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.15, -0.4), draggable=False,      letterHeight=0.07,
         size=(0.5, 0.1), borderWidth=3.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='fishcount',
         depth=-8, autoLog=True,
    )
    # Run 'Begin Experiment' code from fishCounter
    fish_trial_index = 0
    
    fishTrialDisplay = visual.TextStim(win=win, name='fishTrialDisplay',
        text='',
        font='Arial',
        pos=(0.45, -0.4), draggable=False, height=0.07, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "feedback_fish" ---
    fb_txtbox = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0.3), draggable=False,      letterHeight=0.05,
         size=(1, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='fb_txtbox',
         depth=-1, autoLog=True,
    )
    fb_image = visual.ImageStim(
        win=win,
        name='fb_image', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.3),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    fishcountim_2 = visual.ImageStim(
        win=win,
        name='fishcountim_2', 
        image='images/fish1.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.4, -0.4), draggable=False, size=(0.1, 0.07),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    fishcount_2 = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(-0.2, -0.4), draggable=False,      letterHeight=0.03,
         size=(0.3, 0.1), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=None,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor=None, borderColor=None,
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='fishcount_2',
         depth=-4, autoLog=True,
    )
    
    # --- Initialize components for Routine "end_fish" ---
    background_5 = visual.ImageStim(
        win=win,
        name='background_5', units='norm', 
        image='images/lake5.jpg', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(2, 2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    end_txt = visual.TextBox2(
         win, text='', placeholder='Type here...', font='Arial',
         ori=0.0, pos=(0, 0), draggable=False,      letterHeight=0.09,
         size=(1.5, 0.8), borderWidth=2.0,
         color='black', colorSpace='rgb',
         opacity=0.8,
         bold=False, italic=False,
         lineSpacing=1.0, speechPoint=None,
         padding=0.0, alignment='center',
         anchor='center', overflow='visible',
         fillColor='white', borderColor='black',
         flipHoriz=False, flipVert=False, languageStyle='LTR',
         editable=False,
         name='end_txt',
         depth=-1, autoLog=True,
    )
    exit_button = visual.ButtonStim(win, 
        text='EXIT', font='Arvo',
        pos=(0, -0.4),
        letterHeight=0.05,
        size=(0.3, 0.1), 
        ori=0.0
        ,borderWidth=0.0,
        fillColor='darkgrey', borderColor=None,
        color='white', colorSpace='rgb',
        opacity=None,
        bold=True, italic=False,
        padding=None,
        anchor='center',
        name='exit_button',
        depth=-2
    )
    exit_button.buttonClock = core.Clock()
    text_5 = visual.TextStim(win=win, name='text_5',
        text='Thank you for your participation!\nPlease press the "Exit" button to finish the experiment and save your data.\nIf you close the window or exit manually, your data may not be saved properly.\n\n',
        font='Arial',
        pos=(0, 0.7), draggable=False, height=0.1, wrapWidth=1.8, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "dataupload" ---
    
    # create some handy timers
    
    # global clock to track the time since experiment started
    if globalClock is None:
        # create a clock if not given one
        globalClock = core.Clock()
    if isinstance(globalClock, str):
        # if given a string, make a clock accoridng to it
        if globalClock == 'float':
            # get timestamps as a simple value
            globalClock = core.Clock(format='float')
        elif globalClock == 'iso':
            # get timestamps in ISO format
            globalClock = core.Clock(format='%Y-%m-%d_%H:%M:%S.%f%z')
        else:
            # get timestamps in a custom format
            globalClock = core.Clock(format=globalClock)
    if ioServer is not None:
        ioServer.syncClock(globalClock)
    logging.setDefaultClock(globalClock)
    # routine timer to track time remaining of each (possibly non-slip) routine
    routineTimer = core.Clock()
    win.flip()  # flip window to reset last flip timer
    # store the exact time the global clock started
    expInfo['expStart'] = data.getDateStr(
        format='%Y-%m-%d %Hh%M.%S.%f %z', fractionalSecondDigits=6
    )
    
    # --- Prepare to start Routine "Welcome_to_experiment" ---
    # create an object to store info about Routine Welcome_to_experiment
    Welcome_to_experiment = data.Routine(
        name='Welcome_to_experiment',
        components=[Welcome_eng_image, key_resp_13],
    )
    Welcome_to_experiment.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_13
    key_resp_13.keys = []
    key_resp_13.rt = []
    _key_resp_13_allKeys = []
    # store start times for Welcome_to_experiment
    Welcome_to_experiment.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Welcome_to_experiment.tStart = globalClock.getTime(format='float')
    Welcome_to_experiment.status = STARTED
    thisExp.addData('Welcome_to_experiment.started', Welcome_to_experiment.tStart)
    Welcome_to_experiment.maxDuration = None
    # keep track of which components have finished
    Welcome_to_experimentComponents = Welcome_to_experiment.components
    for thisComponent in Welcome_to_experiment.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Welcome_to_experiment" ---
    Welcome_to_experiment.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Welcome_eng_image* updates
        
        # if Welcome_eng_image is starting this frame...
        if Welcome_eng_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Welcome_eng_image.frameNStart = frameN  # exact frame index
            Welcome_eng_image.tStart = t  # local t and not account for scr refresh
            Welcome_eng_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Welcome_eng_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Welcome_eng_image.started')
            # update status
            Welcome_eng_image.status = STARTED
            Welcome_eng_image.setAutoDraw(True)
        
        # if Welcome_eng_image is active this frame...
        if Welcome_eng_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_13* updates
        waitOnFlip = False
        
        # if key_resp_13 is starting this frame...
        if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_13.frameNStart = frameN  # exact frame index
            key_resp_13.tStart = t  # local t and not account for scr refresh
            key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_13.started')
            # update status
            key_resp_13.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_13.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_13.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_13_allKeys.extend(theseKeys)
            if len(_key_resp_13_allKeys):
                key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Welcome_to_experiment,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Welcome_to_experiment.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Welcome_to_experiment.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Welcome_to_experiment" ---
    for thisComponent in Welcome_to_experiment.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Welcome_to_experiment
    Welcome_to_experiment.tStop = globalClock.getTime(format='float')
    Welcome_to_experiment.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Welcome_to_experiment.stopped', Welcome_to_experiment.tStop)
    # check responses
    if key_resp_13.keys in ['', [], None]:  # No response was made
        key_resp_13.keys = None
    thisExp.addData('key_resp_13.keys',key_resp_13.keys)
    if key_resp_13.keys != None:  # we had a response
        thisExp.addData('key_resp_13.rt', key_resp_13.rt)
        thisExp.addData('key_resp_13.duration', key_resp_13.duration)
    thisExp.nextEntry()
    # the Routine "Welcome_to_experiment" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "Gender" ---
    # create an object to store info about Routine Gender
    Gender = data.Routine(
        name='Gender',
        components=[Q_gender_text, gender_female_button, gender_male_button, gender_nonbinary_button, gender_prefernot_button, Q1],
    )
    Gender.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset gender_female_button to account for continued clicks & clear times on/off
    gender_female_button.reset()
    # reset gender_male_button to account for continued clicks & clear times on/off
    gender_male_button.reset()
    # reset gender_nonbinary_button to account for continued clicks & clear times on/off
    gender_nonbinary_button.reset()
    # reset gender_prefernot_button to account for continued clicks & clear times on/off
    gender_prefernot_button.reset()
    # store start times for Gender
    Gender.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Gender.tStart = globalClock.getTime(format='float')
    Gender.status = STARTED
    thisExp.addData('Gender.started', Gender.tStart)
    Gender.maxDuration = None
    # keep track of which components have finished
    GenderComponents = Gender.components
    for thisComponent in Gender.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Gender" ---
    Gender.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_gender_text* updates
        
        # if Q_gender_text is starting this frame...
        if Q_gender_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_gender_text.frameNStart = frameN  # exact frame index
            Q_gender_text.tStart = t  # local t and not account for scr refresh
            Q_gender_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_gender_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_gender_text.started')
            # update status
            Q_gender_text.status = STARTED
            Q_gender_text.setAutoDraw(True)
        
        # if Q_gender_text is active this frame...
        if Q_gender_text.status == STARTED:
            # update params
            pass
        # *gender_female_button* updates
        
        # if gender_female_button is starting this frame...
        if gender_female_button.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            gender_female_button.frameNStart = frameN  # exact frame index
            gender_female_button.tStart = t  # local t and not account for scr refresh
            gender_female_button.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(gender_female_button, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'gender_female_button.started')
            # update status
            gender_female_button.status = STARTED
            win.callOnFlip(gender_female_button.buttonClock.reset)
            gender_female_button.setAutoDraw(True)
        
        # if gender_female_button is active this frame...
        if gender_female_button.status == STARTED:
            # update params
            pass
            # check whether gender_female_button has been pressed
            if gender_female_button.isClicked:
                if not gender_female_button.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    gender_female_button.timesOn.append(gender_female_button.buttonClock.getTime())
                    gender_female_button.timesOff.append(gender_female_button.buttonClock.getTime())
                elif len(gender_female_button.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    gender_female_button.timesOff[-1] = gender_female_button.buttonClock.getTime()
                if not gender_female_button.wasClicked:
                    # end routine when gender_female_button is clicked
                    continueRoutine = False
                if not gender_female_button.wasClicked:
                    # run callback code when gender_female_button is clicked
                    thisExp.addData('gender', '1')
        # take note of whether gender_female_button was clicked, so that next frame we know if clicks are new
        gender_female_button.wasClicked = gender_female_button.isClicked and gender_female_button.status == STARTED
        # *gender_male_button* updates
        
        # if gender_male_button is starting this frame...
        if gender_male_button.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            gender_male_button.frameNStart = frameN  # exact frame index
            gender_male_button.tStart = t  # local t and not account for scr refresh
            gender_male_button.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(gender_male_button, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'gender_male_button.started')
            # update status
            gender_male_button.status = STARTED
            win.callOnFlip(gender_male_button.buttonClock.reset)
            gender_male_button.setAutoDraw(True)
        
        # if gender_male_button is active this frame...
        if gender_male_button.status == STARTED:
            # update params
            pass
            # check whether gender_male_button has been pressed
            if gender_male_button.isClicked:
                if not gender_male_button.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    gender_male_button.timesOn.append(gender_male_button.buttonClock.getTime())
                    gender_male_button.timesOff.append(gender_male_button.buttonClock.getTime())
                elif len(gender_male_button.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    gender_male_button.timesOff[-1] = gender_male_button.buttonClock.getTime()
                if not gender_male_button.wasClicked:
                    # end routine when gender_male_button is clicked
                    continueRoutine = False
                if not gender_male_button.wasClicked:
                    # run callback code when gender_male_button is clicked
                    thisExp.addData('gender', '2')
        # take note of whether gender_male_button was clicked, so that next frame we know if clicks are new
        gender_male_button.wasClicked = gender_male_button.isClicked and gender_male_button.status == STARTED
        # *gender_nonbinary_button* updates
        
        # if gender_nonbinary_button is starting this frame...
        if gender_nonbinary_button.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            gender_nonbinary_button.frameNStart = frameN  # exact frame index
            gender_nonbinary_button.tStart = t  # local t and not account for scr refresh
            gender_nonbinary_button.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(gender_nonbinary_button, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'gender_nonbinary_button.started')
            # update status
            gender_nonbinary_button.status = STARTED
            win.callOnFlip(gender_nonbinary_button.buttonClock.reset)
            gender_nonbinary_button.setAutoDraw(True)
        
        # if gender_nonbinary_button is active this frame...
        if gender_nonbinary_button.status == STARTED:
            # update params
            pass
            # check whether gender_nonbinary_button has been pressed
            if gender_nonbinary_button.isClicked:
                if not gender_nonbinary_button.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    gender_nonbinary_button.timesOn.append(gender_nonbinary_button.buttonClock.getTime())
                    gender_nonbinary_button.timesOff.append(gender_nonbinary_button.buttonClock.getTime())
                elif len(gender_nonbinary_button.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    gender_nonbinary_button.timesOff[-1] = gender_nonbinary_button.buttonClock.getTime()
                if not gender_nonbinary_button.wasClicked:
                    # end routine when gender_nonbinary_button is clicked
                    continueRoutine = False
                if not gender_nonbinary_button.wasClicked:
                    # run callback code when gender_nonbinary_button is clicked
                    thisExp.addData('gender', '3')
        # take note of whether gender_nonbinary_button was clicked, so that next frame we know if clicks are new
        gender_nonbinary_button.wasClicked = gender_nonbinary_button.isClicked and gender_nonbinary_button.status == STARTED
        # *gender_prefernot_button* updates
        
        # if gender_prefernot_button is starting this frame...
        if gender_prefernot_button.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            gender_prefernot_button.frameNStart = frameN  # exact frame index
            gender_prefernot_button.tStart = t  # local t and not account for scr refresh
            gender_prefernot_button.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(gender_prefernot_button, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'gender_prefernot_button.started')
            # update status
            gender_prefernot_button.status = STARTED
            win.callOnFlip(gender_prefernot_button.buttonClock.reset)
            gender_prefernot_button.setAutoDraw(True)
        
        # if gender_prefernot_button is active this frame...
        if gender_prefernot_button.status == STARTED:
            # update params
            pass
            # check whether gender_prefernot_button has been pressed
            if gender_prefernot_button.isClicked:
                if not gender_prefernot_button.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    gender_prefernot_button.timesOn.append(gender_prefernot_button.buttonClock.getTime())
                    gender_prefernot_button.timesOff.append(gender_prefernot_button.buttonClock.getTime())
                elif len(gender_prefernot_button.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    gender_prefernot_button.timesOff[-1] = gender_prefernot_button.buttonClock.getTime()
                if not gender_prefernot_button.wasClicked:
                    # end routine when gender_prefernot_button is clicked
                    continueRoutine = False
                if not gender_prefernot_button.wasClicked:
                    # run callback code when gender_prefernot_button is clicked
                    thisExp.addData('gender', '99')
        # take note of whether gender_prefernot_button was clicked, so that next frame we know if clicks are new
        gender_prefernot_button.wasClicked = gender_prefernot_button.isClicked and gender_prefernot_button.status == STARTED
        
        # *Q1* updates
        
        # if Q1 is starting this frame...
        if Q1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q1.frameNStart = frameN  # exact frame index
            Q1.tStart = t  # local t and not account for scr refresh
            Q1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q1, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q1.started')
            # update status
            Q1.status = STARTED
            Q1.setAutoDraw(True)
        
        # if Q1 is active this frame...
        if Q1.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Gender,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Gender.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Gender.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Gender" ---
    for thisComponent in Gender.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Gender
    Gender.tStop = globalClock.getTime(format='float')
    Gender.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Gender.stopped', Gender.tStop)
    thisExp.addData('gender_female_button.numClicks', gender_female_button.numClicks)
    if gender_female_button.numClicks:
       thisExp.addData('gender_female_button.timesOn', gender_female_button.timesOn)
       thisExp.addData('gender_female_button.timesOff', gender_female_button.timesOff)
    else:
       thisExp.addData('gender_female_button.timesOn', "")
       thisExp.addData('gender_female_button.timesOff', "")
    thisExp.addData('gender_male_button.numClicks', gender_male_button.numClicks)
    if gender_male_button.numClicks:
       thisExp.addData('gender_male_button.timesOn', gender_male_button.timesOn)
       thisExp.addData('gender_male_button.timesOff', gender_male_button.timesOff)
    else:
       thisExp.addData('gender_male_button.timesOn', "")
       thisExp.addData('gender_male_button.timesOff', "")
    thisExp.addData('gender_nonbinary_button.numClicks', gender_nonbinary_button.numClicks)
    if gender_nonbinary_button.numClicks:
       thisExp.addData('gender_nonbinary_button.timesOn', gender_nonbinary_button.timesOn)
       thisExp.addData('gender_nonbinary_button.timesOff', gender_nonbinary_button.timesOff)
    else:
       thisExp.addData('gender_nonbinary_button.timesOn', "")
       thisExp.addData('gender_nonbinary_button.timesOff', "")
    thisExp.addData('gender_prefernot_button.numClicks', gender_prefernot_button.numClicks)
    if gender_prefernot_button.numClicks:
       thisExp.addData('gender_prefernot_button.timesOn', gender_prefernot_button.timesOn)
       thisExp.addData('gender_prefernot_button.timesOff', gender_prefernot_button.timesOff)
    else:
       thisExp.addData('gender_prefernot_button.timesOn', "")
       thisExp.addData('gender_prefernot_button.timesOff', "")
    thisExp.nextEntry()
    # the Routine "Gender" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "Age" ---
    # create an object to store info about Routine Age
    Age = data.Routine(
        name='Age',
        components=[Q_age_text, textbox_age, enter_hint_age, Q2],
    )
    Age.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_age.reset()
    # store start times for Age
    Age.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Age.tStart = globalClock.getTime(format='float')
    Age.status = STARTED
    thisExp.addData('Age.started', Age.tStart)
    Age.maxDuration = None
    # keep track of which components have finished
    AgeComponents = Age.components
    for thisComponent in Age.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Age" ---
    Age.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_age_text* updates
        
        # if Q_age_text is starting this frame...
        if Q_age_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_age_text.frameNStart = frameN  # exact frame index
            Q_age_text.tStart = t  # local t and not account for scr refresh
            Q_age_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_age_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_age_text.started')
            # update status
            Q_age_text.status = STARTED
            Q_age_text.setAutoDraw(True)
        
        # if Q_age_text is active this frame...
        if Q_age_text.status == STARTED:
            # update params
            pass
        
        # *textbox_age* updates
        
        # if textbox_age is starting this frame...
        if textbox_age.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_age.frameNStart = frameN  # exact frame index
            textbox_age.tStart = t  # local t and not account for scr refresh
            textbox_age.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_age, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_age.started')
            # update status
            textbox_age.status = STARTED
            textbox_age.setAutoDraw(True)
        
        # if textbox_age is active this frame...
        if textbox_age.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_3
        if not hasattr(thisExp, 'allow_advance_age'):
            thisExp.allow_advance_age = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_age.text.strip()
            if user_input != '':
                thisExp.allow_advance_age = True
        
        if thisExp.allow_advance_age:
            continueRoutine = False
        
        
        # *enter_hint_age* updates
        
        # if enter_hint_age is starting this frame...
        if enter_hint_age.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            enter_hint_age.frameNStart = frameN  # exact frame index
            enter_hint_age.tStart = t  # local t and not account for scr refresh
            enter_hint_age.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(enter_hint_age, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'enter_hint_age.started')
            # update status
            enter_hint_age.status = STARTED
            enter_hint_age.setAutoDraw(True)
        
        # if enter_hint_age is active this frame...
        if enter_hint_age.status == STARTED:
            # update params
            pass
        
        # *Q2* updates
        
        # if Q2 is starting this frame...
        if Q2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q2.frameNStart = frameN  # exact frame index
            Q2.tStart = t  # local t and not account for scr refresh
            Q2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q2.started')
            # update status
            Q2.status = STARTED
            Q2.setAutoDraw(True)
        
        # if Q2 is active this frame...
        if Q2.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Age,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Age.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Age.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Age" ---
    for thisComponent in Age.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Age
    Age.tStop = globalClock.getTime(format='float')
    Age.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Age.stopped', Age.tStop)
    thisExp.addData('textbox_age.text',textbox_age.text)
    # Run 'End Routine' code from code_3
    thisExp.addData('age', textbox_age.text)
    
    thisExp.nextEntry()
    # the Routine "Age" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "relationship_status" ---
    # create an object to store info about Routine relationship_status
    relationship_status = data.Routine(
        name='relationship_status',
        components=[Q_relationship_status, relationship_single, relationship_Inarelationship, relationship_Married, relationship_Divorced, Q3],
    )
    relationship_status.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset relationship_single to account for continued clicks & clear times on/off
    relationship_single.reset()
    # reset relationship_Inarelationship to account for continued clicks & clear times on/off
    relationship_Inarelationship.reset()
    # reset relationship_Married to account for continued clicks & clear times on/off
    relationship_Married.reset()
    # reset relationship_Divorced to account for continued clicks & clear times on/off
    relationship_Divorced.reset()
    # store start times for relationship_status
    relationship_status.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    relationship_status.tStart = globalClock.getTime(format='float')
    relationship_status.status = STARTED
    thisExp.addData('relationship_status.started', relationship_status.tStart)
    relationship_status.maxDuration = None
    # keep track of which components have finished
    relationship_statusComponents = relationship_status.components
    for thisComponent in relationship_status.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "relationship_status" ---
    relationship_status.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_relationship_status* updates
        
        # if Q_relationship_status is starting this frame...
        if Q_relationship_status.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_relationship_status.frameNStart = frameN  # exact frame index
            Q_relationship_status.tStart = t  # local t and not account for scr refresh
            Q_relationship_status.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_relationship_status, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_relationship_status.started')
            # update status
            Q_relationship_status.status = STARTED
            Q_relationship_status.setAutoDraw(True)
        
        # if Q_relationship_status is active this frame...
        if Q_relationship_status.status == STARTED:
            # update params
            pass
        # *relationship_single* updates
        
        # if relationship_single is starting this frame...
        if relationship_single.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            relationship_single.frameNStart = frameN  # exact frame index
            relationship_single.tStart = t  # local t and not account for scr refresh
            relationship_single.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(relationship_single, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'relationship_single.started')
            # update status
            relationship_single.status = STARTED
            win.callOnFlip(relationship_single.buttonClock.reset)
            relationship_single.setAutoDraw(True)
        
        # if relationship_single is active this frame...
        if relationship_single.status == STARTED:
            # update params
            pass
            # check whether relationship_single has been pressed
            if relationship_single.isClicked:
                if not relationship_single.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    relationship_single.timesOn.append(relationship_single.buttonClock.getTime())
                    relationship_single.timesOff.append(relationship_single.buttonClock.getTime())
                elif len(relationship_single.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    relationship_single.timesOff[-1] = relationship_single.buttonClock.getTime()
                if not relationship_single.wasClicked:
                    # end routine when relationship_single is clicked
                    continueRoutine = False
                if not relationship_single.wasClicked:
                    # run callback code when relationship_single is clicked
                    thisExp.addData('relationship_status', '1')
        # take note of whether relationship_single was clicked, so that next frame we know if clicks are new
        relationship_single.wasClicked = relationship_single.isClicked and relationship_single.status == STARTED
        # *relationship_Inarelationship* updates
        
        # if relationship_Inarelationship is starting this frame...
        if relationship_Inarelationship.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            relationship_Inarelationship.frameNStart = frameN  # exact frame index
            relationship_Inarelationship.tStart = t  # local t and not account for scr refresh
            relationship_Inarelationship.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(relationship_Inarelationship, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'relationship_Inarelationship.started')
            # update status
            relationship_Inarelationship.status = STARTED
            win.callOnFlip(relationship_Inarelationship.buttonClock.reset)
            relationship_Inarelationship.setAutoDraw(True)
        
        # if relationship_Inarelationship is active this frame...
        if relationship_Inarelationship.status == STARTED:
            # update params
            pass
            # check whether relationship_Inarelationship has been pressed
            if relationship_Inarelationship.isClicked:
                if not relationship_Inarelationship.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    relationship_Inarelationship.timesOn.append(relationship_Inarelationship.buttonClock.getTime())
                    relationship_Inarelationship.timesOff.append(relationship_Inarelationship.buttonClock.getTime())
                elif len(relationship_Inarelationship.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    relationship_Inarelationship.timesOff[-1] = relationship_Inarelationship.buttonClock.getTime()
                if not relationship_Inarelationship.wasClicked:
                    # end routine when relationship_Inarelationship is clicked
                    continueRoutine = False
                if not relationship_Inarelationship.wasClicked:
                    # run callback code when relationship_Inarelationship is clicked
                    thisExp.addData('relationship_status', '2')
        # take note of whether relationship_Inarelationship was clicked, so that next frame we know if clicks are new
        relationship_Inarelationship.wasClicked = relationship_Inarelationship.isClicked and relationship_Inarelationship.status == STARTED
        # *relationship_Married* updates
        
        # if relationship_Married is starting this frame...
        if relationship_Married.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            relationship_Married.frameNStart = frameN  # exact frame index
            relationship_Married.tStart = t  # local t and not account for scr refresh
            relationship_Married.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(relationship_Married, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'relationship_Married.started')
            # update status
            relationship_Married.status = STARTED
            win.callOnFlip(relationship_Married.buttonClock.reset)
            relationship_Married.setAutoDraw(True)
        
        # if relationship_Married is active this frame...
        if relationship_Married.status == STARTED:
            # update params
            pass
            # check whether relationship_Married has been pressed
            if relationship_Married.isClicked:
                if not relationship_Married.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    relationship_Married.timesOn.append(relationship_Married.buttonClock.getTime())
                    relationship_Married.timesOff.append(relationship_Married.buttonClock.getTime())
                elif len(relationship_Married.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    relationship_Married.timesOff[-1] = relationship_Married.buttonClock.getTime()
                if not relationship_Married.wasClicked:
                    # end routine when relationship_Married is clicked
                    continueRoutine = False
                if not relationship_Married.wasClicked:
                    # run callback code when relationship_Married is clicked
                    thisExp.addData('relationship_status', '3')
        # take note of whether relationship_Married was clicked, so that next frame we know if clicks are new
        relationship_Married.wasClicked = relationship_Married.isClicked and relationship_Married.status == STARTED
        # *relationship_Divorced* updates
        
        # if relationship_Divorced is starting this frame...
        if relationship_Divorced.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            relationship_Divorced.frameNStart = frameN  # exact frame index
            relationship_Divorced.tStart = t  # local t and not account for scr refresh
            relationship_Divorced.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(relationship_Divorced, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'relationship_Divorced.started')
            # update status
            relationship_Divorced.status = STARTED
            win.callOnFlip(relationship_Divorced.buttonClock.reset)
            relationship_Divorced.setAutoDraw(True)
        
        # if relationship_Divorced is active this frame...
        if relationship_Divorced.status == STARTED:
            # update params
            pass
            # check whether relationship_Divorced has been pressed
            if relationship_Divorced.isClicked:
                if not relationship_Divorced.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    relationship_Divorced.timesOn.append(relationship_Divorced.buttonClock.getTime())
                    relationship_Divorced.timesOff.append(relationship_Divorced.buttonClock.getTime())
                elif len(relationship_Divorced.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    relationship_Divorced.timesOff[-1] = relationship_Divorced.buttonClock.getTime()
                if not relationship_Divorced.wasClicked:
                    # end routine when relationship_Divorced is clicked
                    continueRoutine = False
                if not relationship_Divorced.wasClicked:
                    # run callback code when relationship_Divorced is clicked
                    thisExp.addData('relationship_status', '4')
        # take note of whether relationship_Divorced was clicked, so that next frame we know if clicks are new
        relationship_Divorced.wasClicked = relationship_Divorced.isClicked and relationship_Divorced.status == STARTED
        
        # *Q3* updates
        
        # if Q3 is starting this frame...
        if Q3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q3.frameNStart = frameN  # exact frame index
            Q3.tStart = t  # local t and not account for scr refresh
            Q3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q3.started')
            # update status
            Q3.status = STARTED
            Q3.setAutoDraw(True)
        
        # if Q3 is active this frame...
        if Q3.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=relationship_status,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            relationship_status.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in relationship_status.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "relationship_status" ---
    for thisComponent in relationship_status.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for relationship_status
    relationship_status.tStop = globalClock.getTime(format='float')
    relationship_status.tStopRefresh = tThisFlipGlobal
    thisExp.addData('relationship_status.stopped', relationship_status.tStop)
    thisExp.addData('relationship_single.numClicks', relationship_single.numClicks)
    if relationship_single.numClicks:
       thisExp.addData('relationship_single.timesOn', relationship_single.timesOn)
       thisExp.addData('relationship_single.timesOff', relationship_single.timesOff)
    else:
       thisExp.addData('relationship_single.timesOn', "")
       thisExp.addData('relationship_single.timesOff', "")
    thisExp.addData('relationship_Inarelationship.numClicks', relationship_Inarelationship.numClicks)
    if relationship_Inarelationship.numClicks:
       thisExp.addData('relationship_Inarelationship.timesOn', relationship_Inarelationship.timesOn)
       thisExp.addData('relationship_Inarelationship.timesOff', relationship_Inarelationship.timesOff)
    else:
       thisExp.addData('relationship_Inarelationship.timesOn', "")
       thisExp.addData('relationship_Inarelationship.timesOff', "")
    thisExp.addData('relationship_Married.numClicks', relationship_Married.numClicks)
    if relationship_Married.numClicks:
       thisExp.addData('relationship_Married.timesOn', relationship_Married.timesOn)
       thisExp.addData('relationship_Married.timesOff', relationship_Married.timesOff)
    else:
       thisExp.addData('relationship_Married.timesOn', "")
       thisExp.addData('relationship_Married.timesOff', "")
    thisExp.addData('relationship_Divorced.numClicks', relationship_Divorced.numClicks)
    if relationship_Divorced.numClicks:
       thisExp.addData('relationship_Divorced.timesOn', relationship_Divorced.timesOn)
       thisExp.addData('relationship_Divorced.timesOff', relationship_Divorced.timesOff)
    else:
       thisExp.addData('relationship_Divorced.timesOn', "")
       thisExp.addData('relationship_Divorced.timesOff', "")
    thisExp.nextEntry()
    # the Routine "relationship_status" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "nationality" ---
    # create an object to store info about Routine nationality
    nationality = data.Routine(
        name='nationality',
        components=[nationality_text, nationality_china, nationality_malaysia, nationality_other, nationality_prefernot, Q4],
    )
    nationality.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset nationality_china to account for continued clicks & clear times on/off
    nationality_china.reset()
    # reset nationality_malaysia to account for continued clicks & clear times on/off
    nationality_malaysia.reset()
    # reset nationality_other to account for continued clicks & clear times on/off
    nationality_other.reset()
    # reset nationality_prefernot to account for continued clicks & clear times on/off
    nationality_prefernot.reset()
    # store start times for nationality
    nationality.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    nationality.tStart = globalClock.getTime(format='float')
    nationality.status = STARTED
    thisExp.addData('nationality.started', nationality.tStart)
    nationality.maxDuration = None
    # keep track of which components have finished
    nationalityComponents = nationality.components
    for thisComponent in nationality.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "nationality" ---
    nationality.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *nationality_text* updates
        
        # if nationality_text is starting this frame...
        if nationality_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            nationality_text.frameNStart = frameN  # exact frame index
            nationality_text.tStart = t  # local t and not account for scr refresh
            nationality_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nationality_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'nationality_text.started')
            # update status
            nationality_text.status = STARTED
            nationality_text.setAutoDraw(True)
        
        # if nationality_text is active this frame...
        if nationality_text.status == STARTED:
            # update params
            pass
        # *nationality_china* updates
        
        # if nationality_china is starting this frame...
        if nationality_china.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            nationality_china.frameNStart = frameN  # exact frame index
            nationality_china.tStart = t  # local t and not account for scr refresh
            nationality_china.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nationality_china, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'nationality_china.started')
            # update status
            nationality_china.status = STARTED
            win.callOnFlip(nationality_china.buttonClock.reset)
            nationality_china.setAutoDraw(True)
        
        # if nationality_china is active this frame...
        if nationality_china.status == STARTED:
            # update params
            pass
            # check whether nationality_china has been pressed
            if nationality_china.isClicked:
                if not nationality_china.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    nationality_china.timesOn.append(nationality_china.buttonClock.getTime())
                    nationality_china.timesOff.append(nationality_china.buttonClock.getTime())
                elif len(nationality_china.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    nationality_china.timesOff[-1] = nationality_china.buttonClock.getTime()
                if not nationality_china.wasClicked:
                    # end routine when nationality_china is clicked
                    continueRoutine = False
                if not nationality_china.wasClicked:
                    # run callback code when nationality_china is clicked
                    thisExp.addData('nationality', '1')
        # take note of whether nationality_china was clicked, so that next frame we know if clicks are new
        nationality_china.wasClicked = nationality_china.isClicked and nationality_china.status == STARTED
        # *nationality_malaysia* updates
        
        # if nationality_malaysia is starting this frame...
        if nationality_malaysia.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            nationality_malaysia.frameNStart = frameN  # exact frame index
            nationality_malaysia.tStart = t  # local t and not account for scr refresh
            nationality_malaysia.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nationality_malaysia, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'nationality_malaysia.started')
            # update status
            nationality_malaysia.status = STARTED
            win.callOnFlip(nationality_malaysia.buttonClock.reset)
            nationality_malaysia.setAutoDraw(True)
        
        # if nationality_malaysia is active this frame...
        if nationality_malaysia.status == STARTED:
            # update params
            pass
            # check whether nationality_malaysia has been pressed
            if nationality_malaysia.isClicked:
                if not nationality_malaysia.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    nationality_malaysia.timesOn.append(nationality_malaysia.buttonClock.getTime())
                    nationality_malaysia.timesOff.append(nationality_malaysia.buttonClock.getTime())
                elif len(nationality_malaysia.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    nationality_malaysia.timesOff[-1] = nationality_malaysia.buttonClock.getTime()
                if not nationality_malaysia.wasClicked:
                    # end routine when nationality_malaysia is clicked
                    continueRoutine = False
                if not nationality_malaysia.wasClicked:
                    # run callback code when nationality_malaysia is clicked
                    thisExp.addData('nationality', '2')
        # take note of whether nationality_malaysia was clicked, so that next frame we know if clicks are new
        nationality_malaysia.wasClicked = nationality_malaysia.isClicked and nationality_malaysia.status == STARTED
        # *nationality_other* updates
        
        # if nationality_other is starting this frame...
        if nationality_other.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            nationality_other.frameNStart = frameN  # exact frame index
            nationality_other.tStart = t  # local t and not account for scr refresh
            nationality_other.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nationality_other, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'nationality_other.started')
            # update status
            nationality_other.status = STARTED
            win.callOnFlip(nationality_other.buttonClock.reset)
            nationality_other.setAutoDraw(True)
        
        # if nationality_other is active this frame...
        if nationality_other.status == STARTED:
            # update params
            pass
            # check whether nationality_other has been pressed
            if nationality_other.isClicked:
                if not nationality_other.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    nationality_other.timesOn.append(nationality_other.buttonClock.getTime())
                    nationality_other.timesOff.append(nationality_other.buttonClock.getTime())
                elif len(nationality_other.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    nationality_other.timesOff[-1] = nationality_other.buttonClock.getTime()
                if not nationality_other.wasClicked:
                    # end routine when nationality_other is clicked
                    continueRoutine = False
                if not nationality_other.wasClicked:
                    # run callback code when nationality_other is clicked
                    thisExp.addData('nationality', '3')
        # take note of whether nationality_other was clicked, so that next frame we know if clicks are new
        nationality_other.wasClicked = nationality_other.isClicked and nationality_other.status == STARTED
        # *nationality_prefernot* updates
        
        # if nationality_prefernot is starting this frame...
        if nationality_prefernot.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            nationality_prefernot.frameNStart = frameN  # exact frame index
            nationality_prefernot.tStart = t  # local t and not account for scr refresh
            nationality_prefernot.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nationality_prefernot, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'nationality_prefernot.started')
            # update status
            nationality_prefernot.status = STARTED
            win.callOnFlip(nationality_prefernot.buttonClock.reset)
            nationality_prefernot.setAutoDraw(True)
        
        # if nationality_prefernot is active this frame...
        if nationality_prefernot.status == STARTED:
            # update params
            pass
            # check whether nationality_prefernot has been pressed
            if nationality_prefernot.isClicked:
                if not nationality_prefernot.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    nationality_prefernot.timesOn.append(nationality_prefernot.buttonClock.getTime())
                    nationality_prefernot.timesOff.append(nationality_prefernot.buttonClock.getTime())
                elif len(nationality_prefernot.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    nationality_prefernot.timesOff[-1] = nationality_prefernot.buttonClock.getTime()
                if not nationality_prefernot.wasClicked:
                    # end routine when nationality_prefernot is clicked
                    continueRoutine = False
                if not nationality_prefernot.wasClicked:
                    # run callback code when nationality_prefernot is clicked
                    thisExp.addData('nationality', '99')
        # take note of whether nationality_prefernot was clicked, so that next frame we know if clicks are new
        nationality_prefernot.wasClicked = nationality_prefernot.isClicked and nationality_prefernot.status == STARTED
        
        # *Q4* updates
        
        # if Q4 is starting this frame...
        if Q4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q4.frameNStart = frameN  # exact frame index
            Q4.tStart = t  # local t and not account for scr refresh
            Q4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q4.started')
            # update status
            Q4.status = STARTED
            Q4.setAutoDraw(True)
        
        # if Q4 is active this frame...
        if Q4.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=nationality,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            nationality.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in nationality.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "nationality" ---
    for thisComponent in nationality.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for nationality
    nationality.tStop = globalClock.getTime(format='float')
    nationality.tStopRefresh = tThisFlipGlobal
    thisExp.addData('nationality.stopped', nationality.tStop)
    thisExp.addData('nationality_china.numClicks', nationality_china.numClicks)
    if nationality_china.numClicks:
       thisExp.addData('nationality_china.timesOn', nationality_china.timesOn)
       thisExp.addData('nationality_china.timesOff', nationality_china.timesOff)
    else:
       thisExp.addData('nationality_china.timesOn', "")
       thisExp.addData('nationality_china.timesOff', "")
    thisExp.addData('nationality_malaysia.numClicks', nationality_malaysia.numClicks)
    if nationality_malaysia.numClicks:
       thisExp.addData('nationality_malaysia.timesOn', nationality_malaysia.timesOn)
       thisExp.addData('nationality_malaysia.timesOff', nationality_malaysia.timesOff)
    else:
       thisExp.addData('nationality_malaysia.timesOn', "")
       thisExp.addData('nationality_malaysia.timesOff', "")
    thisExp.addData('nationality_other.numClicks', nationality_other.numClicks)
    if nationality_other.numClicks:
       thisExp.addData('nationality_other.timesOn', nationality_other.timesOn)
       thisExp.addData('nationality_other.timesOff', nationality_other.timesOff)
    else:
       thisExp.addData('nationality_other.timesOn', "")
       thisExp.addData('nationality_other.timesOff', "")
    thisExp.addData('nationality_prefernot.numClicks', nationality_prefernot.numClicks)
    if nationality_prefernot.numClicks:
       thisExp.addData('nationality_prefernot.timesOn', nationality_prefernot.timesOn)
       thisExp.addData('nationality_prefernot.timesOff', nationality_prefernot.timesOff)
    else:
       thisExp.addData('nationality_prefernot.timesOn', "")
       thisExp.addData('nationality_prefernot.timesOff', "")
    thisExp.nextEntry()
    # the Routine "nationality" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "Education" ---
    # create an object to store info about Routine Education
    Education = data.Routine(
        name='Education',
        components=[Q_edu_level_text_, edu_btn_1, edu_btn_2, edu_btn_3, edu_btn_4, edu_btn_5, Q5],
    )
    Education.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset edu_btn_1 to account for continued clicks & clear times on/off
    edu_btn_1.reset()
    # reset edu_btn_2 to account for continued clicks & clear times on/off
    edu_btn_2.reset()
    # reset edu_btn_3 to account for continued clicks & clear times on/off
    edu_btn_3.reset()
    # reset edu_btn_4 to account for continued clicks & clear times on/off
    edu_btn_4.reset()
    # reset edu_btn_5 to account for continued clicks & clear times on/off
    edu_btn_5.reset()
    # store start times for Education
    Education.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Education.tStart = globalClock.getTime(format='float')
    Education.status = STARTED
    thisExp.addData('Education.started', Education.tStart)
    Education.maxDuration = None
    # keep track of which components have finished
    EducationComponents = Education.components
    for thisComponent in Education.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Education" ---
    Education.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_edu_level_text_* updates
        
        # if Q_edu_level_text_ is starting this frame...
        if Q_edu_level_text_.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_edu_level_text_.frameNStart = frameN  # exact frame index
            Q_edu_level_text_.tStart = t  # local t and not account for scr refresh
            Q_edu_level_text_.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_edu_level_text_, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_edu_level_text_.started')
            # update status
            Q_edu_level_text_.status = STARTED
            Q_edu_level_text_.setAutoDraw(True)
        
        # if Q_edu_level_text_ is active this frame...
        if Q_edu_level_text_.status == STARTED:
            # update params
            pass
        # *edu_btn_1* updates
        
        # if edu_btn_1 is starting this frame...
        if edu_btn_1.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            edu_btn_1.frameNStart = frameN  # exact frame index
            edu_btn_1.tStart = t  # local t and not account for scr refresh
            edu_btn_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(edu_btn_1, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'edu_btn_1.started')
            # update status
            edu_btn_1.status = STARTED
            win.callOnFlip(edu_btn_1.buttonClock.reset)
            edu_btn_1.setAutoDraw(True)
        
        # if edu_btn_1 is active this frame...
        if edu_btn_1.status == STARTED:
            # update params
            pass
            # check whether edu_btn_1 has been pressed
            if edu_btn_1.isClicked:
                if not edu_btn_1.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    edu_btn_1.timesOn.append(edu_btn_1.buttonClock.getTime())
                    edu_btn_1.timesOff.append(edu_btn_1.buttonClock.getTime())
                elif len(edu_btn_1.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    edu_btn_1.timesOff[-1] = edu_btn_1.buttonClock.getTime()
                if not edu_btn_1.wasClicked:
                    # end routine when edu_btn_1 is clicked
                    continueRoutine = False
                if not edu_btn_1.wasClicked:
                    # run callback code when edu_btn_1 is clicked
                    thisExp.addData('edu_level', '1')
        # take note of whether edu_btn_1 was clicked, so that next frame we know if clicks are new
        edu_btn_1.wasClicked = edu_btn_1.isClicked and edu_btn_1.status == STARTED
        # *edu_btn_2* updates
        
        # if edu_btn_2 is starting this frame...
        if edu_btn_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            edu_btn_2.frameNStart = frameN  # exact frame index
            edu_btn_2.tStart = t  # local t and not account for scr refresh
            edu_btn_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(edu_btn_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'edu_btn_2.started')
            # update status
            edu_btn_2.status = STARTED
            win.callOnFlip(edu_btn_2.buttonClock.reset)
            edu_btn_2.setAutoDraw(True)
        
        # if edu_btn_2 is active this frame...
        if edu_btn_2.status == STARTED:
            # update params
            pass
            # check whether edu_btn_2 has been pressed
            if edu_btn_2.isClicked:
                if not edu_btn_2.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    edu_btn_2.timesOn.append(edu_btn_2.buttonClock.getTime())
                    edu_btn_2.timesOff.append(edu_btn_2.buttonClock.getTime())
                elif len(edu_btn_2.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    edu_btn_2.timesOff[-1] = edu_btn_2.buttonClock.getTime()
                if not edu_btn_2.wasClicked:
                    # end routine when edu_btn_2 is clicked
                    continueRoutine = False
                if not edu_btn_2.wasClicked:
                    # run callback code when edu_btn_2 is clicked
                    thisExp.addData('edu_level', '2')
        # take note of whether edu_btn_2 was clicked, so that next frame we know if clicks are new
        edu_btn_2.wasClicked = edu_btn_2.isClicked and edu_btn_2.status == STARTED
        # *edu_btn_3* updates
        
        # if edu_btn_3 is starting this frame...
        if edu_btn_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            edu_btn_3.frameNStart = frameN  # exact frame index
            edu_btn_3.tStart = t  # local t and not account for scr refresh
            edu_btn_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(edu_btn_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'edu_btn_3.started')
            # update status
            edu_btn_3.status = STARTED
            win.callOnFlip(edu_btn_3.buttonClock.reset)
            edu_btn_3.setAutoDraw(True)
        
        # if edu_btn_3 is active this frame...
        if edu_btn_3.status == STARTED:
            # update params
            pass
            # check whether edu_btn_3 has been pressed
            if edu_btn_3.isClicked:
                if not edu_btn_3.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    edu_btn_3.timesOn.append(edu_btn_3.buttonClock.getTime())
                    edu_btn_3.timesOff.append(edu_btn_3.buttonClock.getTime())
                elif len(edu_btn_3.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    edu_btn_3.timesOff[-1] = edu_btn_3.buttonClock.getTime()
                if not edu_btn_3.wasClicked:
                    # end routine when edu_btn_3 is clicked
                    continueRoutine = False
                if not edu_btn_3.wasClicked:
                    # run callback code when edu_btn_3 is clicked
                    thisExp.addData('edu_level', '3')
                    
        # take note of whether edu_btn_3 was clicked, so that next frame we know if clicks are new
        edu_btn_3.wasClicked = edu_btn_3.isClicked and edu_btn_3.status == STARTED
        # *edu_btn_4* updates
        
        # if edu_btn_4 is starting this frame...
        if edu_btn_4.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            edu_btn_4.frameNStart = frameN  # exact frame index
            edu_btn_4.tStart = t  # local t and not account for scr refresh
            edu_btn_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(edu_btn_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'edu_btn_4.started')
            # update status
            edu_btn_4.status = STARTED
            win.callOnFlip(edu_btn_4.buttonClock.reset)
            edu_btn_4.setAutoDraw(True)
        
        # if edu_btn_4 is active this frame...
        if edu_btn_4.status == STARTED:
            # update params
            pass
            # check whether edu_btn_4 has been pressed
            if edu_btn_4.isClicked:
                if not edu_btn_4.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    edu_btn_4.timesOn.append(edu_btn_4.buttonClock.getTime())
                    edu_btn_4.timesOff.append(edu_btn_4.buttonClock.getTime())
                elif len(edu_btn_4.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    edu_btn_4.timesOff[-1] = edu_btn_4.buttonClock.getTime()
                if not edu_btn_4.wasClicked:
                    # end routine when edu_btn_4 is clicked
                    continueRoutine = False
                if not edu_btn_4.wasClicked:
                    # run callback code when edu_btn_4 is clicked
                    thisExp.addData('edu_level', '4')
        # take note of whether edu_btn_4 was clicked, so that next frame we know if clicks are new
        edu_btn_4.wasClicked = edu_btn_4.isClicked and edu_btn_4.status == STARTED
        # *edu_btn_5* updates
        
        # if edu_btn_5 is starting this frame...
        if edu_btn_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            edu_btn_5.frameNStart = frameN  # exact frame index
            edu_btn_5.tStart = t  # local t and not account for scr refresh
            edu_btn_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(edu_btn_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'edu_btn_5.started')
            # update status
            edu_btn_5.status = STARTED
            win.callOnFlip(edu_btn_5.buttonClock.reset)
            edu_btn_5.setAutoDraw(True)
        
        # if edu_btn_5 is active this frame...
        if edu_btn_5.status == STARTED:
            # update params
            pass
            # check whether edu_btn_5 has been pressed
            if edu_btn_5.isClicked:
                if not edu_btn_5.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    edu_btn_5.timesOn.append(edu_btn_5.buttonClock.getTime())
                    edu_btn_5.timesOff.append(edu_btn_5.buttonClock.getTime())
                elif len(edu_btn_5.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    edu_btn_5.timesOff[-1] = edu_btn_5.buttonClock.getTime()
                if not edu_btn_5.wasClicked:
                    # end routine when edu_btn_5 is clicked
                    continueRoutine = False
                if not edu_btn_5.wasClicked:
                    # run callback code when edu_btn_5 is clicked
                    thisExp.addData('edu_level', '5')
        # take note of whether edu_btn_5 was clicked, so that next frame we know if clicks are new
        edu_btn_5.wasClicked = edu_btn_5.isClicked and edu_btn_5.status == STARTED
        
        # *Q5* updates
        
        # if Q5 is starting this frame...
        if Q5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q5.frameNStart = frameN  # exact frame index
            Q5.tStart = t  # local t and not account for scr refresh
            Q5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q5.started')
            # update status
            Q5.status = STARTED
            Q5.setAutoDraw(True)
        
        # if Q5 is active this frame...
        if Q5.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Education,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Education.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Education.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Education" ---
    for thisComponent in Education.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Education
    Education.tStop = globalClock.getTime(format='float')
    Education.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Education.stopped', Education.tStop)
    thisExp.addData('edu_btn_1.numClicks', edu_btn_1.numClicks)
    if edu_btn_1.numClicks:
       thisExp.addData('edu_btn_1.timesOn', edu_btn_1.timesOn)
       thisExp.addData('edu_btn_1.timesOff', edu_btn_1.timesOff)
    else:
       thisExp.addData('edu_btn_1.timesOn', "")
       thisExp.addData('edu_btn_1.timesOff', "")
    thisExp.addData('edu_btn_2.numClicks', edu_btn_2.numClicks)
    if edu_btn_2.numClicks:
       thisExp.addData('edu_btn_2.timesOn', edu_btn_2.timesOn)
       thisExp.addData('edu_btn_2.timesOff', edu_btn_2.timesOff)
    else:
       thisExp.addData('edu_btn_2.timesOn', "")
       thisExp.addData('edu_btn_2.timesOff', "")
    thisExp.addData('edu_btn_3.numClicks', edu_btn_3.numClicks)
    if edu_btn_3.numClicks:
       thisExp.addData('edu_btn_3.timesOn', edu_btn_3.timesOn)
       thisExp.addData('edu_btn_3.timesOff', edu_btn_3.timesOff)
    else:
       thisExp.addData('edu_btn_3.timesOn', "")
       thisExp.addData('edu_btn_3.timesOff', "")
    thisExp.addData('edu_btn_4.numClicks', edu_btn_4.numClicks)
    if edu_btn_4.numClicks:
       thisExp.addData('edu_btn_4.timesOn', edu_btn_4.timesOn)
       thisExp.addData('edu_btn_4.timesOff', edu_btn_4.timesOff)
    else:
       thisExp.addData('edu_btn_4.timesOn', "")
       thisExp.addData('edu_btn_4.timesOff', "")
    thisExp.addData('edu_btn_5.numClicks', edu_btn_5.numClicks)
    if edu_btn_5.numClicks:
       thisExp.addData('edu_btn_5.timesOn', edu_btn_5.timesOn)
       thisExp.addData('edu_btn_5.timesOff', edu_btn_5.timesOff)
    else:
       thisExp.addData('edu_btn_5.timesOn', "")
       thisExp.addData('edu_btn_5.timesOff', "")
    thisExp.nextEntry()
    # the Routine "Education" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "religion" ---
    # create an object to store info about Routine religion
    religion = data.Routine(
        name='religion',
        components=[Q_religion_text, religion_btn_1, religion_btn_2, religion_btn_3, religion_btn_4, religion_btn_5, religion_btn_6, religion_btn_7, Q6],
    )
    religion.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset religion_btn_1 to account for continued clicks & clear times on/off
    religion_btn_1.reset()
    # reset religion_btn_2 to account for continued clicks & clear times on/off
    religion_btn_2.reset()
    # reset religion_btn_3 to account for continued clicks & clear times on/off
    religion_btn_3.reset()
    # reset religion_btn_4 to account for continued clicks & clear times on/off
    religion_btn_4.reset()
    # reset religion_btn_5 to account for continued clicks & clear times on/off
    religion_btn_5.reset()
    # reset religion_btn_6 to account for continued clicks & clear times on/off
    religion_btn_6.reset()
    # reset religion_btn_7 to account for continued clicks & clear times on/off
    religion_btn_7.reset()
    # store start times for religion
    religion.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    religion.tStart = globalClock.getTime(format='float')
    religion.status = STARTED
    thisExp.addData('religion.started', religion.tStart)
    religion.maxDuration = None
    # keep track of which components have finished
    religionComponents = religion.components
    for thisComponent in religion.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "religion" ---
    religion.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_religion_text* updates
        
        # if Q_religion_text is starting this frame...
        if Q_religion_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_religion_text.frameNStart = frameN  # exact frame index
            Q_religion_text.tStart = t  # local t and not account for scr refresh
            Q_religion_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_religion_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_religion_text.started')
            # update status
            Q_religion_text.status = STARTED
            Q_religion_text.setAutoDraw(True)
        
        # if Q_religion_text is active this frame...
        if Q_religion_text.status == STARTED:
            # update params
            pass
        # *religion_btn_1* updates
        
        # if religion_btn_1 is starting this frame...
        if religion_btn_1.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_1.frameNStart = frameN  # exact frame index
            religion_btn_1.tStart = t  # local t and not account for scr refresh
            religion_btn_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_1, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_1.started')
            # update status
            religion_btn_1.status = STARTED
            win.callOnFlip(religion_btn_1.buttonClock.reset)
            religion_btn_1.setAutoDraw(True)
        
        # if religion_btn_1 is active this frame...
        if religion_btn_1.status == STARTED:
            # update params
            pass
            # check whether religion_btn_1 has been pressed
            if religion_btn_1.isClicked:
                if not religion_btn_1.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_1.timesOn.append(religion_btn_1.buttonClock.getTime())
                    religion_btn_1.timesOff.append(religion_btn_1.buttonClock.getTime())
                elif len(religion_btn_1.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_1.timesOff[-1] = religion_btn_1.buttonClock.getTime()
                if not religion_btn_1.wasClicked:
                    # end routine when religion_btn_1 is clicked
                    continueRoutine = False
                if not religion_btn_1.wasClicked:
                    # run callback code when religion_btn_1 is clicked
                    thisExp.addData('religion_type', '1')
        # take note of whether religion_btn_1 was clicked, so that next frame we know if clicks are new
        religion_btn_1.wasClicked = religion_btn_1.isClicked and religion_btn_1.status == STARTED
        # *religion_btn_2* updates
        
        # if religion_btn_2 is starting this frame...
        if religion_btn_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_2.frameNStart = frameN  # exact frame index
            religion_btn_2.tStart = t  # local t and not account for scr refresh
            religion_btn_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_2.started')
            # update status
            religion_btn_2.status = STARTED
            win.callOnFlip(religion_btn_2.buttonClock.reset)
            religion_btn_2.setAutoDraw(True)
        
        # if religion_btn_2 is active this frame...
        if religion_btn_2.status == STARTED:
            # update params
            pass
            # check whether religion_btn_2 has been pressed
            if religion_btn_2.isClicked:
                if not religion_btn_2.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_2.timesOn.append(religion_btn_2.buttonClock.getTime())
                    religion_btn_2.timesOff.append(religion_btn_2.buttonClock.getTime())
                elif len(religion_btn_2.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_2.timesOff[-1] = religion_btn_2.buttonClock.getTime()
                if not religion_btn_2.wasClicked:
                    # end routine when religion_btn_2 is clicked
                    continueRoutine = False
                if not religion_btn_2.wasClicked:
                    # run callback code when religion_btn_2 is clicked
                    thisExp.addData('religion_type', '2')
        # take note of whether religion_btn_2 was clicked, so that next frame we know if clicks are new
        religion_btn_2.wasClicked = religion_btn_2.isClicked and religion_btn_2.status == STARTED
        # *religion_btn_3* updates
        
        # if religion_btn_3 is starting this frame...
        if religion_btn_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_3.frameNStart = frameN  # exact frame index
            religion_btn_3.tStart = t  # local t and not account for scr refresh
            religion_btn_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_3.started')
            # update status
            religion_btn_3.status = STARTED
            win.callOnFlip(religion_btn_3.buttonClock.reset)
            religion_btn_3.setAutoDraw(True)
        
        # if religion_btn_3 is active this frame...
        if religion_btn_3.status == STARTED:
            # update params
            pass
            # check whether religion_btn_3 has been pressed
            if religion_btn_3.isClicked:
                if not religion_btn_3.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_3.timesOn.append(religion_btn_3.buttonClock.getTime())
                    religion_btn_3.timesOff.append(religion_btn_3.buttonClock.getTime())
                elif len(religion_btn_3.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_3.timesOff[-1] = religion_btn_3.buttonClock.getTime()
                if not religion_btn_3.wasClicked:
                    # end routine when religion_btn_3 is clicked
                    continueRoutine = False
                if not religion_btn_3.wasClicked:
                    # run callback code when religion_btn_3 is clicked
                    thisExp.addData('religion_type', '3')
        # take note of whether religion_btn_3 was clicked, so that next frame we know if clicks are new
        religion_btn_3.wasClicked = religion_btn_3.isClicked and religion_btn_3.status == STARTED
        # *religion_btn_4* updates
        
        # if religion_btn_4 is starting this frame...
        if religion_btn_4.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_4.frameNStart = frameN  # exact frame index
            religion_btn_4.tStart = t  # local t and not account for scr refresh
            religion_btn_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_4.started')
            # update status
            religion_btn_4.status = STARTED
            win.callOnFlip(religion_btn_4.buttonClock.reset)
            religion_btn_4.setAutoDraw(True)
        
        # if religion_btn_4 is active this frame...
        if religion_btn_4.status == STARTED:
            # update params
            pass
            # check whether religion_btn_4 has been pressed
            if religion_btn_4.isClicked:
                if not religion_btn_4.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_4.timesOn.append(religion_btn_4.buttonClock.getTime())
                    religion_btn_4.timesOff.append(religion_btn_4.buttonClock.getTime())
                elif len(religion_btn_4.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_4.timesOff[-1] = religion_btn_4.buttonClock.getTime()
                if not religion_btn_4.wasClicked:
                    # end routine when religion_btn_4 is clicked
                    continueRoutine = False
                if not religion_btn_4.wasClicked:
                    # run callback code when religion_btn_4 is clicked
                    thisExp.addData('religion_type', '4')
        # take note of whether religion_btn_4 was clicked, so that next frame we know if clicks are new
        religion_btn_4.wasClicked = religion_btn_4.isClicked and religion_btn_4.status == STARTED
        # *religion_btn_5* updates
        
        # if religion_btn_5 is starting this frame...
        if religion_btn_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_5.frameNStart = frameN  # exact frame index
            religion_btn_5.tStart = t  # local t and not account for scr refresh
            religion_btn_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_5.started')
            # update status
            religion_btn_5.status = STARTED
            win.callOnFlip(religion_btn_5.buttonClock.reset)
            religion_btn_5.setAutoDraw(True)
        
        # if religion_btn_5 is active this frame...
        if religion_btn_5.status == STARTED:
            # update params
            pass
            # check whether religion_btn_5 has been pressed
            if religion_btn_5.isClicked:
                if not religion_btn_5.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_5.timesOn.append(religion_btn_5.buttonClock.getTime())
                    religion_btn_5.timesOff.append(religion_btn_5.buttonClock.getTime())
                elif len(religion_btn_5.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_5.timesOff[-1] = religion_btn_5.buttonClock.getTime()
                if not religion_btn_5.wasClicked:
                    # end routine when religion_btn_5 is clicked
                    continueRoutine = False
                if not religion_btn_5.wasClicked:
                    # run callback code when religion_btn_5 is clicked
                    thisExp.addData('religion_type', '5')
        # take note of whether religion_btn_5 was clicked, so that next frame we know if clicks are new
        religion_btn_5.wasClicked = religion_btn_5.isClicked and religion_btn_5.status == STARTED
        # *religion_btn_6* updates
        
        # if religion_btn_6 is starting this frame...
        if religion_btn_6.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_6.frameNStart = frameN  # exact frame index
            religion_btn_6.tStart = t  # local t and not account for scr refresh
            religion_btn_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_6.started')
            # update status
            religion_btn_6.status = STARTED
            win.callOnFlip(religion_btn_6.buttonClock.reset)
            religion_btn_6.setAutoDraw(True)
        
        # if religion_btn_6 is active this frame...
        if religion_btn_6.status == STARTED:
            # update params
            pass
            # check whether religion_btn_6 has been pressed
            if religion_btn_6.isClicked:
                if not religion_btn_6.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_6.timesOn.append(religion_btn_6.buttonClock.getTime())
                    religion_btn_6.timesOff.append(religion_btn_6.buttonClock.getTime())
                elif len(religion_btn_6.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_6.timesOff[-1] = religion_btn_6.buttonClock.getTime()
                if not religion_btn_6.wasClicked:
                    # end routine when religion_btn_6 is clicked
                    continueRoutine = False
                if not religion_btn_6.wasClicked:
                    # run callback code when religion_btn_6 is clicked
                    thisExp.addData('religion_type', '6')
        # take note of whether religion_btn_6 was clicked, so that next frame we know if clicks are new
        religion_btn_6.wasClicked = religion_btn_6.isClicked and religion_btn_6.status == STARTED
        # *religion_btn_7* updates
        
        # if religion_btn_7 is starting this frame...
        if religion_btn_7.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            religion_btn_7.frameNStart = frameN  # exact frame index
            religion_btn_7.tStart = t  # local t and not account for scr refresh
            religion_btn_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(religion_btn_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'religion_btn_7.started')
            # update status
            religion_btn_7.status = STARTED
            win.callOnFlip(religion_btn_7.buttonClock.reset)
            religion_btn_7.setAutoDraw(True)
        
        # if religion_btn_7 is active this frame...
        if religion_btn_7.status == STARTED:
            # update params
            pass
            # check whether religion_btn_7 has been pressed
            if religion_btn_7.isClicked:
                if not religion_btn_7.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    religion_btn_7.timesOn.append(religion_btn_7.buttonClock.getTime())
                    religion_btn_7.timesOff.append(religion_btn_7.buttonClock.getTime())
                elif len(religion_btn_7.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    religion_btn_7.timesOff[-1] = religion_btn_7.buttonClock.getTime()
                if not religion_btn_7.wasClicked:
                    # end routine when religion_btn_7 is clicked
                    continueRoutine = False
                if not religion_btn_7.wasClicked:
                    # run callback code when religion_btn_7 is clicked
                    thisExp.addData('religion_type', '7')
        # take note of whether religion_btn_7 was clicked, so that next frame we know if clicks are new
        religion_btn_7.wasClicked = religion_btn_7.isClicked and religion_btn_7.status == STARTED
        
        # *Q6* updates
        
        # if Q6 is starting this frame...
        if Q6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q6.frameNStart = frameN  # exact frame index
            Q6.tStart = t  # local t and not account for scr refresh
            Q6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q6.started')
            # update status
            Q6.status = STARTED
            Q6.setAutoDraw(True)
        
        # if Q6 is active this frame...
        if Q6.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=religion,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            religion.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in religion.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "religion" ---
    for thisComponent in religion.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for religion
    religion.tStop = globalClock.getTime(format='float')
    religion.tStopRefresh = tThisFlipGlobal
    thisExp.addData('religion.stopped', religion.tStop)
    thisExp.addData('religion_btn_1.numClicks', religion_btn_1.numClicks)
    if religion_btn_1.numClicks:
       thisExp.addData('religion_btn_1.timesOn', religion_btn_1.timesOn)
       thisExp.addData('religion_btn_1.timesOff', religion_btn_1.timesOff)
    else:
       thisExp.addData('religion_btn_1.timesOn', "")
       thisExp.addData('religion_btn_1.timesOff', "")
    thisExp.addData('religion_btn_2.numClicks', religion_btn_2.numClicks)
    if religion_btn_2.numClicks:
       thisExp.addData('religion_btn_2.timesOn', religion_btn_2.timesOn)
       thisExp.addData('religion_btn_2.timesOff', religion_btn_2.timesOff)
    else:
       thisExp.addData('religion_btn_2.timesOn', "")
       thisExp.addData('religion_btn_2.timesOff', "")
    thisExp.addData('religion_btn_3.numClicks', religion_btn_3.numClicks)
    if religion_btn_3.numClicks:
       thisExp.addData('religion_btn_3.timesOn', religion_btn_3.timesOn)
       thisExp.addData('religion_btn_3.timesOff', religion_btn_3.timesOff)
    else:
       thisExp.addData('religion_btn_3.timesOn', "")
       thisExp.addData('religion_btn_3.timesOff', "")
    thisExp.addData('religion_btn_4.numClicks', religion_btn_4.numClicks)
    if religion_btn_4.numClicks:
       thisExp.addData('religion_btn_4.timesOn', religion_btn_4.timesOn)
       thisExp.addData('religion_btn_4.timesOff', religion_btn_4.timesOff)
    else:
       thisExp.addData('religion_btn_4.timesOn', "")
       thisExp.addData('religion_btn_4.timesOff', "")
    thisExp.addData('religion_btn_5.numClicks', religion_btn_5.numClicks)
    if religion_btn_5.numClicks:
       thisExp.addData('religion_btn_5.timesOn', religion_btn_5.timesOn)
       thisExp.addData('religion_btn_5.timesOff', religion_btn_5.timesOff)
    else:
       thisExp.addData('religion_btn_5.timesOn', "")
       thisExp.addData('religion_btn_5.timesOff', "")
    thisExp.addData('religion_btn_6.numClicks', religion_btn_6.numClicks)
    if religion_btn_6.numClicks:
       thisExp.addData('religion_btn_6.timesOn', religion_btn_6.timesOn)
       thisExp.addData('religion_btn_6.timesOff', religion_btn_6.timesOff)
    else:
       thisExp.addData('religion_btn_6.timesOn', "")
       thisExp.addData('religion_btn_6.timesOff', "")
    thisExp.addData('religion_btn_7.numClicks', religion_btn_7.numClicks)
    if religion_btn_7.numClicks:
       thisExp.addData('religion_btn_7.timesOn', religion_btn_7.timesOn)
       thisExp.addData('religion_btn_7.timesOff', religion_btn_7.timesOff)
    else:
       thisExp.addData('religion_btn_7.timesOn', "")
       thisExp.addData('religion_btn_7.timesOff', "")
    thisExp.nextEntry()
    # the Routine "religion" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ethnicity" ---
    # create an object to store info about Routine ethnicity
    ethnicity = data.Routine(
        name='ethnicity',
        components=[Q_ethnicity_text, ethnicity_btn_1, ethnicity_btn_2, ethnicity_btn_3, ethnicity_btn_4, Q7],
    )
    ethnicity.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset ethnicity_btn_1 to account for continued clicks & clear times on/off
    ethnicity_btn_1.reset()
    # reset ethnicity_btn_2 to account for continued clicks & clear times on/off
    ethnicity_btn_2.reset()
    # reset ethnicity_btn_3 to account for continued clicks & clear times on/off
    ethnicity_btn_3.reset()
    # reset ethnicity_btn_4 to account for continued clicks & clear times on/off
    ethnicity_btn_4.reset()
    # store start times for ethnicity
    ethnicity.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ethnicity.tStart = globalClock.getTime(format='float')
    ethnicity.status = STARTED
    thisExp.addData('ethnicity.started', ethnicity.tStart)
    ethnicity.maxDuration = None
    # keep track of which components have finished
    ethnicityComponents = ethnicity.components
    for thisComponent in ethnicity.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ethnicity" ---
    ethnicity.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_ethnicity_text* updates
        
        # if Q_ethnicity_text is starting this frame...
        if Q_ethnicity_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_ethnicity_text.frameNStart = frameN  # exact frame index
            Q_ethnicity_text.tStart = t  # local t and not account for scr refresh
            Q_ethnicity_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_ethnicity_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_ethnicity_text.started')
            # update status
            Q_ethnicity_text.status = STARTED
            Q_ethnicity_text.setAutoDraw(True)
        
        # if Q_ethnicity_text is active this frame...
        if Q_ethnicity_text.status == STARTED:
            # update params
            pass
        # *ethnicity_btn_1* updates
        
        # if ethnicity_btn_1 is starting this frame...
        if ethnicity_btn_1.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ethnicity_btn_1.frameNStart = frameN  # exact frame index
            ethnicity_btn_1.tStart = t  # local t and not account for scr refresh
            ethnicity_btn_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ethnicity_btn_1, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ethnicity_btn_1.started')
            # update status
            ethnicity_btn_1.status = STARTED
            win.callOnFlip(ethnicity_btn_1.buttonClock.reset)
            ethnicity_btn_1.setAutoDraw(True)
        
        # if ethnicity_btn_1 is active this frame...
        if ethnicity_btn_1.status == STARTED:
            # update params
            pass
            # check whether ethnicity_btn_1 has been pressed
            if ethnicity_btn_1.isClicked:
                if not ethnicity_btn_1.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ethnicity_btn_1.timesOn.append(ethnicity_btn_1.buttonClock.getTime())
                    ethnicity_btn_1.timesOff.append(ethnicity_btn_1.buttonClock.getTime())
                elif len(ethnicity_btn_1.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ethnicity_btn_1.timesOff[-1] = ethnicity_btn_1.buttonClock.getTime()
                if not ethnicity_btn_1.wasClicked:
                    # end routine when ethnicity_btn_1 is clicked
                    continueRoutine = False
                if not ethnicity_btn_1.wasClicked:
                    # run callback code when ethnicity_btn_1 is clicked
                    thisExp.addData('religion_type', '1')
        # take note of whether ethnicity_btn_1 was clicked, so that next frame we know if clicks are new
        ethnicity_btn_1.wasClicked = ethnicity_btn_1.isClicked and ethnicity_btn_1.status == STARTED
        # *ethnicity_btn_2* updates
        
        # if ethnicity_btn_2 is starting this frame...
        if ethnicity_btn_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ethnicity_btn_2.frameNStart = frameN  # exact frame index
            ethnicity_btn_2.tStart = t  # local t and not account for scr refresh
            ethnicity_btn_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ethnicity_btn_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ethnicity_btn_2.started')
            # update status
            ethnicity_btn_2.status = STARTED
            win.callOnFlip(ethnicity_btn_2.buttonClock.reset)
            ethnicity_btn_2.setAutoDraw(True)
        
        # if ethnicity_btn_2 is active this frame...
        if ethnicity_btn_2.status == STARTED:
            # update params
            pass
            # check whether ethnicity_btn_2 has been pressed
            if ethnicity_btn_2.isClicked:
                if not ethnicity_btn_2.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ethnicity_btn_2.timesOn.append(ethnicity_btn_2.buttonClock.getTime())
                    ethnicity_btn_2.timesOff.append(ethnicity_btn_2.buttonClock.getTime())
                elif len(ethnicity_btn_2.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ethnicity_btn_2.timesOff[-1] = ethnicity_btn_2.buttonClock.getTime()
                if not ethnicity_btn_2.wasClicked:
                    # end routine when ethnicity_btn_2 is clicked
                    continueRoutine = False
                if not ethnicity_btn_2.wasClicked:
                    # run callback code when ethnicity_btn_2 is clicked
                    thisExp.addData('religion_type', '2')
        # take note of whether ethnicity_btn_2 was clicked, so that next frame we know if clicks are new
        ethnicity_btn_2.wasClicked = ethnicity_btn_2.isClicked and ethnicity_btn_2.status == STARTED
        # *ethnicity_btn_3* updates
        
        # if ethnicity_btn_3 is starting this frame...
        if ethnicity_btn_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ethnicity_btn_3.frameNStart = frameN  # exact frame index
            ethnicity_btn_3.tStart = t  # local t and not account for scr refresh
            ethnicity_btn_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ethnicity_btn_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ethnicity_btn_3.started')
            # update status
            ethnicity_btn_3.status = STARTED
            win.callOnFlip(ethnicity_btn_3.buttonClock.reset)
            ethnicity_btn_3.setAutoDraw(True)
        
        # if ethnicity_btn_3 is active this frame...
        if ethnicity_btn_3.status == STARTED:
            # update params
            pass
            # check whether ethnicity_btn_3 has been pressed
            if ethnicity_btn_3.isClicked:
                if not ethnicity_btn_3.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ethnicity_btn_3.timesOn.append(ethnicity_btn_3.buttonClock.getTime())
                    ethnicity_btn_3.timesOff.append(ethnicity_btn_3.buttonClock.getTime())
                elif len(ethnicity_btn_3.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ethnicity_btn_3.timesOff[-1] = ethnicity_btn_3.buttonClock.getTime()
                if not ethnicity_btn_3.wasClicked:
                    # end routine when ethnicity_btn_3 is clicked
                    continueRoutine = False
                if not ethnicity_btn_3.wasClicked:
                    # run callback code when ethnicity_btn_3 is clicked
                    thisExp.addData('religion_type', '3')
        # take note of whether ethnicity_btn_3 was clicked, so that next frame we know if clicks are new
        ethnicity_btn_3.wasClicked = ethnicity_btn_3.isClicked and ethnicity_btn_3.status == STARTED
        # *ethnicity_btn_4* updates
        
        # if ethnicity_btn_4 is starting this frame...
        if ethnicity_btn_4.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ethnicity_btn_4.frameNStart = frameN  # exact frame index
            ethnicity_btn_4.tStart = t  # local t and not account for scr refresh
            ethnicity_btn_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ethnicity_btn_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ethnicity_btn_4.started')
            # update status
            ethnicity_btn_4.status = STARTED
            win.callOnFlip(ethnicity_btn_4.buttonClock.reset)
            ethnicity_btn_4.setAutoDraw(True)
        
        # if ethnicity_btn_4 is active this frame...
        if ethnicity_btn_4.status == STARTED:
            # update params
            pass
            # check whether ethnicity_btn_4 has been pressed
            if ethnicity_btn_4.isClicked:
                if not ethnicity_btn_4.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ethnicity_btn_4.timesOn.append(ethnicity_btn_4.buttonClock.getTime())
                    ethnicity_btn_4.timesOff.append(ethnicity_btn_4.buttonClock.getTime())
                elif len(ethnicity_btn_4.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ethnicity_btn_4.timesOff[-1] = ethnicity_btn_4.buttonClock.getTime()
                if not ethnicity_btn_4.wasClicked:
                    # end routine when ethnicity_btn_4 is clicked
                    continueRoutine = False
                if not ethnicity_btn_4.wasClicked:
                    # run callback code when ethnicity_btn_4 is clicked
                    thisExp.addData('religion_type', '4')
        # take note of whether ethnicity_btn_4 was clicked, so that next frame we know if clicks are new
        ethnicity_btn_4.wasClicked = ethnicity_btn_4.isClicked and ethnicity_btn_4.status == STARTED
        
        # *Q7* updates
        
        # if Q7 is starting this frame...
        if Q7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q7.frameNStart = frameN  # exact frame index
            Q7.tStart = t  # local t and not account for scr refresh
            Q7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q7.started')
            # update status
            Q7.status = STARTED
            Q7.setAutoDraw(True)
        
        # if Q7 is active this frame...
        if Q7.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=ethnicity,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ethnicity.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ethnicity.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ethnicity" ---
    for thisComponent in ethnicity.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ethnicity
    ethnicity.tStop = globalClock.getTime(format='float')
    ethnicity.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ethnicity.stopped', ethnicity.tStop)
    thisExp.addData('ethnicity_btn_1.numClicks', ethnicity_btn_1.numClicks)
    if ethnicity_btn_1.numClicks:
       thisExp.addData('ethnicity_btn_1.timesOn', ethnicity_btn_1.timesOn)
       thisExp.addData('ethnicity_btn_1.timesOff', ethnicity_btn_1.timesOff)
    else:
       thisExp.addData('ethnicity_btn_1.timesOn', "")
       thisExp.addData('ethnicity_btn_1.timesOff', "")
    thisExp.addData('ethnicity_btn_2.numClicks', ethnicity_btn_2.numClicks)
    if ethnicity_btn_2.numClicks:
       thisExp.addData('ethnicity_btn_2.timesOn', ethnicity_btn_2.timesOn)
       thisExp.addData('ethnicity_btn_2.timesOff', ethnicity_btn_2.timesOff)
    else:
       thisExp.addData('ethnicity_btn_2.timesOn', "")
       thisExp.addData('ethnicity_btn_2.timesOff', "")
    thisExp.addData('ethnicity_btn_3.numClicks', ethnicity_btn_3.numClicks)
    if ethnicity_btn_3.numClicks:
       thisExp.addData('ethnicity_btn_3.timesOn', ethnicity_btn_3.timesOn)
       thisExp.addData('ethnicity_btn_3.timesOff', ethnicity_btn_3.timesOff)
    else:
       thisExp.addData('ethnicity_btn_3.timesOn', "")
       thisExp.addData('ethnicity_btn_3.timesOff', "")
    thisExp.addData('ethnicity_btn_4.numClicks', ethnicity_btn_4.numClicks)
    if ethnicity_btn_4.numClicks:
       thisExp.addData('ethnicity_btn_4.timesOn', ethnicity_btn_4.timesOn)
       thisExp.addData('ethnicity_btn_4.timesOff', ethnicity_btn_4.timesOff)
    else:
       thisExp.addData('ethnicity_btn_4.timesOn', "")
       thisExp.addData('ethnicity_btn_4.timesOff', "")
    thisExp.nextEntry()
    # the Routine "ethnicity" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "HouseholdStructure" ---
    # create an object to store info about Routine HouseholdStructure
    HouseholdStructure = data.Routine(
        name='HouseholdStructure',
        components=[householdstructure_question_text, textbox_household, textbox_ABCDE, textbox_FGHI, Q8, hint_household],
    )
    HouseholdStructure.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_household.reset()
    textbox_ABCDE.reset()
    textbox_FGHI.reset()
    # store start times for HouseholdStructure
    HouseholdStructure.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    HouseholdStructure.tStart = globalClock.getTime(format='float')
    HouseholdStructure.status = STARTED
    thisExp.addData('HouseholdStructure.started', HouseholdStructure.tStart)
    HouseholdStructure.maxDuration = None
    # keep track of which components have finished
    HouseholdStructureComponents = HouseholdStructure.components
    for thisComponent in HouseholdStructure.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "HouseholdStructure" ---
    HouseholdStructure.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *householdstructure_question_text* updates
        
        # if householdstructure_question_text is starting this frame...
        if householdstructure_question_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            householdstructure_question_text.frameNStart = frameN  # exact frame index
            householdstructure_question_text.tStart = t  # local t and not account for scr refresh
            householdstructure_question_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(householdstructure_question_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'householdstructure_question_text.started')
            # update status
            householdstructure_question_text.status = STARTED
            householdstructure_question_text.setAutoDraw(True)
        
        # if householdstructure_question_text is active this frame...
        if householdstructure_question_text.status == STARTED:
            # update params
            pass
        
        # *textbox_household* updates
        
        # if textbox_household is starting this frame...
        if textbox_household.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_household.frameNStart = frameN  # exact frame index
            textbox_household.tStart = t  # local t and not account for scr refresh
            textbox_household.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_household, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_household.started')
            # update status
            textbox_household.status = STARTED
            textbox_household.setAutoDraw(True)
        
        # if textbox_household is active this frame...
        if textbox_household.status == STARTED:
            # update params
            pass
        
        # *textbox_ABCDE* updates
        
        # if textbox_ABCDE is starting this frame...
        if textbox_ABCDE.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_ABCDE.frameNStart = frameN  # exact frame index
            textbox_ABCDE.tStart = t  # local t and not account for scr refresh
            textbox_ABCDE.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_ABCDE, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_ABCDE.started')
            # update status
            textbox_ABCDE.status = STARTED
            textbox_ABCDE.setAutoDraw(True)
        
        # if textbox_ABCDE is active this frame...
        if textbox_ABCDE.status == STARTED:
            # update params
            pass
        
        # *textbox_FGHI* updates
        
        # if textbox_FGHI is starting this frame...
        if textbox_FGHI.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_FGHI.frameNStart = frameN  # exact frame index
            textbox_FGHI.tStart = t  # local t and not account for scr refresh
            textbox_FGHI.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_FGHI, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_FGHI.started')
            # update status
            textbox_FGHI.status = STARTED
            textbox_FGHI.setAutoDraw(True)
        
        # if textbox_FGHI is active this frame...
        if textbox_FGHI.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_6
        if not hasattr(thisExp, 'allow_advance_household'):
            thisExp.allow_advance_household = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_household.text.strip()
            if user_input != '':
                thisExp.allow_advance_household = True
        
        if thisExp.allow_advance_household:
            continueRoutine = False
        
        
        # *Q8* updates
        
        # if Q8 is starting this frame...
        if Q8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q8.frameNStart = frameN  # exact frame index
            Q8.tStart = t  # local t and not account for scr refresh
            Q8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q8.started')
            # update status
            Q8.status = STARTED
            Q8.setAutoDraw(True)
        
        # if Q8 is active this frame...
        if Q8.status == STARTED:
            # update params
            pass
        
        # *hint_household* updates
        
        # if hint_household is starting this frame...
        if hint_household.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            hint_household.frameNStart = frameN  # exact frame index
            hint_household.tStart = t  # local t and not account for scr refresh
            hint_household.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(hint_household, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'hint_household.started')
            # update status
            hint_household.status = STARTED
            hint_household.setAutoDraw(True)
        
        # if hint_household is active this frame...
        if hint_household.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=HouseholdStructure,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            HouseholdStructure.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in HouseholdStructure.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "HouseholdStructure" ---
    for thisComponent in HouseholdStructure.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for HouseholdStructure
    HouseholdStructure.tStop = globalClock.getTime(format='float')
    HouseholdStructure.tStopRefresh = tThisFlipGlobal
    thisExp.addData('HouseholdStructure.stopped', HouseholdStructure.tStop)
    thisExp.addData('textbox_household.text',textbox_household.text)
    # Run 'End Routine' code from code_6
    thisExp.addData('age', textbox_household.text)
    
    thisExp.nextEntry()
    # the Routine "HouseholdStructure" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "occupation_type" ---
    # create an object to store info about Routine occupation_type
    occupation_type = data.Routine(
        name='occupation_type',
        components=[Q_occupation, occupation_Education, occupation_Healthcare, occupation_Government, occupation_Business, occupation_Selfemployed, occupation_Homemaker, occupation_Student, occupation_Unemployed, occupation_Retired, occupation_Other, occupation_Prefernottosay, Q9],
    )
    occupation_type.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset occupation_Education to account for continued clicks & clear times on/off
    occupation_Education.reset()
    # reset occupation_Healthcare to account for continued clicks & clear times on/off
    occupation_Healthcare.reset()
    # reset occupation_Government to account for continued clicks & clear times on/off
    occupation_Government.reset()
    # reset occupation_Business to account for continued clicks & clear times on/off
    occupation_Business.reset()
    # reset occupation_Selfemployed to account for continued clicks & clear times on/off
    occupation_Selfemployed.reset()
    # reset occupation_Homemaker to account for continued clicks & clear times on/off
    occupation_Homemaker.reset()
    # reset occupation_Student to account for continued clicks & clear times on/off
    occupation_Student.reset()
    # reset occupation_Unemployed to account for continued clicks & clear times on/off
    occupation_Unemployed.reset()
    # reset occupation_Retired to account for continued clicks & clear times on/off
    occupation_Retired.reset()
    # reset occupation_Other to account for continued clicks & clear times on/off
    occupation_Other.reset()
    # reset occupation_Prefernottosay to account for continued clicks & clear times on/off
    occupation_Prefernottosay.reset()
    # store start times for occupation_type
    occupation_type.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    occupation_type.tStart = globalClock.getTime(format='float')
    occupation_type.status = STARTED
    thisExp.addData('occupation_type.started', occupation_type.tStart)
    occupation_type.maxDuration = None
    # keep track of which components have finished
    occupation_typeComponents = occupation_type.components
    for thisComponent in occupation_type.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "occupation_type" ---
    occupation_type.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_occupation* updates
        
        # if Q_occupation is starting this frame...
        if Q_occupation.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_occupation.frameNStart = frameN  # exact frame index
            Q_occupation.tStart = t  # local t and not account for scr refresh
            Q_occupation.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_occupation, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_occupation.started')
            # update status
            Q_occupation.status = STARTED
            Q_occupation.setAutoDraw(True)
        
        # if Q_occupation is active this frame...
        if Q_occupation.status == STARTED:
            # update params
            pass
        # *occupation_Education* updates
        
        # if occupation_Education is starting this frame...
        if occupation_Education.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Education.frameNStart = frameN  # exact frame index
            occupation_Education.tStart = t  # local t and not account for scr refresh
            occupation_Education.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Education, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Education.started')
            # update status
            occupation_Education.status = STARTED
            win.callOnFlip(occupation_Education.buttonClock.reset)
            occupation_Education.setAutoDraw(True)
        
        # if occupation_Education is active this frame...
        if occupation_Education.status == STARTED:
            # update params
            pass
            # check whether occupation_Education has been pressed
            if occupation_Education.isClicked:
                if not occupation_Education.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Education.timesOn.append(occupation_Education.buttonClock.getTime())
                    occupation_Education.timesOff.append(occupation_Education.buttonClock.getTime())
                elif len(occupation_Education.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Education.timesOff[-1] = occupation_Education.buttonClock.getTime()
                if not occupation_Education.wasClicked:
                    # end routine when occupation_Education is clicked
                    continueRoutine = False
                if not occupation_Education.wasClicked:
                    # run callback code when occupation_Education is clicked
                    thisExp.addData('occupation_level', '1')
        # take note of whether occupation_Education was clicked, so that next frame we know if clicks are new
        occupation_Education.wasClicked = occupation_Education.isClicked and occupation_Education.status == STARTED
        # *occupation_Healthcare* updates
        
        # if occupation_Healthcare is starting this frame...
        if occupation_Healthcare.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Healthcare.frameNStart = frameN  # exact frame index
            occupation_Healthcare.tStart = t  # local t and not account for scr refresh
            occupation_Healthcare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Healthcare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Healthcare.started')
            # update status
            occupation_Healthcare.status = STARTED
            win.callOnFlip(occupation_Healthcare.buttonClock.reset)
            occupation_Healthcare.setAutoDraw(True)
        
        # if occupation_Healthcare is active this frame...
        if occupation_Healthcare.status == STARTED:
            # update params
            pass
            # check whether occupation_Healthcare has been pressed
            if occupation_Healthcare.isClicked:
                if not occupation_Healthcare.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Healthcare.timesOn.append(occupation_Healthcare.buttonClock.getTime())
                    occupation_Healthcare.timesOff.append(occupation_Healthcare.buttonClock.getTime())
                elif len(occupation_Healthcare.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Healthcare.timesOff[-1] = occupation_Healthcare.buttonClock.getTime()
                if not occupation_Healthcare.wasClicked:
                    # end routine when occupation_Healthcare is clicked
                    continueRoutine = False
                if not occupation_Healthcare.wasClicked:
                    # run callback code when occupation_Healthcare is clicked
                    thisExp.addData('occupation_level', '2')
        # take note of whether occupation_Healthcare was clicked, so that next frame we know if clicks are new
        occupation_Healthcare.wasClicked = occupation_Healthcare.isClicked and occupation_Healthcare.status == STARTED
        # *occupation_Government* updates
        
        # if occupation_Government is starting this frame...
        if occupation_Government.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Government.frameNStart = frameN  # exact frame index
            occupation_Government.tStart = t  # local t and not account for scr refresh
            occupation_Government.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Government, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Government.started')
            # update status
            occupation_Government.status = STARTED
            win.callOnFlip(occupation_Government.buttonClock.reset)
            occupation_Government.setAutoDraw(True)
        
        # if occupation_Government is active this frame...
        if occupation_Government.status == STARTED:
            # update params
            pass
            # check whether occupation_Government has been pressed
            if occupation_Government.isClicked:
                if not occupation_Government.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Government.timesOn.append(occupation_Government.buttonClock.getTime())
                    occupation_Government.timesOff.append(occupation_Government.buttonClock.getTime())
                elif len(occupation_Government.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Government.timesOff[-1] = occupation_Government.buttonClock.getTime()
                if not occupation_Government.wasClicked:
                    # end routine when occupation_Government is clicked
                    continueRoutine = False
                if not occupation_Government.wasClicked:
                    # run callback code when occupation_Government is clicked
                    thisExp.addData('occupation_level', '3')
                    
        # take note of whether occupation_Government was clicked, so that next frame we know if clicks are new
        occupation_Government.wasClicked = occupation_Government.isClicked and occupation_Government.status == STARTED
        # *occupation_Business* updates
        
        # if occupation_Business is starting this frame...
        if occupation_Business.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Business.frameNStart = frameN  # exact frame index
            occupation_Business.tStart = t  # local t and not account for scr refresh
            occupation_Business.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Business, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Business.started')
            # update status
            occupation_Business.status = STARTED
            win.callOnFlip(occupation_Business.buttonClock.reset)
            occupation_Business.setAutoDraw(True)
        
        # if occupation_Business is active this frame...
        if occupation_Business.status == STARTED:
            # update params
            pass
            # check whether occupation_Business has been pressed
            if occupation_Business.isClicked:
                if not occupation_Business.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Business.timesOn.append(occupation_Business.buttonClock.getTime())
                    occupation_Business.timesOff.append(occupation_Business.buttonClock.getTime())
                elif len(occupation_Business.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Business.timesOff[-1] = occupation_Business.buttonClock.getTime()
                if not occupation_Business.wasClicked:
                    # end routine when occupation_Business is clicked
                    continueRoutine = False
                if not occupation_Business.wasClicked:
                    # run callback code when occupation_Business is clicked
                    thisExp.addData('occupation_level', '4')
        # take note of whether occupation_Business was clicked, so that next frame we know if clicks are new
        occupation_Business.wasClicked = occupation_Business.isClicked and occupation_Business.status == STARTED
        # *occupation_Selfemployed* updates
        
        # if occupation_Selfemployed is starting this frame...
        if occupation_Selfemployed.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Selfemployed.frameNStart = frameN  # exact frame index
            occupation_Selfemployed.tStart = t  # local t and not account for scr refresh
            occupation_Selfemployed.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Selfemployed, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Selfemployed.started')
            # update status
            occupation_Selfemployed.status = STARTED
            win.callOnFlip(occupation_Selfemployed.buttonClock.reset)
            occupation_Selfemployed.setAutoDraw(True)
        
        # if occupation_Selfemployed is active this frame...
        if occupation_Selfemployed.status == STARTED:
            # update params
            pass
            # check whether occupation_Selfemployed has been pressed
            if occupation_Selfemployed.isClicked:
                if not occupation_Selfemployed.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Selfemployed.timesOn.append(occupation_Selfemployed.buttonClock.getTime())
                    occupation_Selfemployed.timesOff.append(occupation_Selfemployed.buttonClock.getTime())
                elif len(occupation_Selfemployed.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Selfemployed.timesOff[-1] = occupation_Selfemployed.buttonClock.getTime()
                if not occupation_Selfemployed.wasClicked:
                    # end routine when occupation_Selfemployed is clicked
                    continueRoutine = False
                if not occupation_Selfemployed.wasClicked:
                    # run callback code when occupation_Selfemployed is clicked
                    thisExp.addData('occupation_level', '5')
        # take note of whether occupation_Selfemployed was clicked, so that next frame we know if clicks are new
        occupation_Selfemployed.wasClicked = occupation_Selfemployed.isClicked and occupation_Selfemployed.status == STARTED
        # *occupation_Homemaker* updates
        
        # if occupation_Homemaker is starting this frame...
        if occupation_Homemaker.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Homemaker.frameNStart = frameN  # exact frame index
            occupation_Homemaker.tStart = t  # local t and not account for scr refresh
            occupation_Homemaker.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Homemaker, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Homemaker.started')
            # update status
            occupation_Homemaker.status = STARTED
            win.callOnFlip(occupation_Homemaker.buttonClock.reset)
            occupation_Homemaker.setAutoDraw(True)
        
        # if occupation_Homemaker is active this frame...
        if occupation_Homemaker.status == STARTED:
            # update params
            pass
            # check whether occupation_Homemaker has been pressed
            if occupation_Homemaker.isClicked:
                if not occupation_Homemaker.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Homemaker.timesOn.append(occupation_Homemaker.buttonClock.getTime())
                    occupation_Homemaker.timesOff.append(occupation_Homemaker.buttonClock.getTime())
                elif len(occupation_Homemaker.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Homemaker.timesOff[-1] = occupation_Homemaker.buttonClock.getTime()
                if not occupation_Homemaker.wasClicked:
                    # end routine when occupation_Homemaker is clicked
                    continueRoutine = False
                if not occupation_Homemaker.wasClicked:
                    # run callback code when occupation_Homemaker is clicked
                    thisExp.addData('occupation_level', '6')
        # take note of whether occupation_Homemaker was clicked, so that next frame we know if clicks are new
        occupation_Homemaker.wasClicked = occupation_Homemaker.isClicked and occupation_Homemaker.status == STARTED
        # *occupation_Student* updates
        
        # if occupation_Student is starting this frame...
        if occupation_Student.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Student.frameNStart = frameN  # exact frame index
            occupation_Student.tStart = t  # local t and not account for scr refresh
            occupation_Student.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Student, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Student.started')
            # update status
            occupation_Student.status = STARTED
            win.callOnFlip(occupation_Student.buttonClock.reset)
            occupation_Student.setAutoDraw(True)
        
        # if occupation_Student is active this frame...
        if occupation_Student.status == STARTED:
            # update params
            pass
            # check whether occupation_Student has been pressed
            if occupation_Student.isClicked:
                if not occupation_Student.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Student.timesOn.append(occupation_Student.buttonClock.getTime())
                    occupation_Student.timesOff.append(occupation_Student.buttonClock.getTime())
                elif len(occupation_Student.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Student.timesOff[-1] = occupation_Student.buttonClock.getTime()
                if not occupation_Student.wasClicked:
                    # end routine when occupation_Student is clicked
                    continueRoutine = False
                if not occupation_Student.wasClicked:
                    # run callback code when occupation_Student is clicked
                    thisExp.addData('occupation_level', '7')
        # take note of whether occupation_Student was clicked, so that next frame we know if clicks are new
        occupation_Student.wasClicked = occupation_Student.isClicked and occupation_Student.status == STARTED
        # *occupation_Unemployed* updates
        
        # if occupation_Unemployed is starting this frame...
        if occupation_Unemployed.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Unemployed.frameNStart = frameN  # exact frame index
            occupation_Unemployed.tStart = t  # local t and not account for scr refresh
            occupation_Unemployed.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Unemployed, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Unemployed.started')
            # update status
            occupation_Unemployed.status = STARTED
            win.callOnFlip(occupation_Unemployed.buttonClock.reset)
            occupation_Unemployed.setAutoDraw(True)
        
        # if occupation_Unemployed is active this frame...
        if occupation_Unemployed.status == STARTED:
            # update params
            pass
            # check whether occupation_Unemployed has been pressed
            if occupation_Unemployed.isClicked:
                if not occupation_Unemployed.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Unemployed.timesOn.append(occupation_Unemployed.buttonClock.getTime())
                    occupation_Unemployed.timesOff.append(occupation_Unemployed.buttonClock.getTime())
                elif len(occupation_Unemployed.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Unemployed.timesOff[-1] = occupation_Unemployed.buttonClock.getTime()
                if not occupation_Unemployed.wasClicked:
                    # end routine when occupation_Unemployed is clicked
                    continueRoutine = False
                if not occupation_Unemployed.wasClicked:
                    # run callback code when occupation_Unemployed is clicked
                    thisExp.addData('occupation_level', '8')
        # take note of whether occupation_Unemployed was clicked, so that next frame we know if clicks are new
        occupation_Unemployed.wasClicked = occupation_Unemployed.isClicked and occupation_Unemployed.status == STARTED
        # *occupation_Retired* updates
        
        # if occupation_Retired is starting this frame...
        if occupation_Retired.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Retired.frameNStart = frameN  # exact frame index
            occupation_Retired.tStart = t  # local t and not account for scr refresh
            occupation_Retired.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Retired, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Retired.started')
            # update status
            occupation_Retired.status = STARTED
            win.callOnFlip(occupation_Retired.buttonClock.reset)
            occupation_Retired.setAutoDraw(True)
        
        # if occupation_Retired is active this frame...
        if occupation_Retired.status == STARTED:
            # update params
            pass
            # check whether occupation_Retired has been pressed
            if occupation_Retired.isClicked:
                if not occupation_Retired.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Retired.timesOn.append(occupation_Retired.buttonClock.getTime())
                    occupation_Retired.timesOff.append(occupation_Retired.buttonClock.getTime())
                elif len(occupation_Retired.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Retired.timesOff[-1] = occupation_Retired.buttonClock.getTime()
                if not occupation_Retired.wasClicked:
                    # end routine when occupation_Retired is clicked
                    continueRoutine = False
                if not occupation_Retired.wasClicked:
                    # run callback code when occupation_Retired is clicked
                    thisExp.addData('occupation_level', '9')
        # take note of whether occupation_Retired was clicked, so that next frame we know if clicks are new
        occupation_Retired.wasClicked = occupation_Retired.isClicked and occupation_Retired.status == STARTED
        # *occupation_Other* updates
        
        # if occupation_Other is starting this frame...
        if occupation_Other.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Other.frameNStart = frameN  # exact frame index
            occupation_Other.tStart = t  # local t and not account for scr refresh
            occupation_Other.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Other, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Other.started')
            # update status
            occupation_Other.status = STARTED
            win.callOnFlip(occupation_Other.buttonClock.reset)
            occupation_Other.setAutoDraw(True)
        
        # if occupation_Other is active this frame...
        if occupation_Other.status == STARTED:
            # update params
            pass
            # check whether occupation_Other has been pressed
            if occupation_Other.isClicked:
                if not occupation_Other.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Other.timesOn.append(occupation_Other.buttonClock.getTime())
                    occupation_Other.timesOff.append(occupation_Other.buttonClock.getTime())
                elif len(occupation_Other.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Other.timesOff[-1] = occupation_Other.buttonClock.getTime()
                if not occupation_Other.wasClicked:
                    # end routine when occupation_Other is clicked
                    continueRoutine = False
                if not occupation_Other.wasClicked:
                    # run callback code when occupation_Other is clicked
                    thisExp.addData('occupation_level', '10')
        # take note of whether occupation_Other was clicked, so that next frame we know if clicks are new
        occupation_Other.wasClicked = occupation_Other.isClicked and occupation_Other.status == STARTED
        # *occupation_Prefernottosay* updates
        
        # if occupation_Prefernottosay is starting this frame...
        if occupation_Prefernottosay.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            occupation_Prefernottosay.frameNStart = frameN  # exact frame index
            occupation_Prefernottosay.tStart = t  # local t and not account for scr refresh
            occupation_Prefernottosay.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(occupation_Prefernottosay, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'occupation_Prefernottosay.started')
            # update status
            occupation_Prefernottosay.status = STARTED
            win.callOnFlip(occupation_Prefernottosay.buttonClock.reset)
            occupation_Prefernottosay.setAutoDraw(True)
        
        # if occupation_Prefernottosay is active this frame...
        if occupation_Prefernottosay.status == STARTED:
            # update params
            pass
            # check whether occupation_Prefernottosay has been pressed
            if occupation_Prefernottosay.isClicked:
                if not occupation_Prefernottosay.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    occupation_Prefernottosay.timesOn.append(occupation_Prefernottosay.buttonClock.getTime())
                    occupation_Prefernottosay.timesOff.append(occupation_Prefernottosay.buttonClock.getTime())
                elif len(occupation_Prefernottosay.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    occupation_Prefernottosay.timesOff[-1] = occupation_Prefernottosay.buttonClock.getTime()
                if not occupation_Prefernottosay.wasClicked:
                    # end routine when occupation_Prefernottosay is clicked
                    continueRoutine = False
                if not occupation_Prefernottosay.wasClicked:
                    # run callback code when occupation_Prefernottosay is clicked
                    thisExp.addData('occupation_level', '99')
        # take note of whether occupation_Prefernottosay was clicked, so that next frame we know if clicks are new
        occupation_Prefernottosay.wasClicked = occupation_Prefernottosay.isClicked and occupation_Prefernottosay.status == STARTED
        
        # *Q9* updates
        
        # if Q9 is starting this frame...
        if Q9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q9.frameNStart = frameN  # exact frame index
            Q9.tStart = t  # local t and not account for scr refresh
            Q9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q9.started')
            # update status
            Q9.status = STARTED
            Q9.setAutoDraw(True)
        
        # if Q9 is active this frame...
        if Q9.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=occupation_type,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            occupation_type.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in occupation_type.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "occupation_type" ---
    for thisComponent in occupation_type.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for occupation_type
    occupation_type.tStop = globalClock.getTime(format='float')
    occupation_type.tStopRefresh = tThisFlipGlobal
    thisExp.addData('occupation_type.stopped', occupation_type.tStop)
    thisExp.addData('occupation_Education.numClicks', occupation_Education.numClicks)
    if occupation_Education.numClicks:
       thisExp.addData('occupation_Education.timesOn', occupation_Education.timesOn)
       thisExp.addData('occupation_Education.timesOff', occupation_Education.timesOff)
    else:
       thisExp.addData('occupation_Education.timesOn', "")
       thisExp.addData('occupation_Education.timesOff', "")
    thisExp.addData('occupation_Healthcare.numClicks', occupation_Healthcare.numClicks)
    if occupation_Healthcare.numClicks:
       thisExp.addData('occupation_Healthcare.timesOn', occupation_Healthcare.timesOn)
       thisExp.addData('occupation_Healthcare.timesOff', occupation_Healthcare.timesOff)
    else:
       thisExp.addData('occupation_Healthcare.timesOn', "")
       thisExp.addData('occupation_Healthcare.timesOff', "")
    thisExp.addData('occupation_Government.numClicks', occupation_Government.numClicks)
    if occupation_Government.numClicks:
       thisExp.addData('occupation_Government.timesOn', occupation_Government.timesOn)
       thisExp.addData('occupation_Government.timesOff', occupation_Government.timesOff)
    else:
       thisExp.addData('occupation_Government.timesOn', "")
       thisExp.addData('occupation_Government.timesOff', "")
    thisExp.addData('occupation_Business.numClicks', occupation_Business.numClicks)
    if occupation_Business.numClicks:
       thisExp.addData('occupation_Business.timesOn', occupation_Business.timesOn)
       thisExp.addData('occupation_Business.timesOff', occupation_Business.timesOff)
    else:
       thisExp.addData('occupation_Business.timesOn', "")
       thisExp.addData('occupation_Business.timesOff', "")
    thisExp.addData('occupation_Selfemployed.numClicks', occupation_Selfemployed.numClicks)
    if occupation_Selfemployed.numClicks:
       thisExp.addData('occupation_Selfemployed.timesOn', occupation_Selfemployed.timesOn)
       thisExp.addData('occupation_Selfemployed.timesOff', occupation_Selfemployed.timesOff)
    else:
       thisExp.addData('occupation_Selfemployed.timesOn', "")
       thisExp.addData('occupation_Selfemployed.timesOff', "")
    thisExp.addData('occupation_Homemaker.numClicks', occupation_Homemaker.numClicks)
    if occupation_Homemaker.numClicks:
       thisExp.addData('occupation_Homemaker.timesOn', occupation_Homemaker.timesOn)
       thisExp.addData('occupation_Homemaker.timesOff', occupation_Homemaker.timesOff)
    else:
       thisExp.addData('occupation_Homemaker.timesOn', "")
       thisExp.addData('occupation_Homemaker.timesOff', "")
    thisExp.addData('occupation_Student.numClicks', occupation_Student.numClicks)
    if occupation_Student.numClicks:
       thisExp.addData('occupation_Student.timesOn', occupation_Student.timesOn)
       thisExp.addData('occupation_Student.timesOff', occupation_Student.timesOff)
    else:
       thisExp.addData('occupation_Student.timesOn', "")
       thisExp.addData('occupation_Student.timesOff', "")
    thisExp.addData('occupation_Unemployed.numClicks', occupation_Unemployed.numClicks)
    if occupation_Unemployed.numClicks:
       thisExp.addData('occupation_Unemployed.timesOn', occupation_Unemployed.timesOn)
       thisExp.addData('occupation_Unemployed.timesOff', occupation_Unemployed.timesOff)
    else:
       thisExp.addData('occupation_Unemployed.timesOn', "")
       thisExp.addData('occupation_Unemployed.timesOff', "")
    thisExp.addData('occupation_Retired.numClicks', occupation_Retired.numClicks)
    if occupation_Retired.numClicks:
       thisExp.addData('occupation_Retired.timesOn', occupation_Retired.timesOn)
       thisExp.addData('occupation_Retired.timesOff', occupation_Retired.timesOff)
    else:
       thisExp.addData('occupation_Retired.timesOn', "")
       thisExp.addData('occupation_Retired.timesOff', "")
    thisExp.addData('occupation_Other.numClicks', occupation_Other.numClicks)
    if occupation_Other.numClicks:
       thisExp.addData('occupation_Other.timesOn', occupation_Other.timesOn)
       thisExp.addData('occupation_Other.timesOff', occupation_Other.timesOff)
    else:
       thisExp.addData('occupation_Other.timesOn', "")
       thisExp.addData('occupation_Other.timesOff', "")
    thisExp.addData('occupation_Prefernottosay.numClicks', occupation_Prefernottosay.numClicks)
    if occupation_Prefernottosay.numClicks:
       thisExp.addData('occupation_Prefernottosay.timesOn', occupation_Prefernottosay.timesOn)
       thisExp.addData('occupation_Prefernottosay.timesOff', occupation_Prefernottosay.timesOff)
    else:
       thisExp.addData('occupation_Prefernottosay.timesOn', "")
       thisExp.addData('occupation_Prefernottosay.timesOff', "")
    thisExp.nextEntry()
    # the Routine "occupation_type" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "family_income" ---
    # create an object to store info about Routine family_income
    family_income = data.Routine(
        name='family_income',
        components=[Q_family_income, income_20000, income_20001to50000, income_50001to100000, income_100001to150000, income_150001to200000, income_Morethan200000, income_Prefernottosay, Q10],
    )
    family_income.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset income_20000 to account for continued clicks & clear times on/off
    income_20000.reset()
    # reset income_20001to50000 to account for continued clicks & clear times on/off
    income_20001to50000.reset()
    # reset income_50001to100000 to account for continued clicks & clear times on/off
    income_50001to100000.reset()
    # reset income_100001to150000 to account for continued clicks & clear times on/off
    income_100001to150000.reset()
    # reset income_150001to200000 to account for continued clicks & clear times on/off
    income_150001to200000.reset()
    # reset income_Morethan200000 to account for continued clicks & clear times on/off
    income_Morethan200000.reset()
    # reset income_Prefernottosay to account for continued clicks & clear times on/off
    income_Prefernottosay.reset()
    # store start times for family_income
    family_income.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    family_income.tStart = globalClock.getTime(format='float')
    family_income.status = STARTED
    thisExp.addData('family_income.started', family_income.tStart)
    family_income.maxDuration = None
    # keep track of which components have finished
    family_incomeComponents = family_income.components
    for thisComponent in family_income.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "family_income" ---
    family_income.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_family_income* updates
        
        # if Q_family_income is starting this frame...
        if Q_family_income.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_family_income.frameNStart = frameN  # exact frame index
            Q_family_income.tStart = t  # local t and not account for scr refresh
            Q_family_income.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_family_income, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_family_income.started')
            # update status
            Q_family_income.status = STARTED
            Q_family_income.setAutoDraw(True)
        
        # if Q_family_income is active this frame...
        if Q_family_income.status == STARTED:
            # update params
            pass
        # *income_20000* updates
        
        # if income_20000 is starting this frame...
        if income_20000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_20000.frameNStart = frameN  # exact frame index
            income_20000.tStart = t  # local t and not account for scr refresh
            income_20000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_20000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_20000.started')
            # update status
            income_20000.status = STARTED
            win.callOnFlip(income_20000.buttonClock.reset)
            income_20000.setAutoDraw(True)
        
        # if income_20000 is active this frame...
        if income_20000.status == STARTED:
            # update params
            pass
            # check whether income_20000 has been pressed
            if income_20000.isClicked:
                if not income_20000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_20000.timesOn.append(income_20000.buttonClock.getTime())
                    income_20000.timesOff.append(income_20000.buttonClock.getTime())
                elif len(income_20000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_20000.timesOff[-1] = income_20000.buttonClock.getTime()
                if not income_20000.wasClicked:
                    # end routine when income_20000 is clicked
                    continueRoutine = False
                if not income_20000.wasClicked:
                    # run callback code when income_20000 is clicked
                    thisExp.addData('family_income_level', '1')
        # take note of whether income_20000 was clicked, so that next frame we know if clicks are new
        income_20000.wasClicked = income_20000.isClicked and income_20000.status == STARTED
        # *income_20001to50000* updates
        
        # if income_20001to50000 is starting this frame...
        if income_20001to50000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_20001to50000.frameNStart = frameN  # exact frame index
            income_20001to50000.tStart = t  # local t and not account for scr refresh
            income_20001to50000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_20001to50000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_20001to50000.started')
            # update status
            income_20001to50000.status = STARTED
            win.callOnFlip(income_20001to50000.buttonClock.reset)
            income_20001to50000.setAutoDraw(True)
        
        # if income_20001to50000 is active this frame...
        if income_20001to50000.status == STARTED:
            # update params
            pass
            # check whether income_20001to50000 has been pressed
            if income_20001to50000.isClicked:
                if not income_20001to50000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_20001to50000.timesOn.append(income_20001to50000.buttonClock.getTime())
                    income_20001to50000.timesOff.append(income_20001to50000.buttonClock.getTime())
                elif len(income_20001to50000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_20001to50000.timesOff[-1] = income_20001to50000.buttonClock.getTime()
                if not income_20001to50000.wasClicked:
                    # end routine when income_20001to50000 is clicked
                    continueRoutine = False
                if not income_20001to50000.wasClicked:
                    # run callback code when income_20001to50000 is clicked
                    thisExp.addData('family_income_level', '2')
        # take note of whether income_20001to50000 was clicked, so that next frame we know if clicks are new
        income_20001to50000.wasClicked = income_20001to50000.isClicked and income_20001to50000.status == STARTED
        # *income_50001to100000* updates
        
        # if income_50001to100000 is starting this frame...
        if income_50001to100000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_50001to100000.frameNStart = frameN  # exact frame index
            income_50001to100000.tStart = t  # local t and not account for scr refresh
            income_50001to100000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_50001to100000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_50001to100000.started')
            # update status
            income_50001to100000.status = STARTED
            win.callOnFlip(income_50001to100000.buttonClock.reset)
            income_50001to100000.setAutoDraw(True)
        
        # if income_50001to100000 is active this frame...
        if income_50001to100000.status == STARTED:
            # update params
            pass
            # check whether income_50001to100000 has been pressed
            if income_50001to100000.isClicked:
                if not income_50001to100000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_50001to100000.timesOn.append(income_50001to100000.buttonClock.getTime())
                    income_50001to100000.timesOff.append(income_50001to100000.buttonClock.getTime())
                elif len(income_50001to100000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_50001to100000.timesOff[-1] = income_50001to100000.buttonClock.getTime()
                if not income_50001to100000.wasClicked:
                    # end routine when income_50001to100000 is clicked
                    continueRoutine = False
                if not income_50001to100000.wasClicked:
                    # run callback code when income_50001to100000 is clicked
                    thisExp.addData('family_income_level', '3')
        # take note of whether income_50001to100000 was clicked, so that next frame we know if clicks are new
        income_50001to100000.wasClicked = income_50001to100000.isClicked and income_50001to100000.status == STARTED
        # *income_100001to150000* updates
        
        # if income_100001to150000 is starting this frame...
        if income_100001to150000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_100001to150000.frameNStart = frameN  # exact frame index
            income_100001to150000.tStart = t  # local t and not account for scr refresh
            income_100001to150000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_100001to150000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_100001to150000.started')
            # update status
            income_100001to150000.status = STARTED
            win.callOnFlip(income_100001to150000.buttonClock.reset)
            income_100001to150000.setAutoDraw(True)
        
        # if income_100001to150000 is active this frame...
        if income_100001to150000.status == STARTED:
            # update params
            pass
            # check whether income_100001to150000 has been pressed
            if income_100001to150000.isClicked:
                if not income_100001to150000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_100001to150000.timesOn.append(income_100001to150000.buttonClock.getTime())
                    income_100001to150000.timesOff.append(income_100001to150000.buttonClock.getTime())
                elif len(income_100001to150000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_100001to150000.timesOff[-1] = income_100001to150000.buttonClock.getTime()
                if not income_100001to150000.wasClicked:
                    # end routine when income_100001to150000 is clicked
                    continueRoutine = False
                if not income_100001to150000.wasClicked:
                    # run callback code when income_100001to150000 is clicked
                    thisExp.addData('family_income_level', '4')
        # take note of whether income_100001to150000 was clicked, so that next frame we know if clicks are new
        income_100001to150000.wasClicked = income_100001to150000.isClicked and income_100001to150000.status == STARTED
        # *income_150001to200000* updates
        
        # if income_150001to200000 is starting this frame...
        if income_150001to200000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_150001to200000.frameNStart = frameN  # exact frame index
            income_150001to200000.tStart = t  # local t and not account for scr refresh
            income_150001to200000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_150001to200000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_150001to200000.started')
            # update status
            income_150001to200000.status = STARTED
            win.callOnFlip(income_150001to200000.buttonClock.reset)
            income_150001to200000.setAutoDraw(True)
        
        # if income_150001to200000 is active this frame...
        if income_150001to200000.status == STARTED:
            # update params
            pass
            # check whether income_150001to200000 has been pressed
            if income_150001to200000.isClicked:
                if not income_150001to200000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_150001to200000.timesOn.append(income_150001to200000.buttonClock.getTime())
                    income_150001to200000.timesOff.append(income_150001to200000.buttonClock.getTime())
                elif len(income_150001to200000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_150001to200000.timesOff[-1] = income_150001to200000.buttonClock.getTime()
                if not income_150001to200000.wasClicked:
                    # end routine when income_150001to200000 is clicked
                    continueRoutine = False
                if not income_150001to200000.wasClicked:
                    # run callback code when income_150001to200000 is clicked
                    thisExp.addData('family_income_level', '5')
        # take note of whether income_150001to200000 was clicked, so that next frame we know if clicks are new
        income_150001to200000.wasClicked = income_150001to200000.isClicked and income_150001to200000.status == STARTED
        # *income_Morethan200000* updates
        
        # if income_Morethan200000 is starting this frame...
        if income_Morethan200000.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_Morethan200000.frameNStart = frameN  # exact frame index
            income_Morethan200000.tStart = t  # local t and not account for scr refresh
            income_Morethan200000.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_Morethan200000, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_Morethan200000.started')
            # update status
            income_Morethan200000.status = STARTED
            win.callOnFlip(income_Morethan200000.buttonClock.reset)
            income_Morethan200000.setAutoDraw(True)
        
        # if income_Morethan200000 is active this frame...
        if income_Morethan200000.status == STARTED:
            # update params
            pass
            # check whether income_Morethan200000 has been pressed
            if income_Morethan200000.isClicked:
                if not income_Morethan200000.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_Morethan200000.timesOn.append(income_Morethan200000.buttonClock.getTime())
                    income_Morethan200000.timesOff.append(income_Morethan200000.buttonClock.getTime())
                elif len(income_Morethan200000.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_Morethan200000.timesOff[-1] = income_Morethan200000.buttonClock.getTime()
                if not income_Morethan200000.wasClicked:
                    # end routine when income_Morethan200000 is clicked
                    continueRoutine = False
                if not income_Morethan200000.wasClicked:
                    # run callback code when income_Morethan200000 is clicked
                    thisExp.addData('family_income_level', '6')
        # take note of whether income_Morethan200000 was clicked, so that next frame we know if clicks are new
        income_Morethan200000.wasClicked = income_Morethan200000.isClicked and income_Morethan200000.status == STARTED
        # *income_Prefernottosay* updates
        
        # if income_Prefernottosay is starting this frame...
        if income_Prefernottosay.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            income_Prefernottosay.frameNStart = frameN  # exact frame index
            income_Prefernottosay.tStart = t  # local t and not account for scr refresh
            income_Prefernottosay.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(income_Prefernottosay, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'income_Prefernottosay.started')
            # update status
            income_Prefernottosay.status = STARTED
            win.callOnFlip(income_Prefernottosay.buttonClock.reset)
            income_Prefernottosay.setAutoDraw(True)
        
        # if income_Prefernottosay is active this frame...
        if income_Prefernottosay.status == STARTED:
            # update params
            pass
            # check whether income_Prefernottosay has been pressed
            if income_Prefernottosay.isClicked:
                if not income_Prefernottosay.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    income_Prefernottosay.timesOn.append(income_Prefernottosay.buttonClock.getTime())
                    income_Prefernottosay.timesOff.append(income_Prefernottosay.buttonClock.getTime())
                elif len(income_Prefernottosay.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    income_Prefernottosay.timesOff[-1] = income_Prefernottosay.buttonClock.getTime()
                if not income_Prefernottosay.wasClicked:
                    # end routine when income_Prefernottosay is clicked
                    continueRoutine = False
                if not income_Prefernottosay.wasClicked:
                    # run callback code when income_Prefernottosay is clicked
                    thisExp.addData('family_income_level', '99')
        # take note of whether income_Prefernottosay was clicked, so that next frame we know if clicks are new
        income_Prefernottosay.wasClicked = income_Prefernottosay.isClicked and income_Prefernottosay.status == STARTED
        
        # *Q10* updates
        
        # if Q10 is starting this frame...
        if Q10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q10.frameNStart = frameN  # exact frame index
            Q10.tStart = t  # local t and not account for scr refresh
            Q10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q10, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q10.started')
            # update status
            Q10.status = STARTED
            Q10.setAutoDraw(True)
        
        # if Q10 is active this frame...
        if Q10.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=family_income,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            family_income.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in family_income.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "family_income" ---
    for thisComponent in family_income.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for family_income
    family_income.tStop = globalClock.getTime(format='float')
    family_income.tStopRefresh = tThisFlipGlobal
    thisExp.addData('family_income.stopped', family_income.tStop)
    thisExp.addData('income_20000.numClicks', income_20000.numClicks)
    if income_20000.numClicks:
       thisExp.addData('income_20000.timesOn', income_20000.timesOn)
       thisExp.addData('income_20000.timesOff', income_20000.timesOff)
    else:
       thisExp.addData('income_20000.timesOn', "")
       thisExp.addData('income_20000.timesOff', "")
    thisExp.addData('income_20001to50000.numClicks', income_20001to50000.numClicks)
    if income_20001to50000.numClicks:
       thisExp.addData('income_20001to50000.timesOn', income_20001to50000.timesOn)
       thisExp.addData('income_20001to50000.timesOff', income_20001to50000.timesOff)
    else:
       thisExp.addData('income_20001to50000.timesOn', "")
       thisExp.addData('income_20001to50000.timesOff', "")
    thisExp.addData('income_50001to100000.numClicks', income_50001to100000.numClicks)
    if income_50001to100000.numClicks:
       thisExp.addData('income_50001to100000.timesOn', income_50001to100000.timesOn)
       thisExp.addData('income_50001to100000.timesOff', income_50001to100000.timesOff)
    else:
       thisExp.addData('income_50001to100000.timesOn', "")
       thisExp.addData('income_50001to100000.timesOff', "")
    thisExp.addData('income_100001to150000.numClicks', income_100001to150000.numClicks)
    if income_100001to150000.numClicks:
       thisExp.addData('income_100001to150000.timesOn', income_100001to150000.timesOn)
       thisExp.addData('income_100001to150000.timesOff', income_100001to150000.timesOff)
    else:
       thisExp.addData('income_100001to150000.timesOn', "")
       thisExp.addData('income_100001to150000.timesOff', "")
    thisExp.addData('income_150001to200000.numClicks', income_150001to200000.numClicks)
    if income_150001to200000.numClicks:
       thisExp.addData('income_150001to200000.timesOn', income_150001to200000.timesOn)
       thisExp.addData('income_150001to200000.timesOff', income_150001to200000.timesOff)
    else:
       thisExp.addData('income_150001to200000.timesOn', "")
       thisExp.addData('income_150001to200000.timesOff', "")
    thisExp.addData('income_Morethan200000.numClicks', income_Morethan200000.numClicks)
    if income_Morethan200000.numClicks:
       thisExp.addData('income_Morethan200000.timesOn', income_Morethan200000.timesOn)
       thisExp.addData('income_Morethan200000.timesOff', income_Morethan200000.timesOff)
    else:
       thisExp.addData('income_Morethan200000.timesOn', "")
       thisExp.addData('income_Morethan200000.timesOff', "")
    thisExp.addData('income_Prefernottosay.numClicks', income_Prefernottosay.numClicks)
    if income_Prefernottosay.numClicks:
       thisExp.addData('income_Prefernottosay.timesOn', income_Prefernottosay.timesOn)
       thisExp.addData('income_Prefernottosay.timesOff', income_Prefernottosay.timesOff)
    else:
       thisExp.addData('income_Prefernottosay.timesOn', "")
       thisExp.addData('income_Prefernottosay.timesOff', "")
    thisExp.nextEntry()
    # the Routine "family_income" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "height" ---
    # create an object to store info about Routine height
    height = data.Routine(
        name='height',
        components=[Q_height_text, textbox_height, height_hint, Q11],
    )
    height.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_height.reset()
    # store start times for height
    height.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    height.tStart = globalClock.getTime(format='float')
    height.status = STARTED
    thisExp.addData('height.started', height.tStart)
    height.maxDuration = None
    # keep track of which components have finished
    heightComponents = height.components
    for thisComponent in height.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "height" ---
    height.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_height_text* updates
        
        # if Q_height_text is starting this frame...
        if Q_height_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_height_text.frameNStart = frameN  # exact frame index
            Q_height_text.tStart = t  # local t and not account for scr refresh
            Q_height_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_height_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_height_text.started')
            # update status
            Q_height_text.status = STARTED
            Q_height_text.setAutoDraw(True)
        
        # if Q_height_text is active this frame...
        if Q_height_text.status == STARTED:
            # update params
            pass
        
        # *textbox_height* updates
        
        # if textbox_height is starting this frame...
        if textbox_height.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_height.frameNStart = frameN  # exact frame index
            textbox_height.tStart = t  # local t and not account for scr refresh
            textbox_height.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_height, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_height.started')
            # update status
            textbox_height.status = STARTED
            textbox_height.setAutoDraw(True)
        
        # if textbox_height is active this frame...
        if textbox_height.status == STARTED:
            # update params
            pass
        
        # *height_hint* updates
        
        # if height_hint is starting this frame...
        if height_hint.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            height_hint.frameNStart = frameN  # exact frame index
            height_hint.tStart = t  # local t and not account for scr refresh
            height_hint.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(height_hint, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'height_hint.started')
            # update status
            height_hint.status = STARTED
            height_hint.setAutoDraw(True)
        
        # if height_hint is active this frame...
        if height_hint.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_height
        if not hasattr(thisExp, 'allow_advance_height'):
            thisExp.allow_advance_height = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_height.text.strip()
            if user_input != '':
                thisExp.allow_advance_height = True
        
        if thisExp.allow_advance_height:
            continueRoutine = False
        
        
        # *Q11* updates
        
        # if Q11 is starting this frame...
        if Q11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q11.frameNStart = frameN  # exact frame index
            Q11.tStart = t  # local t and not account for scr refresh
            Q11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q11.started')
            # update status
            Q11.status = STARTED
            Q11.setAutoDraw(True)
        
        # if Q11 is active this frame...
        if Q11.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=height,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            height.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in height.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "height" ---
    for thisComponent in height.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for height
    height.tStop = globalClock.getTime(format='float')
    height.tStopRefresh = tThisFlipGlobal
    thisExp.addData('height.stopped', height.tStop)
    thisExp.addData('textbox_height.text',textbox_height.text)
    # Run 'End Routine' code from code_height
    thisExp.addData('height', textbox_height.text)
    
    thisExp.nextEntry()
    # the Routine "height" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "weight" ---
    # create an object to store info about Routine weight
    weight = data.Routine(
        name='weight',
        components=[Q_weight_text, textbox_weight, weight_hint, Q12],
    )
    weight.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_weight.reset()
    # store start times for weight
    weight.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    weight.tStart = globalClock.getTime(format='float')
    weight.status = STARTED
    thisExp.addData('weight.started', weight.tStart)
    weight.maxDuration = None
    # keep track of which components have finished
    weightComponents = weight.components
    for thisComponent in weight.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "weight" ---
    weight.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_weight_text* updates
        
        # if Q_weight_text is starting this frame...
        if Q_weight_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_weight_text.frameNStart = frameN  # exact frame index
            Q_weight_text.tStart = t  # local t and not account for scr refresh
            Q_weight_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_weight_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_weight_text.started')
            # update status
            Q_weight_text.status = STARTED
            Q_weight_text.setAutoDraw(True)
        
        # if Q_weight_text is active this frame...
        if Q_weight_text.status == STARTED:
            # update params
            pass
        
        # *textbox_weight* updates
        
        # if textbox_weight is starting this frame...
        if textbox_weight.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_weight.frameNStart = frameN  # exact frame index
            textbox_weight.tStart = t  # local t and not account for scr refresh
            textbox_weight.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_weight, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_weight.started')
            # update status
            textbox_weight.status = STARTED
            textbox_weight.setAutoDraw(True)
        
        # if textbox_weight is active this frame...
        if textbox_weight.status == STARTED:
            # update params
            pass
        
        # *weight_hint* updates
        
        # if weight_hint is starting this frame...
        if weight_hint.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            weight_hint.frameNStart = frameN  # exact frame index
            weight_hint.tStart = t  # local t and not account for scr refresh
            weight_hint.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(weight_hint, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'weight_hint.started')
            # update status
            weight_hint.status = STARTED
            weight_hint.setAutoDraw(True)
        
        # if weight_hint is active this frame...
        if weight_hint.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_weight
        if not hasattr(thisExp, 'allow_advance_weight'):
            thisExp.allow_advance_weight = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_weight.text.strip()
            if user_input != '':
                thisExp.allow_advance_weight = True
        
        if thisExp.allow_advance_weight:
            continueRoutine = False
        
        
        # *Q12* updates
        
        # if Q12 is starting this frame...
        if Q12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q12.frameNStart = frameN  # exact frame index
            Q12.tStart = t  # local t and not account for scr refresh
            Q12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q12, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q12.started')
            # update status
            Q12.status = STARTED
            Q12.setAutoDraw(True)
        
        # if Q12 is active this frame...
        if Q12.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=weight,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            weight.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in weight.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "weight" ---
    for thisComponent in weight.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for weight
    weight.tStop = globalClock.getTime(format='float')
    weight.tStopRefresh = tThisFlipGlobal
    thisExp.addData('weight.stopped', weight.tStop)
    thisExp.addData('textbox_weight.text',textbox_weight.text)
    # Run 'End Routine' code from code_weight
    # 保存体重输入（允许空值）
    thisExp.addData('weight', textbox_weight.text.strip())
    
    
    thisExp.nextEntry()
    # the Routine "weight" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "waistline" ---
    # create an object to store info about Routine waistline
    waistline = data.Routine(
        name='waistline',
        components=[Q_waistline_text, textbox_waistline, waistline_hint, Q13],
    )
    waistline.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_waistline.reset()
    # store start times for waistline
    waistline.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    waistline.tStart = globalClock.getTime(format='float')
    waistline.status = STARTED
    thisExp.addData('waistline.started', waistline.tStart)
    waistline.maxDuration = None
    # keep track of which components have finished
    waistlineComponents = waistline.components
    for thisComponent in waistline.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "waistline" ---
    waistline.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_waistline_text* updates
        
        # if Q_waistline_text is starting this frame...
        if Q_waistline_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_waistline_text.frameNStart = frameN  # exact frame index
            Q_waistline_text.tStart = t  # local t and not account for scr refresh
            Q_waistline_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_waistline_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_waistline_text.started')
            # update status
            Q_waistline_text.status = STARTED
            Q_waistline_text.setAutoDraw(True)
        
        # if Q_waistline_text is active this frame...
        if Q_waistline_text.status == STARTED:
            # update params
            pass
        
        # *textbox_waistline* updates
        
        # if textbox_waistline is starting this frame...
        if textbox_waistline.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_waistline.frameNStart = frameN  # exact frame index
            textbox_waistline.tStart = t  # local t and not account for scr refresh
            textbox_waistline.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_waistline, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_waistline.started')
            # update status
            textbox_waistline.status = STARTED
            textbox_waistline.setAutoDraw(True)
        
        # if textbox_waistline is active this frame...
        if textbox_waistline.status == STARTED:
            # update params
            pass
        
        # *waistline_hint* updates
        
        # if waistline_hint is starting this frame...
        if waistline_hint.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            waistline_hint.frameNStart = frameN  # exact frame index
            waistline_hint.tStart = t  # local t and not account for scr refresh
            waistline_hint.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(waistline_hint, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'waistline_hint.started')
            # update status
            waistline_hint.status = STARTED
            waistline_hint.setAutoDraw(True)
        
        # if waistline_hint is active this frame...
        if waistline_hint.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_waistline_2
        if not hasattr(thisExp, 'allow_advance_waistline'):
            thisExp.allow_advance_waistline = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_waistline.text.strip()
            if user_input != '':
                thisExp.allow_advance_waistline = True
        
        if thisExp.allow_advance_waistline:
            continueRoutine = False
        
        
        # *Q13* updates
        
        # if Q13 is starting this frame...
        if Q13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q13.frameNStart = frameN  # exact frame index
            Q13.tStart = t  # local t and not account for scr refresh
            Q13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q13.started')
            # update status
            Q13.status = STARTED
            Q13.setAutoDraw(True)
        
        # if Q13 is active this frame...
        if Q13.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=waistline,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            waistline.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in waistline.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "waistline" ---
    for thisComponent in waistline.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for waistline
    waistline.tStop = globalClock.getTime(format='float')
    waistline.tStopRefresh = tThisFlipGlobal
    thisExp.addData('waistline.stopped', waistline.tStop)
    thisExp.addData('textbox_waistline.text',textbox_waistline.text)
    # Run 'End Routine' code from code_waistline_2
    # 保存体重输入（允许空值）
    thisExp.addData('waistline', textbox_waistline.text.strip())
    
    
    thisExp.nextEntry()
    # the Routine "waistline" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ever_drink_alcohol" ---
    # create an object to store info about Routine ever_drink_alcohol
    ever_drink_alcohol = data.Routine(
        name='ever_drink_alcohol',
        components=[Q_ever_drink_alcohol, ever_drink_alcohol_yes, ever_drink_alcohol_no, Q14],
    )
    ever_drink_alcohol.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset ever_drink_alcohol_yes to account for continued clicks & clear times on/off
    ever_drink_alcohol_yes.reset()
    # reset ever_drink_alcohol_no to account for continued clicks & clear times on/off
    ever_drink_alcohol_no.reset()
    # store start times for ever_drink_alcohol
    ever_drink_alcohol.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ever_drink_alcohol.tStart = globalClock.getTime(format='float')
    ever_drink_alcohol.status = STARTED
    thisExp.addData('ever_drink_alcohol.started', ever_drink_alcohol.tStart)
    ever_drink_alcohol.maxDuration = None
    # keep track of which components have finished
    ever_drink_alcoholComponents = ever_drink_alcohol.components
    for thisComponent in ever_drink_alcohol.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ever_drink_alcohol" ---
    ever_drink_alcohol.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_ever_drink_alcohol* updates
        
        # if Q_ever_drink_alcohol is starting this frame...
        if Q_ever_drink_alcohol.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_ever_drink_alcohol.frameNStart = frameN  # exact frame index
            Q_ever_drink_alcohol.tStart = t  # local t and not account for scr refresh
            Q_ever_drink_alcohol.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_ever_drink_alcohol, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_ever_drink_alcohol.started')
            # update status
            Q_ever_drink_alcohol.status = STARTED
            Q_ever_drink_alcohol.setAutoDraw(True)
        
        # if Q_ever_drink_alcohol is active this frame...
        if Q_ever_drink_alcohol.status == STARTED:
            # update params
            pass
        # *ever_drink_alcohol_yes* updates
        
        # if ever_drink_alcohol_yes is starting this frame...
        if ever_drink_alcohol_yes.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ever_drink_alcohol_yes.frameNStart = frameN  # exact frame index
            ever_drink_alcohol_yes.tStart = t  # local t and not account for scr refresh
            ever_drink_alcohol_yes.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ever_drink_alcohol_yes, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ever_drink_alcohol_yes.started')
            # update status
            ever_drink_alcohol_yes.status = STARTED
            win.callOnFlip(ever_drink_alcohol_yes.buttonClock.reset)
            ever_drink_alcohol_yes.setAutoDraw(True)
        
        # if ever_drink_alcohol_yes is active this frame...
        if ever_drink_alcohol_yes.status == STARTED:
            # update params
            pass
            # check whether ever_drink_alcohol_yes has been pressed
            if ever_drink_alcohol_yes.isClicked:
                if not ever_drink_alcohol_yes.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ever_drink_alcohol_yes.timesOn.append(ever_drink_alcohol_yes.buttonClock.getTime())
                    ever_drink_alcohol_yes.timesOff.append(ever_drink_alcohol_yes.buttonClock.getTime())
                elif len(ever_drink_alcohol_yes.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ever_drink_alcohol_yes.timesOff[-1] = ever_drink_alcohol_yes.buttonClock.getTime()
                if not ever_drink_alcohol_yes.wasClicked:
                    # end routine when ever_drink_alcohol_yes is clicked
                    continueRoutine = False
                if not ever_drink_alcohol_yes.wasClicked:
                    # run callback code when ever_drink_alcohol_yes is clicked
                    thisExp.addData('ever_drink_alcohol', '1')
        # take note of whether ever_drink_alcohol_yes was clicked, so that next frame we know if clicks are new
        ever_drink_alcohol_yes.wasClicked = ever_drink_alcohol_yes.isClicked and ever_drink_alcohol_yes.status == STARTED
        # *ever_drink_alcohol_no* updates
        
        # if ever_drink_alcohol_no is starting this frame...
        if ever_drink_alcohol_no.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ever_drink_alcohol_no.frameNStart = frameN  # exact frame index
            ever_drink_alcohol_no.tStart = t  # local t and not account for scr refresh
            ever_drink_alcohol_no.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ever_drink_alcohol_no, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ever_drink_alcohol_no.started')
            # update status
            ever_drink_alcohol_no.status = STARTED
            win.callOnFlip(ever_drink_alcohol_no.buttonClock.reset)
            ever_drink_alcohol_no.setAutoDraw(True)
        
        # if ever_drink_alcohol_no is active this frame...
        if ever_drink_alcohol_no.status == STARTED:
            # update params
            pass
            # check whether ever_drink_alcohol_no has been pressed
            if ever_drink_alcohol_no.isClicked:
                if not ever_drink_alcohol_no.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ever_drink_alcohol_no.timesOn.append(ever_drink_alcohol_no.buttonClock.getTime())
                    ever_drink_alcohol_no.timesOff.append(ever_drink_alcohol_no.buttonClock.getTime())
                elif len(ever_drink_alcohol_no.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ever_drink_alcohol_no.timesOff[-1] = ever_drink_alcohol_no.buttonClock.getTime()
                if not ever_drink_alcohol_no.wasClicked:
                    # end routine when ever_drink_alcohol_no is clicked
                    continueRoutine = False
                if not ever_drink_alcohol_no.wasClicked:
                    # run callback code when ever_drink_alcohol_no is clicked
                    thisExp.addData('ever_drink_alcohol', '2')
        # take note of whether ever_drink_alcohol_no was clicked, so that next frame we know if clicks are new
        ever_drink_alcohol_no.wasClicked = ever_drink_alcohol_no.isClicked and ever_drink_alcohol_no.status == STARTED
        
        # *Q14* updates
        
        # if Q14 is starting this frame...
        if Q14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q14.frameNStart = frameN  # exact frame index
            Q14.tStart = t  # local t and not account for scr refresh
            Q14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q14, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q14.started')
            # update status
            Q14.status = STARTED
            Q14.setAutoDraw(True)
        
        # if Q14 is active this frame...
        if Q14.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=ever_drink_alcohol,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ever_drink_alcohol.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ever_drink_alcohol.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ever_drink_alcohol" ---
    for thisComponent in ever_drink_alcohol.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ever_drink_alcohol
    ever_drink_alcohol.tStop = globalClock.getTime(format='float')
    ever_drink_alcohol.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ever_drink_alcohol.stopped', ever_drink_alcohol.tStop)
    thisExp.addData('ever_drink_alcohol_yes.numClicks', ever_drink_alcohol_yes.numClicks)
    if ever_drink_alcohol_yes.numClicks:
       thisExp.addData('ever_drink_alcohol_yes.timesOn', ever_drink_alcohol_yes.timesOn)
       thisExp.addData('ever_drink_alcohol_yes.timesOff', ever_drink_alcohol_yes.timesOff)
    else:
       thisExp.addData('ever_drink_alcohol_yes.timesOn', "")
       thisExp.addData('ever_drink_alcohol_yes.timesOff', "")
    thisExp.addData('ever_drink_alcohol_no.numClicks', ever_drink_alcohol_no.numClicks)
    if ever_drink_alcohol_no.numClicks:
       thisExp.addData('ever_drink_alcohol_no.timesOn', ever_drink_alcohol_no.timesOn)
       thisExp.addData('ever_drink_alcohol_no.timesOff', ever_drink_alcohol_no.timesOff)
    else:
       thisExp.addData('ever_drink_alcohol_no.timesOn', "")
       thisExp.addData('ever_drink_alcohol_no.timesOff', "")
    thisExp.nextEntry()
    # the Routine "ever_drink_alcohol" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "last_drink_time" ---
    # create an object to store info about Routine last_drink_time
    last_drink_time = data.Routine(
        name='last_drink_time',
        components=[Q_last_drink_time, last_drink_time_30days, last_drink_time_in12mons, last_drink_time_over12mons, last_drink_time_never, Q15],
    )
    last_drink_time.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset last_drink_time_30days to account for continued clicks & clear times on/off
    last_drink_time_30days.reset()
    # reset last_drink_time_in12mons to account for continued clicks & clear times on/off
    last_drink_time_in12mons.reset()
    # reset last_drink_time_over12mons to account for continued clicks & clear times on/off
    last_drink_time_over12mons.reset()
    # reset last_drink_time_never to account for continued clicks & clear times on/off
    last_drink_time_never.reset()
    # store start times for last_drink_time
    last_drink_time.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    last_drink_time.tStart = globalClock.getTime(format='float')
    last_drink_time.status = STARTED
    thisExp.addData('last_drink_time.started', last_drink_time.tStart)
    last_drink_time.maxDuration = None
    # keep track of which components have finished
    last_drink_timeComponents = last_drink_time.components
    for thisComponent in last_drink_time.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "last_drink_time" ---
    last_drink_time.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_last_drink_time* updates
        
        # if Q_last_drink_time is starting this frame...
        if Q_last_drink_time.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_last_drink_time.frameNStart = frameN  # exact frame index
            Q_last_drink_time.tStart = t  # local t and not account for scr refresh
            Q_last_drink_time.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_last_drink_time, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_last_drink_time.started')
            # update status
            Q_last_drink_time.status = STARTED
            Q_last_drink_time.setAutoDraw(True)
        
        # if Q_last_drink_time is active this frame...
        if Q_last_drink_time.status == STARTED:
            # update params
            pass
        # *last_drink_time_30days* updates
        
        # if last_drink_time_30days is starting this frame...
        if last_drink_time_30days.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            last_drink_time_30days.frameNStart = frameN  # exact frame index
            last_drink_time_30days.tStart = t  # local t and not account for scr refresh
            last_drink_time_30days.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(last_drink_time_30days, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'last_drink_time_30days.started')
            # update status
            last_drink_time_30days.status = STARTED
            win.callOnFlip(last_drink_time_30days.buttonClock.reset)
            last_drink_time_30days.setAutoDraw(True)
        
        # if last_drink_time_30days is active this frame...
        if last_drink_time_30days.status == STARTED:
            # update params
            pass
            # check whether last_drink_time_30days has been pressed
            if last_drink_time_30days.isClicked:
                if not last_drink_time_30days.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    last_drink_time_30days.timesOn.append(last_drink_time_30days.buttonClock.getTime())
                    last_drink_time_30days.timesOff.append(last_drink_time_30days.buttonClock.getTime())
                elif len(last_drink_time_30days.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    last_drink_time_30days.timesOff[-1] = last_drink_time_30days.buttonClock.getTime()
                if not last_drink_time_30days.wasClicked:
                    # end routine when last_drink_time_30days is clicked
                    continueRoutine = False
                if not last_drink_time_30days.wasClicked:
                    # run callback code when last_drink_time_30days is clicked
                    thisExp.addData('last_drink_time', '1')
        # take note of whether last_drink_time_30days was clicked, so that next frame we know if clicks are new
        last_drink_time_30days.wasClicked = last_drink_time_30days.isClicked and last_drink_time_30days.status == STARTED
        # *last_drink_time_in12mons* updates
        
        # if last_drink_time_in12mons is starting this frame...
        if last_drink_time_in12mons.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            last_drink_time_in12mons.frameNStart = frameN  # exact frame index
            last_drink_time_in12mons.tStart = t  # local t and not account for scr refresh
            last_drink_time_in12mons.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(last_drink_time_in12mons, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'last_drink_time_in12mons.started')
            # update status
            last_drink_time_in12mons.status = STARTED
            win.callOnFlip(last_drink_time_in12mons.buttonClock.reset)
            last_drink_time_in12mons.setAutoDraw(True)
        
        # if last_drink_time_in12mons is active this frame...
        if last_drink_time_in12mons.status == STARTED:
            # update params
            pass
            # check whether last_drink_time_in12mons has been pressed
            if last_drink_time_in12mons.isClicked:
                if not last_drink_time_in12mons.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    last_drink_time_in12mons.timesOn.append(last_drink_time_in12mons.buttonClock.getTime())
                    last_drink_time_in12mons.timesOff.append(last_drink_time_in12mons.buttonClock.getTime())
                elif len(last_drink_time_in12mons.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    last_drink_time_in12mons.timesOff[-1] = last_drink_time_in12mons.buttonClock.getTime()
                if not last_drink_time_in12mons.wasClicked:
                    # end routine when last_drink_time_in12mons is clicked
                    continueRoutine = False
                if not last_drink_time_in12mons.wasClicked:
                    # run callback code when last_drink_time_in12mons is clicked
                    thisExp.addData('last_drink_time', '2')
        # take note of whether last_drink_time_in12mons was clicked, so that next frame we know if clicks are new
        last_drink_time_in12mons.wasClicked = last_drink_time_in12mons.isClicked and last_drink_time_in12mons.status == STARTED
        # *last_drink_time_over12mons* updates
        
        # if last_drink_time_over12mons is starting this frame...
        if last_drink_time_over12mons.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            last_drink_time_over12mons.frameNStart = frameN  # exact frame index
            last_drink_time_over12mons.tStart = t  # local t and not account for scr refresh
            last_drink_time_over12mons.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(last_drink_time_over12mons, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'last_drink_time_over12mons.started')
            # update status
            last_drink_time_over12mons.status = STARTED
            win.callOnFlip(last_drink_time_over12mons.buttonClock.reset)
            last_drink_time_over12mons.setAutoDraw(True)
        
        # if last_drink_time_over12mons is active this frame...
        if last_drink_time_over12mons.status == STARTED:
            # update params
            pass
            # check whether last_drink_time_over12mons has been pressed
            if last_drink_time_over12mons.isClicked:
                if not last_drink_time_over12mons.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    last_drink_time_over12mons.timesOn.append(last_drink_time_over12mons.buttonClock.getTime())
                    last_drink_time_over12mons.timesOff.append(last_drink_time_over12mons.buttonClock.getTime())
                elif len(last_drink_time_over12mons.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    last_drink_time_over12mons.timesOff[-1] = last_drink_time_over12mons.buttonClock.getTime()
                if not last_drink_time_over12mons.wasClicked:
                    # end routine when last_drink_time_over12mons is clicked
                    continueRoutine = False
                if not last_drink_time_over12mons.wasClicked:
                    # run callback code when last_drink_time_over12mons is clicked
                    thisExp.addData('last_drink_time', '3')
        # take note of whether last_drink_time_over12mons was clicked, so that next frame we know if clicks are new
        last_drink_time_over12mons.wasClicked = last_drink_time_over12mons.isClicked and last_drink_time_over12mons.status == STARTED
        # *last_drink_time_never* updates
        
        # if last_drink_time_never is starting this frame...
        if last_drink_time_never.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            last_drink_time_never.frameNStart = frameN  # exact frame index
            last_drink_time_never.tStart = t  # local t and not account for scr refresh
            last_drink_time_never.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(last_drink_time_never, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'last_drink_time_never.started')
            # update status
            last_drink_time_never.status = STARTED
            win.callOnFlip(last_drink_time_never.buttonClock.reset)
            last_drink_time_never.setAutoDraw(True)
        
        # if last_drink_time_never is active this frame...
        if last_drink_time_never.status == STARTED:
            # update params
            pass
            # check whether last_drink_time_never has been pressed
            if last_drink_time_never.isClicked:
                if not last_drink_time_never.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    last_drink_time_never.timesOn.append(last_drink_time_never.buttonClock.getTime())
                    last_drink_time_never.timesOff.append(last_drink_time_never.buttonClock.getTime())
                elif len(last_drink_time_never.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    last_drink_time_never.timesOff[-1] = last_drink_time_never.buttonClock.getTime()
                if not last_drink_time_never.wasClicked:
                    # end routine when last_drink_time_never is clicked
                    continueRoutine = False
                if not last_drink_time_never.wasClicked:
                    # run callback code when last_drink_time_never is clicked
                    thisExp.addData('last_drink_time', '4')
        # take note of whether last_drink_time_never was clicked, so that next frame we know if clicks are new
        last_drink_time_never.wasClicked = last_drink_time_never.isClicked and last_drink_time_never.status == STARTED
        
        # *Q15* updates
        
        # if Q15 is starting this frame...
        if Q15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q15.frameNStart = frameN  # exact frame index
            Q15.tStart = t  # local t and not account for scr refresh
            Q15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q15, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q15.started')
            # update status
            Q15.status = STARTED
            Q15.setAutoDraw(True)
        
        # if Q15 is active this frame...
        if Q15.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=last_drink_time,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            last_drink_time.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in last_drink_time.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "last_drink_time" ---
    for thisComponent in last_drink_time.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for last_drink_time
    last_drink_time.tStop = globalClock.getTime(format='float')
    last_drink_time.tStopRefresh = tThisFlipGlobal
    thisExp.addData('last_drink_time.stopped', last_drink_time.tStop)
    thisExp.addData('last_drink_time_30days.numClicks', last_drink_time_30days.numClicks)
    if last_drink_time_30days.numClicks:
       thisExp.addData('last_drink_time_30days.timesOn', last_drink_time_30days.timesOn)
       thisExp.addData('last_drink_time_30days.timesOff', last_drink_time_30days.timesOff)
    else:
       thisExp.addData('last_drink_time_30days.timesOn', "")
       thisExp.addData('last_drink_time_30days.timesOff', "")
    thisExp.addData('last_drink_time_in12mons.numClicks', last_drink_time_in12mons.numClicks)
    if last_drink_time_in12mons.numClicks:
       thisExp.addData('last_drink_time_in12mons.timesOn', last_drink_time_in12mons.timesOn)
       thisExp.addData('last_drink_time_in12mons.timesOff', last_drink_time_in12mons.timesOff)
    else:
       thisExp.addData('last_drink_time_in12mons.timesOn', "")
       thisExp.addData('last_drink_time_in12mons.timesOff', "")
    thisExp.addData('last_drink_time_over12mons.numClicks', last_drink_time_over12mons.numClicks)
    if last_drink_time_over12mons.numClicks:
       thisExp.addData('last_drink_time_over12mons.timesOn', last_drink_time_over12mons.timesOn)
       thisExp.addData('last_drink_time_over12mons.timesOff', last_drink_time_over12mons.timesOff)
    else:
       thisExp.addData('last_drink_time_over12mons.timesOn', "")
       thisExp.addData('last_drink_time_over12mons.timesOff', "")
    thisExp.addData('last_drink_time_never.numClicks', last_drink_time_never.numClicks)
    if last_drink_time_never.numClicks:
       thisExp.addData('last_drink_time_never.timesOn', last_drink_time_never.timesOn)
       thisExp.addData('last_drink_time_never.timesOff', last_drink_time_never.timesOff)
    else:
       thisExp.addData('last_drink_time_never.timesOn', "")
       thisExp.addData('last_drink_time_never.timesOff', "")
    thisExp.nextEntry()
    # the Routine "last_drink_time" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "drink_freq_12mo_2" ---
    # create an object to store info about Routine drink_freq_12mo_2
    drink_freq_12mo_2 = data.Routine(
        name='drink_freq_12mo_2',
        components=[Q_drink_freq_12mo, drink_freq_12mo_Everyday, drink_freq_12mo_Severaltimesaweek, drink_freq_12mo_Severaltimesamonth, drink_freq_12mo_Rarely, drink_freq_12mo_Never, Q16],
    )
    drink_freq_12mo_2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset drink_freq_12mo_Everyday to account for continued clicks & clear times on/off
    drink_freq_12mo_Everyday.reset()
    # reset drink_freq_12mo_Severaltimesaweek to account for continued clicks & clear times on/off
    drink_freq_12mo_Severaltimesaweek.reset()
    # reset drink_freq_12mo_Severaltimesamonth to account for continued clicks & clear times on/off
    drink_freq_12mo_Severaltimesamonth.reset()
    # reset drink_freq_12mo_Rarely to account for continued clicks & clear times on/off
    drink_freq_12mo_Rarely.reset()
    # reset drink_freq_12mo_Never to account for continued clicks & clear times on/off
    drink_freq_12mo_Never.reset()
    # store start times for drink_freq_12mo_2
    drink_freq_12mo_2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    drink_freq_12mo_2.tStart = globalClock.getTime(format='float')
    drink_freq_12mo_2.status = STARTED
    thisExp.addData('drink_freq_12mo_2.started', drink_freq_12mo_2.tStart)
    drink_freq_12mo_2.maxDuration = None
    # keep track of which components have finished
    drink_freq_12mo_2Components = drink_freq_12mo_2.components
    for thisComponent in drink_freq_12mo_2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "drink_freq_12mo_2" ---
    drink_freq_12mo_2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_drink_freq_12mo* updates
        
        # if Q_drink_freq_12mo is starting this frame...
        if Q_drink_freq_12mo.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_drink_freq_12mo.frameNStart = frameN  # exact frame index
            Q_drink_freq_12mo.tStart = t  # local t and not account for scr refresh
            Q_drink_freq_12mo.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_drink_freq_12mo, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_drink_freq_12mo.started')
            # update status
            Q_drink_freq_12mo.status = STARTED
            Q_drink_freq_12mo.setAutoDraw(True)
        
        # if Q_drink_freq_12mo is active this frame...
        if Q_drink_freq_12mo.status == STARTED:
            # update params
            pass
        # *drink_freq_12mo_Everyday* updates
        
        # if drink_freq_12mo_Everyday is starting this frame...
        if drink_freq_12mo_Everyday.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_freq_12mo_Everyday.frameNStart = frameN  # exact frame index
            drink_freq_12mo_Everyday.tStart = t  # local t and not account for scr refresh
            drink_freq_12mo_Everyday.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_freq_12mo_Everyday, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_freq_12mo_Everyday.started')
            # update status
            drink_freq_12mo_Everyday.status = STARTED
            win.callOnFlip(drink_freq_12mo_Everyday.buttonClock.reset)
            drink_freq_12mo_Everyday.setAutoDraw(True)
        
        # if drink_freq_12mo_Everyday is active this frame...
        if drink_freq_12mo_Everyday.status == STARTED:
            # update params
            pass
            # check whether drink_freq_12mo_Everyday has been pressed
            if drink_freq_12mo_Everyday.isClicked:
                if not drink_freq_12mo_Everyday.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_freq_12mo_Everyday.timesOn.append(drink_freq_12mo_Everyday.buttonClock.getTime())
                    drink_freq_12mo_Everyday.timesOff.append(drink_freq_12mo_Everyday.buttonClock.getTime())
                elif len(drink_freq_12mo_Everyday.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_freq_12mo_Everyday.timesOff[-1] = drink_freq_12mo_Everyday.buttonClock.getTime()
                if not drink_freq_12mo_Everyday.wasClicked:
                    # end routine when drink_freq_12mo_Everyday is clicked
                    continueRoutine = False
                if not drink_freq_12mo_Everyday.wasClicked:
                    # run callback code when drink_freq_12mo_Everyday is clicked
                    thisExp.addData('drink_freq_12mo', '1')
        # take note of whether drink_freq_12mo_Everyday was clicked, so that next frame we know if clicks are new
        drink_freq_12mo_Everyday.wasClicked = drink_freq_12mo_Everyday.isClicked and drink_freq_12mo_Everyday.status == STARTED
        # *drink_freq_12mo_Severaltimesaweek* updates
        
        # if drink_freq_12mo_Severaltimesaweek is starting this frame...
        if drink_freq_12mo_Severaltimesaweek.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_freq_12mo_Severaltimesaweek.frameNStart = frameN  # exact frame index
            drink_freq_12mo_Severaltimesaweek.tStart = t  # local t and not account for scr refresh
            drink_freq_12mo_Severaltimesaweek.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_freq_12mo_Severaltimesaweek, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_freq_12mo_Severaltimesaweek.started')
            # update status
            drink_freq_12mo_Severaltimesaweek.status = STARTED
            win.callOnFlip(drink_freq_12mo_Severaltimesaweek.buttonClock.reset)
            drink_freq_12mo_Severaltimesaweek.setAutoDraw(True)
        
        # if drink_freq_12mo_Severaltimesaweek is active this frame...
        if drink_freq_12mo_Severaltimesaweek.status == STARTED:
            # update params
            pass
            # check whether drink_freq_12mo_Severaltimesaweek has been pressed
            if drink_freq_12mo_Severaltimesaweek.isClicked:
                if not drink_freq_12mo_Severaltimesaweek.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_freq_12mo_Severaltimesaweek.timesOn.append(drink_freq_12mo_Severaltimesaweek.buttonClock.getTime())
                    drink_freq_12mo_Severaltimesaweek.timesOff.append(drink_freq_12mo_Severaltimesaweek.buttonClock.getTime())
                elif len(drink_freq_12mo_Severaltimesaweek.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_freq_12mo_Severaltimesaweek.timesOff[-1] = drink_freq_12mo_Severaltimesaweek.buttonClock.getTime()
                if not drink_freq_12mo_Severaltimesaweek.wasClicked:
                    # end routine when drink_freq_12mo_Severaltimesaweek is clicked
                    continueRoutine = False
                if not drink_freq_12mo_Severaltimesaweek.wasClicked:
                    # run callback code when drink_freq_12mo_Severaltimesaweek is clicked
                    thisExp.addData('drink_freq_12mo', '2')
        # take note of whether drink_freq_12mo_Severaltimesaweek was clicked, so that next frame we know if clicks are new
        drink_freq_12mo_Severaltimesaweek.wasClicked = drink_freq_12mo_Severaltimesaweek.isClicked and drink_freq_12mo_Severaltimesaweek.status == STARTED
        # *drink_freq_12mo_Severaltimesamonth* updates
        
        # if drink_freq_12mo_Severaltimesamonth is starting this frame...
        if drink_freq_12mo_Severaltimesamonth.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_freq_12mo_Severaltimesamonth.frameNStart = frameN  # exact frame index
            drink_freq_12mo_Severaltimesamonth.tStart = t  # local t and not account for scr refresh
            drink_freq_12mo_Severaltimesamonth.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_freq_12mo_Severaltimesamonth, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_freq_12mo_Severaltimesamonth.started')
            # update status
            drink_freq_12mo_Severaltimesamonth.status = STARTED
            win.callOnFlip(drink_freq_12mo_Severaltimesamonth.buttonClock.reset)
            drink_freq_12mo_Severaltimesamonth.setAutoDraw(True)
        
        # if drink_freq_12mo_Severaltimesamonth is active this frame...
        if drink_freq_12mo_Severaltimesamonth.status == STARTED:
            # update params
            pass
            # check whether drink_freq_12mo_Severaltimesamonth has been pressed
            if drink_freq_12mo_Severaltimesamonth.isClicked:
                if not drink_freq_12mo_Severaltimesamonth.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_freq_12mo_Severaltimesamonth.timesOn.append(drink_freq_12mo_Severaltimesamonth.buttonClock.getTime())
                    drink_freq_12mo_Severaltimesamonth.timesOff.append(drink_freq_12mo_Severaltimesamonth.buttonClock.getTime())
                elif len(drink_freq_12mo_Severaltimesamonth.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_freq_12mo_Severaltimesamonth.timesOff[-1] = drink_freq_12mo_Severaltimesamonth.buttonClock.getTime()
                if not drink_freq_12mo_Severaltimesamonth.wasClicked:
                    # end routine when drink_freq_12mo_Severaltimesamonth is clicked
                    continueRoutine = False
                if not drink_freq_12mo_Severaltimesamonth.wasClicked:
                    # run callback code when drink_freq_12mo_Severaltimesamonth is clicked
                    thisExp.addData('drink_freq_12mo', '3')
        # take note of whether drink_freq_12mo_Severaltimesamonth was clicked, so that next frame we know if clicks are new
        drink_freq_12mo_Severaltimesamonth.wasClicked = drink_freq_12mo_Severaltimesamonth.isClicked and drink_freq_12mo_Severaltimesamonth.status == STARTED
        # *drink_freq_12mo_Rarely* updates
        
        # if drink_freq_12mo_Rarely is starting this frame...
        if drink_freq_12mo_Rarely.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_freq_12mo_Rarely.frameNStart = frameN  # exact frame index
            drink_freq_12mo_Rarely.tStart = t  # local t and not account for scr refresh
            drink_freq_12mo_Rarely.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_freq_12mo_Rarely, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_freq_12mo_Rarely.started')
            # update status
            drink_freq_12mo_Rarely.status = STARTED
            win.callOnFlip(drink_freq_12mo_Rarely.buttonClock.reset)
            drink_freq_12mo_Rarely.setAutoDraw(True)
        
        # if drink_freq_12mo_Rarely is active this frame...
        if drink_freq_12mo_Rarely.status == STARTED:
            # update params
            pass
            # check whether drink_freq_12mo_Rarely has been pressed
            if drink_freq_12mo_Rarely.isClicked:
                if not drink_freq_12mo_Rarely.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_freq_12mo_Rarely.timesOn.append(drink_freq_12mo_Rarely.buttonClock.getTime())
                    drink_freq_12mo_Rarely.timesOff.append(drink_freq_12mo_Rarely.buttonClock.getTime())
                elif len(drink_freq_12mo_Rarely.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_freq_12mo_Rarely.timesOff[-1] = drink_freq_12mo_Rarely.buttonClock.getTime()
                if not drink_freq_12mo_Rarely.wasClicked:
                    # end routine when drink_freq_12mo_Rarely is clicked
                    continueRoutine = False
                if not drink_freq_12mo_Rarely.wasClicked:
                    # run callback code when drink_freq_12mo_Rarely is clicked
                    thisExp.addData('drink_freq_12mo', '4')
        # take note of whether drink_freq_12mo_Rarely was clicked, so that next frame we know if clicks are new
        drink_freq_12mo_Rarely.wasClicked = drink_freq_12mo_Rarely.isClicked and drink_freq_12mo_Rarely.status == STARTED
        # *drink_freq_12mo_Never* updates
        
        # if drink_freq_12mo_Never is starting this frame...
        if drink_freq_12mo_Never.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_freq_12mo_Never.frameNStart = frameN  # exact frame index
            drink_freq_12mo_Never.tStart = t  # local t and not account for scr refresh
            drink_freq_12mo_Never.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_freq_12mo_Never, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_freq_12mo_Never.started')
            # update status
            drink_freq_12mo_Never.status = STARTED
            win.callOnFlip(drink_freq_12mo_Never.buttonClock.reset)
            drink_freq_12mo_Never.setAutoDraw(True)
        
        # if drink_freq_12mo_Never is active this frame...
        if drink_freq_12mo_Never.status == STARTED:
            # update params
            pass
            # check whether drink_freq_12mo_Never has been pressed
            if drink_freq_12mo_Never.isClicked:
                if not drink_freq_12mo_Never.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_freq_12mo_Never.timesOn.append(drink_freq_12mo_Never.buttonClock.getTime())
                    drink_freq_12mo_Never.timesOff.append(drink_freq_12mo_Never.buttonClock.getTime())
                elif len(drink_freq_12mo_Never.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_freq_12mo_Never.timesOff[-1] = drink_freq_12mo_Never.buttonClock.getTime()
                if not drink_freq_12mo_Never.wasClicked:
                    # end routine when drink_freq_12mo_Never is clicked
                    continueRoutine = False
                if not drink_freq_12mo_Never.wasClicked:
                    # run callback code when drink_freq_12mo_Never is clicked
                    thisExp.addData('drink_freq_12mo', '5')
        # take note of whether drink_freq_12mo_Never was clicked, so that next frame we know if clicks are new
        drink_freq_12mo_Never.wasClicked = drink_freq_12mo_Never.isClicked and drink_freq_12mo_Never.status == STARTED
        
        # *Q16* updates
        
        # if Q16 is starting this frame...
        if Q16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q16.frameNStart = frameN  # exact frame index
            Q16.tStart = t  # local t and not account for scr refresh
            Q16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q16.started')
            # update status
            Q16.status = STARTED
            Q16.setAutoDraw(True)
        
        # if Q16 is active this frame...
        if Q16.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=drink_freq_12mo_2,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            drink_freq_12mo_2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in drink_freq_12mo_2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "drink_freq_12mo_2" ---
    for thisComponent in drink_freq_12mo_2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for drink_freq_12mo_2
    drink_freq_12mo_2.tStop = globalClock.getTime(format='float')
    drink_freq_12mo_2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('drink_freq_12mo_2.stopped', drink_freq_12mo_2.tStop)
    thisExp.addData('drink_freq_12mo_Everyday.numClicks', drink_freq_12mo_Everyday.numClicks)
    if drink_freq_12mo_Everyday.numClicks:
       thisExp.addData('drink_freq_12mo_Everyday.timesOn', drink_freq_12mo_Everyday.timesOn)
       thisExp.addData('drink_freq_12mo_Everyday.timesOff', drink_freq_12mo_Everyday.timesOff)
    else:
       thisExp.addData('drink_freq_12mo_Everyday.timesOn', "")
       thisExp.addData('drink_freq_12mo_Everyday.timesOff', "")
    thisExp.addData('drink_freq_12mo_Severaltimesaweek.numClicks', drink_freq_12mo_Severaltimesaweek.numClicks)
    if drink_freq_12mo_Severaltimesaweek.numClicks:
       thisExp.addData('drink_freq_12mo_Severaltimesaweek.timesOn', drink_freq_12mo_Severaltimesaweek.timesOn)
       thisExp.addData('drink_freq_12mo_Severaltimesaweek.timesOff', drink_freq_12mo_Severaltimesaweek.timesOff)
    else:
       thisExp.addData('drink_freq_12mo_Severaltimesaweek.timesOn', "")
       thisExp.addData('drink_freq_12mo_Severaltimesaweek.timesOff', "")
    thisExp.addData('drink_freq_12mo_Severaltimesamonth.numClicks', drink_freq_12mo_Severaltimesamonth.numClicks)
    if drink_freq_12mo_Severaltimesamonth.numClicks:
       thisExp.addData('drink_freq_12mo_Severaltimesamonth.timesOn', drink_freq_12mo_Severaltimesamonth.timesOn)
       thisExp.addData('drink_freq_12mo_Severaltimesamonth.timesOff', drink_freq_12mo_Severaltimesamonth.timesOff)
    else:
       thisExp.addData('drink_freq_12mo_Severaltimesamonth.timesOn', "")
       thisExp.addData('drink_freq_12mo_Severaltimesamonth.timesOff', "")
    thisExp.addData('drink_freq_12mo_Rarely.numClicks', drink_freq_12mo_Rarely.numClicks)
    if drink_freq_12mo_Rarely.numClicks:
       thisExp.addData('drink_freq_12mo_Rarely.timesOn', drink_freq_12mo_Rarely.timesOn)
       thisExp.addData('drink_freq_12mo_Rarely.timesOff', drink_freq_12mo_Rarely.timesOff)
    else:
       thisExp.addData('drink_freq_12mo_Rarely.timesOn', "")
       thisExp.addData('drink_freq_12mo_Rarely.timesOff', "")
    thisExp.addData('drink_freq_12mo_Never.numClicks', drink_freq_12mo_Never.numClicks)
    if drink_freq_12mo_Never.numClicks:
       thisExp.addData('drink_freq_12mo_Never.timesOn', drink_freq_12mo_Never.timesOn)
       thisExp.addData('drink_freq_12mo_Never.timesOff', drink_freq_12mo_Never.timesOff)
    else:
       thisExp.addData('drink_freq_12mo_Never.timesOn', "")
       thisExp.addData('drink_freq_12mo_Never.timesOff', "")
    thisExp.nextEntry()
    # the Routine "drink_freq_12mo_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "drink_amount_12mo" ---
    # create an object to store info about Routine drink_amount_12mo
    drink_amount_12mo = data.Routine(
        name='drink_amount_12mo',
        components=[Q_drink_amount_12mo, drink_amount_12mo_0glass, drink_amount_12mo_1glass, drink_amount_12mo_2glass, drink_amount_12mo_3glasses, drink_amount_12mo_4glasses, drink_amount_12mo_5glassesmore, Q17],
    )
    drink_amount_12mo.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset drink_amount_12mo_0glass to account for continued clicks & clear times on/off
    drink_amount_12mo_0glass.reset()
    # reset drink_amount_12mo_1glass to account for continued clicks & clear times on/off
    drink_amount_12mo_1glass.reset()
    # reset drink_amount_12mo_2glass to account for continued clicks & clear times on/off
    drink_amount_12mo_2glass.reset()
    # reset drink_amount_12mo_3glasses to account for continued clicks & clear times on/off
    drink_amount_12mo_3glasses.reset()
    # reset drink_amount_12mo_4glasses to account for continued clicks & clear times on/off
    drink_amount_12mo_4glasses.reset()
    # reset drink_amount_12mo_5glassesmore to account for continued clicks & clear times on/off
    drink_amount_12mo_5glassesmore.reset()
    # store start times for drink_amount_12mo
    drink_amount_12mo.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    drink_amount_12mo.tStart = globalClock.getTime(format='float')
    drink_amount_12mo.status = STARTED
    thisExp.addData('drink_amount_12mo.started', drink_amount_12mo.tStart)
    drink_amount_12mo.maxDuration = None
    # keep track of which components have finished
    drink_amount_12moComponents = drink_amount_12mo.components
    for thisComponent in drink_amount_12mo.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "drink_amount_12mo" ---
    drink_amount_12mo.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_drink_amount_12mo* updates
        
        # if Q_drink_amount_12mo is starting this frame...
        if Q_drink_amount_12mo.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_drink_amount_12mo.frameNStart = frameN  # exact frame index
            Q_drink_amount_12mo.tStart = t  # local t and not account for scr refresh
            Q_drink_amount_12mo.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_drink_amount_12mo, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_drink_amount_12mo.started')
            # update status
            Q_drink_amount_12mo.status = STARTED
            Q_drink_amount_12mo.setAutoDraw(True)
        
        # if Q_drink_amount_12mo is active this frame...
        if Q_drink_amount_12mo.status == STARTED:
            # update params
            pass
        # *drink_amount_12mo_0glass* updates
        
        # if drink_amount_12mo_0glass is starting this frame...
        if drink_amount_12mo_0glass.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_0glass.frameNStart = frameN  # exact frame index
            drink_amount_12mo_0glass.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_0glass.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_0glass, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_0glass.started')
            # update status
            drink_amount_12mo_0glass.status = STARTED
            win.callOnFlip(drink_amount_12mo_0glass.buttonClock.reset)
            drink_amount_12mo_0glass.setAutoDraw(True)
        
        # if drink_amount_12mo_0glass is active this frame...
        if drink_amount_12mo_0glass.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_0glass has been pressed
            if drink_amount_12mo_0glass.isClicked:
                if not drink_amount_12mo_0glass.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_0glass.timesOn.append(drink_amount_12mo_0glass.buttonClock.getTime())
                    drink_amount_12mo_0glass.timesOff.append(drink_amount_12mo_0glass.buttonClock.getTime())
                elif len(drink_amount_12mo_0glass.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_0glass.timesOff[-1] = drink_amount_12mo_0glass.buttonClock.getTime()
                if not drink_amount_12mo_0glass.wasClicked:
                    # end routine when drink_amount_12mo_0glass is clicked
                    continueRoutine = False
                if not drink_amount_12mo_0glass.wasClicked:
                    # run callback code when drink_amount_12mo_0glass is clicked
                    thisExp.addData('drink_amount_12mo', '1')
        # take note of whether drink_amount_12mo_0glass was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_0glass.wasClicked = drink_amount_12mo_0glass.isClicked and drink_amount_12mo_0glass.status == STARTED
        # *drink_amount_12mo_1glass* updates
        
        # if drink_amount_12mo_1glass is starting this frame...
        if drink_amount_12mo_1glass.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_1glass.frameNStart = frameN  # exact frame index
            drink_amount_12mo_1glass.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_1glass.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_1glass, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_1glass.started')
            # update status
            drink_amount_12mo_1glass.status = STARTED
            win.callOnFlip(drink_amount_12mo_1glass.buttonClock.reset)
            drink_amount_12mo_1glass.setAutoDraw(True)
        
        # if drink_amount_12mo_1glass is active this frame...
        if drink_amount_12mo_1glass.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_1glass has been pressed
            if drink_amount_12mo_1glass.isClicked:
                if not drink_amount_12mo_1glass.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_1glass.timesOn.append(drink_amount_12mo_1glass.buttonClock.getTime())
                    drink_amount_12mo_1glass.timesOff.append(drink_amount_12mo_1glass.buttonClock.getTime())
                elif len(drink_amount_12mo_1glass.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_1glass.timesOff[-1] = drink_amount_12mo_1glass.buttonClock.getTime()
                if not drink_amount_12mo_1glass.wasClicked:
                    # end routine when drink_amount_12mo_1glass is clicked
                    continueRoutine = False
                if not drink_amount_12mo_1glass.wasClicked:
                    # run callback code when drink_amount_12mo_1glass is clicked
                    thisExp.addData('drink_amount_12mo', '1')
        # take note of whether drink_amount_12mo_1glass was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_1glass.wasClicked = drink_amount_12mo_1glass.isClicked and drink_amount_12mo_1glass.status == STARTED
        # *drink_amount_12mo_2glass* updates
        
        # if drink_amount_12mo_2glass is starting this frame...
        if drink_amount_12mo_2glass.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_2glass.frameNStart = frameN  # exact frame index
            drink_amount_12mo_2glass.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_2glass.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_2glass, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_2glass.started')
            # update status
            drink_amount_12mo_2glass.status = STARTED
            win.callOnFlip(drink_amount_12mo_2glass.buttonClock.reset)
            drink_amount_12mo_2glass.setAutoDraw(True)
        
        # if drink_amount_12mo_2glass is active this frame...
        if drink_amount_12mo_2glass.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_2glass has been pressed
            if drink_amount_12mo_2glass.isClicked:
                if not drink_amount_12mo_2glass.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_2glass.timesOn.append(drink_amount_12mo_2glass.buttonClock.getTime())
                    drink_amount_12mo_2glass.timesOff.append(drink_amount_12mo_2glass.buttonClock.getTime())
                elif len(drink_amount_12mo_2glass.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_2glass.timesOff[-1] = drink_amount_12mo_2glass.buttonClock.getTime()
                if not drink_amount_12mo_2glass.wasClicked:
                    # end routine when drink_amount_12mo_2glass is clicked
                    continueRoutine = False
                if not drink_amount_12mo_2glass.wasClicked:
                    # run callback code when drink_amount_12mo_2glass is clicked
                    thisExp.addData('drink_amount_12mo', '2')
        # take note of whether drink_amount_12mo_2glass was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_2glass.wasClicked = drink_amount_12mo_2glass.isClicked and drink_amount_12mo_2glass.status == STARTED
        # *drink_amount_12mo_3glasses* updates
        
        # if drink_amount_12mo_3glasses is starting this frame...
        if drink_amount_12mo_3glasses.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_3glasses.frameNStart = frameN  # exact frame index
            drink_amount_12mo_3glasses.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_3glasses.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_3glasses, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_3glasses.started')
            # update status
            drink_amount_12mo_3glasses.status = STARTED
            win.callOnFlip(drink_amount_12mo_3glasses.buttonClock.reset)
            drink_amount_12mo_3glasses.setAutoDraw(True)
        
        # if drink_amount_12mo_3glasses is active this frame...
        if drink_amount_12mo_3glasses.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_3glasses has been pressed
            if drink_amount_12mo_3glasses.isClicked:
                if not drink_amount_12mo_3glasses.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_3glasses.timesOn.append(drink_amount_12mo_3glasses.buttonClock.getTime())
                    drink_amount_12mo_3glasses.timesOff.append(drink_amount_12mo_3glasses.buttonClock.getTime())
                elif len(drink_amount_12mo_3glasses.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_3glasses.timesOff[-1] = drink_amount_12mo_3glasses.buttonClock.getTime()
                if not drink_amount_12mo_3glasses.wasClicked:
                    # end routine when drink_amount_12mo_3glasses is clicked
                    continueRoutine = False
                if not drink_amount_12mo_3glasses.wasClicked:
                    # run callback code when drink_amount_12mo_3glasses is clicked
                    thisExp.addData('drink_amount_12mo', '3')
        # take note of whether drink_amount_12mo_3glasses was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_3glasses.wasClicked = drink_amount_12mo_3glasses.isClicked and drink_amount_12mo_3glasses.status == STARTED
        # *drink_amount_12mo_4glasses* updates
        
        # if drink_amount_12mo_4glasses is starting this frame...
        if drink_amount_12mo_4glasses.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_4glasses.frameNStart = frameN  # exact frame index
            drink_amount_12mo_4glasses.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_4glasses.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_4glasses, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_4glasses.started')
            # update status
            drink_amount_12mo_4glasses.status = STARTED
            win.callOnFlip(drink_amount_12mo_4glasses.buttonClock.reset)
            drink_amount_12mo_4glasses.setAutoDraw(True)
        
        # if drink_amount_12mo_4glasses is active this frame...
        if drink_amount_12mo_4glasses.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_4glasses has been pressed
            if drink_amount_12mo_4glasses.isClicked:
                if not drink_amount_12mo_4glasses.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_4glasses.timesOn.append(drink_amount_12mo_4glasses.buttonClock.getTime())
                    drink_amount_12mo_4glasses.timesOff.append(drink_amount_12mo_4glasses.buttonClock.getTime())
                elif len(drink_amount_12mo_4glasses.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_4glasses.timesOff[-1] = drink_amount_12mo_4glasses.buttonClock.getTime()
                if not drink_amount_12mo_4glasses.wasClicked:
                    # end routine when drink_amount_12mo_4glasses is clicked
                    continueRoutine = False
                if not drink_amount_12mo_4glasses.wasClicked:
                    # run callback code when drink_amount_12mo_4glasses is clicked
                    thisExp.addData('drink_amount_12mo', '4')
        # take note of whether drink_amount_12mo_4glasses was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_4glasses.wasClicked = drink_amount_12mo_4glasses.isClicked and drink_amount_12mo_4glasses.status == STARTED
        # *drink_amount_12mo_5glassesmore* updates
        
        # if drink_amount_12mo_5glassesmore is starting this frame...
        if drink_amount_12mo_5glassesmore.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            drink_amount_12mo_5glassesmore.frameNStart = frameN  # exact frame index
            drink_amount_12mo_5glassesmore.tStart = t  # local t and not account for scr refresh
            drink_amount_12mo_5glassesmore.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(drink_amount_12mo_5glassesmore, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink_amount_12mo_5glassesmore.started')
            # update status
            drink_amount_12mo_5glassesmore.status = STARTED
            win.callOnFlip(drink_amount_12mo_5glassesmore.buttonClock.reset)
            drink_amount_12mo_5glassesmore.setAutoDraw(True)
        
        # if drink_amount_12mo_5glassesmore is active this frame...
        if drink_amount_12mo_5glassesmore.status == STARTED:
            # update params
            pass
            # check whether drink_amount_12mo_5glassesmore has been pressed
            if drink_amount_12mo_5glassesmore.isClicked:
                if not drink_amount_12mo_5glassesmore.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    drink_amount_12mo_5glassesmore.timesOn.append(drink_amount_12mo_5glassesmore.buttonClock.getTime())
                    drink_amount_12mo_5glassesmore.timesOff.append(drink_amount_12mo_5glassesmore.buttonClock.getTime())
                elif len(drink_amount_12mo_5glassesmore.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    drink_amount_12mo_5glassesmore.timesOff[-1] = drink_amount_12mo_5glassesmore.buttonClock.getTime()
                if not drink_amount_12mo_5glassesmore.wasClicked:
                    # end routine when drink_amount_12mo_5glassesmore is clicked
                    continueRoutine = False
                if not drink_amount_12mo_5glassesmore.wasClicked:
                    # run callback code when drink_amount_12mo_5glassesmore is clicked
                    thisExp.addData('drink_amount_12mo', '4')
        # take note of whether drink_amount_12mo_5glassesmore was clicked, so that next frame we know if clicks are new
        drink_amount_12mo_5glassesmore.wasClicked = drink_amount_12mo_5glassesmore.isClicked and drink_amount_12mo_5glassesmore.status == STARTED
        
        # *Q17* updates
        
        # if Q17 is starting this frame...
        if Q17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q17.frameNStart = frameN  # exact frame index
            Q17.tStart = t  # local t and not account for scr refresh
            Q17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q17, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q17.started')
            # update status
            Q17.status = STARTED
            Q17.setAutoDraw(True)
        
        # if Q17 is active this frame...
        if Q17.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=drink_amount_12mo,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            drink_amount_12mo.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in drink_amount_12mo.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "drink_amount_12mo" ---
    for thisComponent in drink_amount_12mo.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for drink_amount_12mo
    drink_amount_12mo.tStop = globalClock.getTime(format='float')
    drink_amount_12mo.tStopRefresh = tThisFlipGlobal
    thisExp.addData('drink_amount_12mo.stopped', drink_amount_12mo.tStop)
    thisExp.addData('drink_amount_12mo_0glass.numClicks', drink_amount_12mo_0glass.numClicks)
    if drink_amount_12mo_0glass.numClicks:
       thisExp.addData('drink_amount_12mo_0glass.timesOn', drink_amount_12mo_0glass.timesOn)
       thisExp.addData('drink_amount_12mo_0glass.timesOff', drink_amount_12mo_0glass.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_0glass.timesOn', "")
       thisExp.addData('drink_amount_12mo_0glass.timesOff', "")
    thisExp.addData('drink_amount_12mo_1glass.numClicks', drink_amount_12mo_1glass.numClicks)
    if drink_amount_12mo_1glass.numClicks:
       thisExp.addData('drink_amount_12mo_1glass.timesOn', drink_amount_12mo_1glass.timesOn)
       thisExp.addData('drink_amount_12mo_1glass.timesOff', drink_amount_12mo_1glass.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_1glass.timesOn', "")
       thisExp.addData('drink_amount_12mo_1glass.timesOff', "")
    thisExp.addData('drink_amount_12mo_2glass.numClicks', drink_amount_12mo_2glass.numClicks)
    if drink_amount_12mo_2glass.numClicks:
       thisExp.addData('drink_amount_12mo_2glass.timesOn', drink_amount_12mo_2glass.timesOn)
       thisExp.addData('drink_amount_12mo_2glass.timesOff', drink_amount_12mo_2glass.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_2glass.timesOn', "")
       thisExp.addData('drink_amount_12mo_2glass.timesOff', "")
    thisExp.addData('drink_amount_12mo_3glasses.numClicks', drink_amount_12mo_3glasses.numClicks)
    if drink_amount_12mo_3glasses.numClicks:
       thisExp.addData('drink_amount_12mo_3glasses.timesOn', drink_amount_12mo_3glasses.timesOn)
       thisExp.addData('drink_amount_12mo_3glasses.timesOff', drink_amount_12mo_3glasses.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_3glasses.timesOn', "")
       thisExp.addData('drink_amount_12mo_3glasses.timesOff', "")
    thisExp.addData('drink_amount_12mo_4glasses.numClicks', drink_amount_12mo_4glasses.numClicks)
    if drink_amount_12mo_4glasses.numClicks:
       thisExp.addData('drink_amount_12mo_4glasses.timesOn', drink_amount_12mo_4glasses.timesOn)
       thisExp.addData('drink_amount_12mo_4glasses.timesOff', drink_amount_12mo_4glasses.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_4glasses.timesOn', "")
       thisExp.addData('drink_amount_12mo_4glasses.timesOff', "")
    thisExp.addData('drink_amount_12mo_5glassesmore.numClicks', drink_amount_12mo_5glassesmore.numClicks)
    if drink_amount_12mo_5glassesmore.numClicks:
       thisExp.addData('drink_amount_12mo_5glassesmore.timesOn', drink_amount_12mo_5glassesmore.timesOn)
       thisExp.addData('drink_amount_12mo_5glassesmore.timesOff', drink_amount_12mo_5glassesmore.timesOff)
    else:
       thisExp.addData('drink_amount_12mo_5glassesmore.timesOn', "")
       thisExp.addData('drink_amount_12mo_5glassesmore.timesOff', "")
    thisExp.nextEntry()
    # the Routine "drink_amount_12mo" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ever_smoke" ---
    # create an object to store info about Routine ever_smoke
    ever_smoke = data.Routine(
        name='ever_smoke',
        components=[Q_ever_smoke, ever_smoke_yes, ever_smoke_no, Q18],
    )
    ever_smoke.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset ever_smoke_yes to account for continued clicks & clear times on/off
    ever_smoke_yes.reset()
    # reset ever_smoke_no to account for continued clicks & clear times on/off
    ever_smoke_no.reset()
    # store start times for ever_smoke
    ever_smoke.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ever_smoke.tStart = globalClock.getTime(format='float')
    ever_smoke.status = STARTED
    thisExp.addData('ever_smoke.started', ever_smoke.tStart)
    ever_smoke.maxDuration = None
    # keep track of which components have finished
    ever_smokeComponents = ever_smoke.components
    for thisComponent in ever_smoke.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ever_smoke" ---
    ever_smoke.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_ever_smoke* updates
        
        # if Q_ever_smoke is starting this frame...
        if Q_ever_smoke.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_ever_smoke.frameNStart = frameN  # exact frame index
            Q_ever_smoke.tStart = t  # local t and not account for scr refresh
            Q_ever_smoke.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_ever_smoke, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_ever_smoke.started')
            # update status
            Q_ever_smoke.status = STARTED
            Q_ever_smoke.setAutoDraw(True)
        
        # if Q_ever_smoke is active this frame...
        if Q_ever_smoke.status == STARTED:
            # update params
            pass
        # *ever_smoke_yes* updates
        
        # if ever_smoke_yes is starting this frame...
        if ever_smoke_yes.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ever_smoke_yes.frameNStart = frameN  # exact frame index
            ever_smoke_yes.tStart = t  # local t and not account for scr refresh
            ever_smoke_yes.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ever_smoke_yes, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ever_smoke_yes.started')
            # update status
            ever_smoke_yes.status = STARTED
            win.callOnFlip(ever_smoke_yes.buttonClock.reset)
            ever_smoke_yes.setAutoDraw(True)
        
        # if ever_smoke_yes is active this frame...
        if ever_smoke_yes.status == STARTED:
            # update params
            pass
            # check whether ever_smoke_yes has been pressed
            if ever_smoke_yes.isClicked:
                if not ever_smoke_yes.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ever_smoke_yes.timesOn.append(ever_smoke_yes.buttonClock.getTime())
                    ever_smoke_yes.timesOff.append(ever_smoke_yes.buttonClock.getTime())
                elif len(ever_smoke_yes.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ever_smoke_yes.timesOff[-1] = ever_smoke_yes.buttonClock.getTime()
                if not ever_smoke_yes.wasClicked:
                    # end routine when ever_smoke_yes is clicked
                    continueRoutine = False
                if not ever_smoke_yes.wasClicked:
                    # run callback code when ever_smoke_yes is clicked
                    thisExp.addData('ever_smoke', '1')
        # take note of whether ever_smoke_yes was clicked, so that next frame we know if clicks are new
        ever_smoke_yes.wasClicked = ever_smoke_yes.isClicked and ever_smoke_yes.status == STARTED
        # *ever_smoke_no* updates
        
        # if ever_smoke_no is starting this frame...
        if ever_smoke_no.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            ever_smoke_no.frameNStart = frameN  # exact frame index
            ever_smoke_no.tStart = t  # local t and not account for scr refresh
            ever_smoke_no.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ever_smoke_no, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ever_smoke_no.started')
            # update status
            ever_smoke_no.status = STARTED
            win.callOnFlip(ever_smoke_no.buttonClock.reset)
            ever_smoke_no.setAutoDraw(True)
        
        # if ever_smoke_no is active this frame...
        if ever_smoke_no.status == STARTED:
            # update params
            pass
            # check whether ever_smoke_no has been pressed
            if ever_smoke_no.isClicked:
                if not ever_smoke_no.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    ever_smoke_no.timesOn.append(ever_smoke_no.buttonClock.getTime())
                    ever_smoke_no.timesOff.append(ever_smoke_no.buttonClock.getTime())
                elif len(ever_smoke_no.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    ever_smoke_no.timesOff[-1] = ever_smoke_no.buttonClock.getTime()
                if not ever_smoke_no.wasClicked:
                    # end routine when ever_smoke_no is clicked
                    continueRoutine = False
                if not ever_smoke_no.wasClicked:
                    # run callback code when ever_smoke_no is clicked
                    thisExp.addData('ever_smoke', '2')
        # take note of whether ever_smoke_no was clicked, so that next frame we know if clicks are new
        ever_smoke_no.wasClicked = ever_smoke_no.isClicked and ever_smoke_no.status == STARTED
        
        # *Q18* updates
        
        # if Q18 is starting this frame...
        if Q18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q18.frameNStart = frameN  # exact frame index
            Q18.tStart = t  # local t and not account for scr refresh
            Q18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q18, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q18.started')
            # update status
            Q18.status = STARTED
            Q18.setAutoDraw(True)
        
        # if Q18 is active this frame...
        if Q18.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=ever_smoke,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ever_smoke.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ever_smoke.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ever_smoke" ---
    for thisComponent in ever_smoke.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ever_smoke
    ever_smoke.tStop = globalClock.getTime(format='float')
    ever_smoke.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ever_smoke.stopped', ever_smoke.tStop)
    thisExp.addData('ever_smoke_yes.numClicks', ever_smoke_yes.numClicks)
    if ever_smoke_yes.numClicks:
       thisExp.addData('ever_smoke_yes.timesOn', ever_smoke_yes.timesOn)
       thisExp.addData('ever_smoke_yes.timesOff', ever_smoke_yes.timesOff)
    else:
       thisExp.addData('ever_smoke_yes.timesOn', "")
       thisExp.addData('ever_smoke_yes.timesOff', "")
    thisExp.addData('ever_smoke_no.numClicks', ever_smoke_no.numClicks)
    if ever_smoke_no.numClicks:
       thisExp.addData('ever_smoke_no.timesOn', ever_smoke_no.timesOn)
       thisExp.addData('ever_smoke_no.timesOff', ever_smoke_no.timesOff)
    else:
       thisExp.addData('ever_smoke_no.timesOn', "")
       thisExp.addData('ever_smoke_no.timesOff', "")
    thisExp.nextEntry()
    # the Routine "ever_smoke" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "start_smoke_age" ---
    # create an object to store info about Routine start_smoke_age
    start_smoke_age = data.Routine(
        name='start_smoke_age',
        components=[Q_start_smoke_age, textbox_start_smoke_age, Q19, hit_star_smoke_age],
    )
    start_smoke_age.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_start_smoke_age.reset()
    # store start times for start_smoke_age
    start_smoke_age.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    start_smoke_age.tStart = globalClock.getTime(format='float')
    start_smoke_age.status = STARTED
    thisExp.addData('start_smoke_age.started', start_smoke_age.tStart)
    start_smoke_age.maxDuration = None
    # keep track of which components have finished
    start_smoke_ageComponents = start_smoke_age.components
    for thisComponent in start_smoke_age.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "start_smoke_age" ---
    start_smoke_age.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_start_smoke_age* updates
        
        # if Q_start_smoke_age is starting this frame...
        if Q_start_smoke_age.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_start_smoke_age.frameNStart = frameN  # exact frame index
            Q_start_smoke_age.tStart = t  # local t and not account for scr refresh
            Q_start_smoke_age.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_start_smoke_age, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_start_smoke_age.started')
            # update status
            Q_start_smoke_age.status = STARTED
            Q_start_smoke_age.setAutoDraw(True)
        
        # if Q_start_smoke_age is active this frame...
        if Q_start_smoke_age.status == STARTED:
            # update params
            pass
        
        # *textbox_start_smoke_age* updates
        
        # if textbox_start_smoke_age is starting this frame...
        if textbox_start_smoke_age.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_start_smoke_age.frameNStart = frameN  # exact frame index
            textbox_start_smoke_age.tStart = t  # local t and not account for scr refresh
            textbox_start_smoke_age.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_start_smoke_age, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_start_smoke_age.started')
            # update status
            textbox_start_smoke_age.status = STARTED
            textbox_start_smoke_age.setAutoDraw(True)
        
        # if textbox_start_smoke_age is active this frame...
        if textbox_start_smoke_age.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_7
        if not hasattr(thisExp, 'allow_advance_start_smoke_age'):
            thisExp.allow_advance_start_smoke_age = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_start_smoke_age.text.strip()
            if user_input != '':
                thisExp.allow_advance_start_smoke_age = True
        
        if thisExp.allow_advance_start_smoke_age:
            continueRoutine = False
        
        
        # *Q19* updates
        
        # if Q19 is starting this frame...
        if Q19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q19.frameNStart = frameN  # exact frame index
            Q19.tStart = t  # local t and not account for scr refresh
            Q19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q19, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q19.started')
            # update status
            Q19.status = STARTED
            Q19.setAutoDraw(True)
        
        # if Q19 is active this frame...
        if Q19.status == STARTED:
            # update params
            pass
        
        # *hit_star_smoke_age* updates
        
        # if hit_star_smoke_age is starting this frame...
        if hit_star_smoke_age.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            hit_star_smoke_age.frameNStart = frameN  # exact frame index
            hit_star_smoke_age.tStart = t  # local t and not account for scr refresh
            hit_star_smoke_age.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(hit_star_smoke_age, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'hit_star_smoke_age.started')
            # update status
            hit_star_smoke_age.status = STARTED
            hit_star_smoke_age.setAutoDraw(True)
        
        # if hit_star_smoke_age is active this frame...
        if hit_star_smoke_age.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=start_smoke_age,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            start_smoke_age.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_smoke_age.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "start_smoke_age" ---
    for thisComponent in start_smoke_age.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for start_smoke_age
    start_smoke_age.tStop = globalClock.getTime(format='float')
    start_smoke_age.tStopRefresh = tThisFlipGlobal
    thisExp.addData('start_smoke_age.stopped', start_smoke_age.tStop)
    thisExp.addData('textbox_start_smoke_age.text',textbox_start_smoke_age.text)
    # Run 'End Routine' code from code_7
    thisExp.addData('start_smoke_age', textbox_start_smoke_age.text)
    
    thisExp.nextEntry()
    # the Routine "start_smoke_age" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "cigs_per_day" ---
    # create an object to store info about Routine cigs_per_day
    cigs_per_day = data.Routine(
        name='cigs_per_day',
        components=[Q_cigs_per_day, textbox_cigs_per_day, Q20, hit_cigs],
    )
    cigs_per_day.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_cigs_per_day.reset()
    # store start times for cigs_per_day
    cigs_per_day.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    cigs_per_day.tStart = globalClock.getTime(format='float')
    cigs_per_day.status = STARTED
    thisExp.addData('cigs_per_day.started', cigs_per_day.tStart)
    cigs_per_day.maxDuration = None
    # keep track of which components have finished
    cigs_per_dayComponents = cigs_per_day.components
    for thisComponent in cigs_per_day.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "cigs_per_day" ---
    cigs_per_day.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_cigs_per_day* updates
        
        # if Q_cigs_per_day is starting this frame...
        if Q_cigs_per_day.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_cigs_per_day.frameNStart = frameN  # exact frame index
            Q_cigs_per_day.tStart = t  # local t and not account for scr refresh
            Q_cigs_per_day.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_cigs_per_day, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_cigs_per_day.started')
            # update status
            Q_cigs_per_day.status = STARTED
            Q_cigs_per_day.setAutoDraw(True)
        
        # if Q_cigs_per_day is active this frame...
        if Q_cigs_per_day.status == STARTED:
            # update params
            pass
        
        # *textbox_cigs_per_day* updates
        
        # if textbox_cigs_per_day is starting this frame...
        if textbox_cigs_per_day.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_cigs_per_day.frameNStart = frameN  # exact frame index
            textbox_cigs_per_day.tStart = t  # local t and not account for scr refresh
            textbox_cigs_per_day.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_cigs_per_day, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_cigs_per_day.started')
            # update status
            textbox_cigs_per_day.status = STARTED
            textbox_cigs_per_day.setAutoDraw(True)
        
        # if textbox_cigs_per_day is active this frame...
        if textbox_cigs_per_day.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_8
        if not hasattr(thisExp, 'allow_advance_cigs_per_day'):
            thisExp.allow_advance_cigs_per_day = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_cigs_per_day.text.strip()
            if user_input != '':
                thisExp.allow_advance_cigs_per_day = True
        
        if thisExp.allow_advance_cigs_per_day:
            continueRoutine = False
        
        
        # *Q20* updates
        
        # if Q20 is starting this frame...
        if Q20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q20.frameNStart = frameN  # exact frame index
            Q20.tStart = t  # local t and not account for scr refresh
            Q20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q20, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q20.started')
            # update status
            Q20.status = STARTED
            Q20.setAutoDraw(True)
        
        # if Q20 is active this frame...
        if Q20.status == STARTED:
            # update params
            pass
        
        # *hit_cigs* updates
        
        # if hit_cigs is starting this frame...
        if hit_cigs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            hit_cigs.frameNStart = frameN  # exact frame index
            hit_cigs.tStart = t  # local t and not account for scr refresh
            hit_cigs.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(hit_cigs, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'hit_cigs.started')
            # update status
            hit_cigs.status = STARTED
            hit_cigs.setAutoDraw(True)
        
        # if hit_cigs is active this frame...
        if hit_cigs.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=cigs_per_day,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            cigs_per_day.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in cigs_per_day.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "cigs_per_day" ---
    for thisComponent in cigs_per_day.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for cigs_per_day
    cigs_per_day.tStop = globalClock.getTime(format='float')
    cigs_per_day.tStopRefresh = tThisFlipGlobal
    thisExp.addData('cigs_per_day.stopped', cigs_per_day.tStop)
    thisExp.addData('textbox_cigs_per_day.text',textbox_cigs_per_day.text)
    # Run 'End Routine' code from code_8
    thisExp.addData('cigs_per_day', textbox_cigs_per_day.text)
    
    thisExp.nextEntry()
    # the Routine "cigs_per_day" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "self_health_status" ---
    # create an object to store info about Routine self_health_status
    self_health_status = data.Routine(
        name='self_health_status',
        components=[Q_self_health_status, self_health_status_Verygood, self_health_status_Good, self_health_status_Average, self_health_status_Poor, self_health_status_Verypoor, Q21],
    )
    self_health_status.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset self_health_status_Verygood to account for continued clicks & clear times on/off
    self_health_status_Verygood.reset()
    # reset self_health_status_Good to account for continued clicks & clear times on/off
    self_health_status_Good.reset()
    # reset self_health_status_Average to account for continued clicks & clear times on/off
    self_health_status_Average.reset()
    # reset self_health_status_Poor to account for continued clicks & clear times on/off
    self_health_status_Poor.reset()
    # reset self_health_status_Verypoor to account for continued clicks & clear times on/off
    self_health_status_Verypoor.reset()
    # store start times for self_health_status
    self_health_status.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    self_health_status.tStart = globalClock.getTime(format='float')
    self_health_status.status = STARTED
    thisExp.addData('self_health_status.started', self_health_status.tStart)
    self_health_status.maxDuration = None
    # keep track of which components have finished
    self_health_statusComponents = self_health_status.components
    for thisComponent in self_health_status.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "self_health_status" ---
    self_health_status.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_self_health_status* updates
        
        # if Q_self_health_status is starting this frame...
        if Q_self_health_status.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_self_health_status.frameNStart = frameN  # exact frame index
            Q_self_health_status.tStart = t  # local t and not account for scr refresh
            Q_self_health_status.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_self_health_status, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_self_health_status.started')
            # update status
            Q_self_health_status.status = STARTED
            Q_self_health_status.setAutoDraw(True)
        
        # if Q_self_health_status is active this frame...
        if Q_self_health_status.status == STARTED:
            # update params
            pass
        # *self_health_status_Verygood* updates
        
        # if self_health_status_Verygood is starting this frame...
        if self_health_status_Verygood.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            self_health_status_Verygood.frameNStart = frameN  # exact frame index
            self_health_status_Verygood.tStart = t  # local t and not account for scr refresh
            self_health_status_Verygood.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(self_health_status_Verygood, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'self_health_status_Verygood.started')
            # update status
            self_health_status_Verygood.status = STARTED
            win.callOnFlip(self_health_status_Verygood.buttonClock.reset)
            self_health_status_Verygood.setAutoDraw(True)
        
        # if self_health_status_Verygood is active this frame...
        if self_health_status_Verygood.status == STARTED:
            # update params
            pass
            # check whether self_health_status_Verygood has been pressed
            if self_health_status_Verygood.isClicked:
                if not self_health_status_Verygood.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    self_health_status_Verygood.timesOn.append(self_health_status_Verygood.buttonClock.getTime())
                    self_health_status_Verygood.timesOff.append(self_health_status_Verygood.buttonClock.getTime())
                elif len(self_health_status_Verygood.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    self_health_status_Verygood.timesOff[-1] = self_health_status_Verygood.buttonClock.getTime()
                if not self_health_status_Verygood.wasClicked:
                    # end routine when self_health_status_Verygood is clicked
                    continueRoutine = False
                if not self_health_status_Verygood.wasClicked:
                    # run callback code when self_health_status_Verygood is clicked
                    thisExp.addData('self_health_status', '1')
        # take note of whether self_health_status_Verygood was clicked, so that next frame we know if clicks are new
        self_health_status_Verygood.wasClicked = self_health_status_Verygood.isClicked and self_health_status_Verygood.status == STARTED
        # *self_health_status_Good* updates
        
        # if self_health_status_Good is starting this frame...
        if self_health_status_Good.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            self_health_status_Good.frameNStart = frameN  # exact frame index
            self_health_status_Good.tStart = t  # local t and not account for scr refresh
            self_health_status_Good.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(self_health_status_Good, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'self_health_status_Good.started')
            # update status
            self_health_status_Good.status = STARTED
            win.callOnFlip(self_health_status_Good.buttonClock.reset)
            self_health_status_Good.setAutoDraw(True)
        
        # if self_health_status_Good is active this frame...
        if self_health_status_Good.status == STARTED:
            # update params
            pass
            # check whether self_health_status_Good has been pressed
            if self_health_status_Good.isClicked:
                if not self_health_status_Good.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    self_health_status_Good.timesOn.append(self_health_status_Good.buttonClock.getTime())
                    self_health_status_Good.timesOff.append(self_health_status_Good.buttonClock.getTime())
                elif len(self_health_status_Good.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    self_health_status_Good.timesOff[-1] = self_health_status_Good.buttonClock.getTime()
                if not self_health_status_Good.wasClicked:
                    # end routine when self_health_status_Good is clicked
                    continueRoutine = False
                if not self_health_status_Good.wasClicked:
                    # run callback code when self_health_status_Good is clicked
                    thisExp.addData('self_health_status', '2')
        # take note of whether self_health_status_Good was clicked, so that next frame we know if clicks are new
        self_health_status_Good.wasClicked = self_health_status_Good.isClicked and self_health_status_Good.status == STARTED
        # *self_health_status_Average* updates
        
        # if self_health_status_Average is starting this frame...
        if self_health_status_Average.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            self_health_status_Average.frameNStart = frameN  # exact frame index
            self_health_status_Average.tStart = t  # local t and not account for scr refresh
            self_health_status_Average.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(self_health_status_Average, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'self_health_status_Average.started')
            # update status
            self_health_status_Average.status = STARTED
            win.callOnFlip(self_health_status_Average.buttonClock.reset)
            self_health_status_Average.setAutoDraw(True)
        
        # if self_health_status_Average is active this frame...
        if self_health_status_Average.status == STARTED:
            # update params
            pass
            # check whether self_health_status_Average has been pressed
            if self_health_status_Average.isClicked:
                if not self_health_status_Average.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    self_health_status_Average.timesOn.append(self_health_status_Average.buttonClock.getTime())
                    self_health_status_Average.timesOff.append(self_health_status_Average.buttonClock.getTime())
                elif len(self_health_status_Average.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    self_health_status_Average.timesOff[-1] = self_health_status_Average.buttonClock.getTime()
                if not self_health_status_Average.wasClicked:
                    # end routine when self_health_status_Average is clicked
                    continueRoutine = False
                if not self_health_status_Average.wasClicked:
                    # run callback code when self_health_status_Average is clicked
                    thisExp.addData('self_health_status', '3')
        # take note of whether self_health_status_Average was clicked, so that next frame we know if clicks are new
        self_health_status_Average.wasClicked = self_health_status_Average.isClicked and self_health_status_Average.status == STARTED
        # *self_health_status_Poor* updates
        
        # if self_health_status_Poor is starting this frame...
        if self_health_status_Poor.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            self_health_status_Poor.frameNStart = frameN  # exact frame index
            self_health_status_Poor.tStart = t  # local t and not account for scr refresh
            self_health_status_Poor.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(self_health_status_Poor, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'self_health_status_Poor.started')
            # update status
            self_health_status_Poor.status = STARTED
            win.callOnFlip(self_health_status_Poor.buttonClock.reset)
            self_health_status_Poor.setAutoDraw(True)
        
        # if self_health_status_Poor is active this frame...
        if self_health_status_Poor.status == STARTED:
            # update params
            pass
            # check whether self_health_status_Poor has been pressed
            if self_health_status_Poor.isClicked:
                if not self_health_status_Poor.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    self_health_status_Poor.timesOn.append(self_health_status_Poor.buttonClock.getTime())
                    self_health_status_Poor.timesOff.append(self_health_status_Poor.buttonClock.getTime())
                elif len(self_health_status_Poor.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    self_health_status_Poor.timesOff[-1] = self_health_status_Poor.buttonClock.getTime()
                if not self_health_status_Poor.wasClicked:
                    # end routine when self_health_status_Poor is clicked
                    continueRoutine = False
                if not self_health_status_Poor.wasClicked:
                    # run callback code when self_health_status_Poor is clicked
                    thisExp.addData('self_health_status', '4')
        # take note of whether self_health_status_Poor was clicked, so that next frame we know if clicks are new
        self_health_status_Poor.wasClicked = self_health_status_Poor.isClicked and self_health_status_Poor.status == STARTED
        # *self_health_status_Verypoor* updates
        
        # if self_health_status_Verypoor is starting this frame...
        if self_health_status_Verypoor.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            self_health_status_Verypoor.frameNStart = frameN  # exact frame index
            self_health_status_Verypoor.tStart = t  # local t and not account for scr refresh
            self_health_status_Verypoor.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(self_health_status_Verypoor, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'self_health_status_Verypoor.started')
            # update status
            self_health_status_Verypoor.status = STARTED
            win.callOnFlip(self_health_status_Verypoor.buttonClock.reset)
            self_health_status_Verypoor.setAutoDraw(True)
        
        # if self_health_status_Verypoor is active this frame...
        if self_health_status_Verypoor.status == STARTED:
            # update params
            pass
            # check whether self_health_status_Verypoor has been pressed
            if self_health_status_Verypoor.isClicked:
                if not self_health_status_Verypoor.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    self_health_status_Verypoor.timesOn.append(self_health_status_Verypoor.buttonClock.getTime())
                    self_health_status_Verypoor.timesOff.append(self_health_status_Verypoor.buttonClock.getTime())
                elif len(self_health_status_Verypoor.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    self_health_status_Verypoor.timesOff[-1] = self_health_status_Verypoor.buttonClock.getTime()
                if not self_health_status_Verypoor.wasClicked:
                    # end routine when self_health_status_Verypoor is clicked
                    continueRoutine = False
                if not self_health_status_Verypoor.wasClicked:
                    # run callback code when self_health_status_Verypoor is clicked
                    thisExp.addData('self_health_status', '4')
        # take note of whether self_health_status_Verypoor was clicked, so that next frame we know if clicks are new
        self_health_status_Verypoor.wasClicked = self_health_status_Verypoor.isClicked and self_health_status_Verypoor.status == STARTED
        
        # *Q21* updates
        
        # if Q21 is starting this frame...
        if Q21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q21.frameNStart = frameN  # exact frame index
            Q21.tStart = t  # local t and not account for scr refresh
            Q21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q21, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q21.started')
            # update status
            Q21.status = STARTED
            Q21.setAutoDraw(True)
        
        # if Q21 is active this frame...
        if Q21.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=self_health_status,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            self_health_status.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in self_health_status.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "self_health_status" ---
    for thisComponent in self_health_status.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for self_health_status
    self_health_status.tStop = globalClock.getTime(format='float')
    self_health_status.tStopRefresh = tThisFlipGlobal
    thisExp.addData('self_health_status.stopped', self_health_status.tStop)
    thisExp.addData('self_health_status_Verygood.numClicks', self_health_status_Verygood.numClicks)
    if self_health_status_Verygood.numClicks:
       thisExp.addData('self_health_status_Verygood.timesOn', self_health_status_Verygood.timesOn)
       thisExp.addData('self_health_status_Verygood.timesOff', self_health_status_Verygood.timesOff)
    else:
       thisExp.addData('self_health_status_Verygood.timesOn', "")
       thisExp.addData('self_health_status_Verygood.timesOff', "")
    thisExp.addData('self_health_status_Good.numClicks', self_health_status_Good.numClicks)
    if self_health_status_Good.numClicks:
       thisExp.addData('self_health_status_Good.timesOn', self_health_status_Good.timesOn)
       thisExp.addData('self_health_status_Good.timesOff', self_health_status_Good.timesOff)
    else:
       thisExp.addData('self_health_status_Good.timesOn', "")
       thisExp.addData('self_health_status_Good.timesOff', "")
    thisExp.addData('self_health_status_Average.numClicks', self_health_status_Average.numClicks)
    if self_health_status_Average.numClicks:
       thisExp.addData('self_health_status_Average.timesOn', self_health_status_Average.timesOn)
       thisExp.addData('self_health_status_Average.timesOff', self_health_status_Average.timesOff)
    else:
       thisExp.addData('self_health_status_Average.timesOn', "")
       thisExp.addData('self_health_status_Average.timesOff', "")
    thisExp.addData('self_health_status_Poor.numClicks', self_health_status_Poor.numClicks)
    if self_health_status_Poor.numClicks:
       thisExp.addData('self_health_status_Poor.timesOn', self_health_status_Poor.timesOn)
       thisExp.addData('self_health_status_Poor.timesOff', self_health_status_Poor.timesOff)
    else:
       thisExp.addData('self_health_status_Poor.timesOn', "")
       thisExp.addData('self_health_status_Poor.timesOff', "")
    thisExp.addData('self_health_status_Verypoor.numClicks', self_health_status_Verypoor.numClicks)
    if self_health_status_Verypoor.numClicks:
       thisExp.addData('self_health_status_Verypoor.timesOn', self_health_status_Verypoor.timesOn)
       thisExp.addData('self_health_status_Verypoor.timesOff', self_health_status_Verypoor.timesOff)
    else:
       thisExp.addData('self_health_status_Verypoor.timesOn', "")
       thisExp.addData('self_health_status_Verypoor.timesOff', "")
    thisExp.nextEntry()
    # the Routine "self_health_status" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PHQ9_intro" ---
    # create an object to store info about Routine PHQ9_intro
    PHQ9_intro = data.Routine(
        name='PHQ9_intro',
        components=[PHQ9_intro_image, key_resp_4],
    )
    PHQ9_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_4
    key_resp_4.keys = []
    key_resp_4.rt = []
    _key_resp_4_allKeys = []
    # store start times for PHQ9_intro
    PHQ9_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    PHQ9_intro.tStart = globalClock.getTime(format='float')
    PHQ9_intro.status = STARTED
    thisExp.addData('PHQ9_intro.started', PHQ9_intro.tStart)
    PHQ9_intro.maxDuration = None
    # keep track of which components have finished
    PHQ9_introComponents = PHQ9_intro.components
    for thisComponent in PHQ9_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PHQ9_intro" ---
    PHQ9_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *PHQ9_intro_image* updates
        
        # if PHQ9_intro_image is starting this frame...
        if PHQ9_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            PHQ9_intro_image.frameNStart = frameN  # exact frame index
            PHQ9_intro_image.tStart = t  # local t and not account for scr refresh
            PHQ9_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(PHQ9_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'PHQ9_intro_image.started')
            # update status
            PHQ9_intro_image.status = STARTED
            PHQ9_intro_image.setAutoDraw(True)
        
        # if PHQ9_intro_image is active this frame...
        if PHQ9_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_4* updates
        waitOnFlip = False
        
        # if key_resp_4 is starting this frame...
        if key_resp_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_4.frameNStart = frameN  # exact frame index
            key_resp_4.tStart = t  # local t and not account for scr refresh
            key_resp_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_4.started')
            # update status
            key_resp_4.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_4.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_4.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_4.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_4.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_4_allKeys.extend(theseKeys)
            if len(_key_resp_4_allKeys):
                key_resp_4.keys = _key_resp_4_allKeys[-1].name  # just the last key pressed
                key_resp_4.rt = _key_resp_4_allKeys[-1].rt
                key_resp_4.duration = _key_resp_4_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=PHQ9_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            PHQ9_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PHQ9_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PHQ9_intro" ---
    for thisComponent in PHQ9_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for PHQ9_intro
    PHQ9_intro.tStop = globalClock.getTime(format='float')
    PHQ9_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('PHQ9_intro.stopped', PHQ9_intro.tStop)
    # check responses
    if key_resp_4.keys in ['', [], None]:  # No response was made
        key_resp_4.keys = None
    thisExp.addData('key_resp_4.keys',key_resp_4.keys)
    if key_resp_4.keys != None:  # we had a response
        thisExp.addData('key_resp_4.rt', key_resp_4.rt)
        thisExp.addData('key_resp_4.duration', key_resp_4.duration)
    thisExp.nextEntry()
    # the Routine "PHQ9_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_PHQ9 = data.TrialHandler2(
        name='trials_PHQ9',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('PHQ9Qutext.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_PHQ9)  # add the loop to the experiment
    thisTrials_PHQ9 = trials_PHQ9.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_PHQ9.rgb)
    if thisTrials_PHQ9 != None:
        for paramName in thisTrials_PHQ9:
            globals()[paramName] = thisTrials_PHQ9[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_PHQ9 in trials_PHQ9:
        trials_PHQ9.status = STARTED
        if hasattr(thisTrials_PHQ9, 'status'):
            thisTrials_PHQ9.status = STARTED
        currentLoop = trials_PHQ9
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_PHQ9.rgb)
        if thisTrials_PHQ9 != None:
            for paramName in thisTrials_PHQ9:
                globals()[paramName] = thisTrials_PHQ9[paramName]
        
        # --- Prepare to start Routine "PHQ_9" ---
        # create an object to store info about Routine PHQ_9
        PHQ_9 = data.Routine(
            name='PHQ_9',
            components=[PHQ_9QuestionText, PHQ_9questionslide, Q22toQ30],
        )
        PHQ_9.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        PHQ_9QuestionText.setText(PHQ9qText)
        PHQ_9questionslide.reset()
        Q22toQ30.setText(PHQ9qIndex)
        # store start times for PHQ_9
        PHQ_9.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        PHQ_9.tStart = globalClock.getTime(format='float')
        PHQ_9.status = STARTED
        thisExp.addData('PHQ_9.started', PHQ_9.tStart)
        PHQ_9.maxDuration = None
        # keep track of which components have finished
        PHQ_9Components = PHQ_9.components
        for thisComponent in PHQ_9.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "PHQ_9" ---
        PHQ_9.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_PHQ9, 'status') and thisTrials_PHQ9.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *PHQ_9QuestionText* updates
            
            # if PHQ_9QuestionText is starting this frame...
            if PHQ_9QuestionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                PHQ_9QuestionText.frameNStart = frameN  # exact frame index
                PHQ_9QuestionText.tStart = t  # local t and not account for scr refresh
                PHQ_9QuestionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(PHQ_9QuestionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'PHQ_9QuestionText.started')
                # update status
                PHQ_9QuestionText.status = STARTED
                PHQ_9QuestionText.setAutoDraw(True)
            
            # if PHQ_9QuestionText is active this frame...
            if PHQ_9QuestionText.status == STARTED:
                # update params
                pass
            
            # *PHQ_9questionslide* updates
            
            # if PHQ_9questionslide is starting this frame...
            if PHQ_9questionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                PHQ_9questionslide.frameNStart = frameN  # exact frame index
                PHQ_9questionslide.tStart = t  # local t and not account for scr refresh
                PHQ_9questionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(PHQ_9questionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'PHQ_9questionslide.started')
                # update status
                PHQ_9questionslide.status = STARTED
                PHQ_9questionslide.setAutoDraw(True)
            
            # if PHQ_9questionslide is active this frame...
            if PHQ_9questionslide.status == STARTED:
                # update params
                pass
            
            # Check PHQ_9questionslide for response to end Routine
            if PHQ_9questionslide.getRating() is not None and PHQ_9questionslide.status == STARTED:
                continueRoutine = False
            
            # *Q22toQ30* updates
            
            # if Q22toQ30 is starting this frame...
            if Q22toQ30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q22toQ30.frameNStart = frameN  # exact frame index
                Q22toQ30.tStart = t  # local t and not account for scr refresh
                Q22toQ30.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q22toQ30, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q22toQ30.started')
                # update status
                Q22toQ30.status = STARTED
                Q22toQ30.setAutoDraw(True)
            
            # if Q22toQ30 is active this frame...
            if Q22toQ30.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=PHQ_9,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                PHQ_9.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in PHQ_9.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "PHQ_9" ---
        for thisComponent in PHQ_9.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for PHQ_9
        PHQ_9.tStop = globalClock.getTime(format='float')
        PHQ_9.tStopRefresh = tThisFlipGlobal
        thisExp.addData('PHQ_9.stopped', PHQ_9.tStop)
        trials_PHQ9.addData('PHQ_9questionslide.response', PHQ_9questionslide.getRating())
        trials_PHQ9.addData('PHQ_9questionslide.rt', PHQ_9questionslide.getRT())
        # the Routine "PHQ_9" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_PHQ9 as finished
        if hasattr(thisTrials_PHQ9, 'status'):
            thisTrials_PHQ9.status = FINISHED
        # if awaiting a pause, pause now
        if trials_PHQ9.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_PHQ9.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_PHQ9'
    trials_PHQ9.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_PHQ9.trialList in ([], [None], None):
        params = []
    else:
        params = trials_PHQ9.trialList[0].keys()
    # save data for this loop
    trials_PHQ9.saveAsExcel(filename + '.xlsx', sheetName='trials_PHQ9',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_PHQ9.saveAsText(filename + '_trials_PHQ9.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "BPSQI_intro" ---
    # create an object to store info about Routine BPSQI_intro
    BPSQI_intro = data.Routine(
        name='BPSQI_intro',
        components=[BPSQI_intro_image, key_resp_5],
    )
    BPSQI_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_5
    key_resp_5.keys = []
    key_resp_5.rt = []
    _key_resp_5_allKeys = []
    # store start times for BPSQI_intro
    BPSQI_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    BPSQI_intro.tStart = globalClock.getTime(format='float')
    BPSQI_intro.status = STARTED
    thisExp.addData('BPSQI_intro.started', BPSQI_intro.tStart)
    BPSQI_intro.maxDuration = None
    # keep track of which components have finished
    BPSQI_introComponents = BPSQI_intro.components
    for thisComponent in BPSQI_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "BPSQI_intro" ---
    BPSQI_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *BPSQI_intro_image* updates
        
        # if BPSQI_intro_image is starting this frame...
        if BPSQI_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            BPSQI_intro_image.frameNStart = frameN  # exact frame index
            BPSQI_intro_image.tStart = t  # local t and not account for scr refresh
            BPSQI_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(BPSQI_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'BPSQI_intro_image.started')
            # update status
            BPSQI_intro_image.status = STARTED
            BPSQI_intro_image.setAutoDraw(True)
        
        # if BPSQI_intro_image is active this frame...
        if BPSQI_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_5* updates
        waitOnFlip = False
        
        # if key_resp_5 is starting this frame...
        if key_resp_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_5.frameNStart = frameN  # exact frame index
            key_resp_5.tStart = t  # local t and not account for scr refresh
            key_resp_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_5.started')
            # update status
            key_resp_5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_5.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_5.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_5.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_5_allKeys.extend(theseKeys)
            if len(_key_resp_5_allKeys):
                key_resp_5.keys = _key_resp_5_allKeys[-1].name  # just the last key pressed
                key_resp_5.rt = _key_resp_5_allKeys[-1].rt
                key_resp_5.duration = _key_resp_5_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=BPSQI_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            BPSQI_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BPSQI_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "BPSQI_intro" ---
    for thisComponent in BPSQI_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for BPSQI_intro
    BPSQI_intro.tStop = globalClock.getTime(format='float')
    BPSQI_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('BPSQI_intro.stopped', BPSQI_intro.tStop)
    # check responses
    if key_resp_5.keys in ['', [], None]:  # No response was made
        key_resp_5.keys = None
    thisExp.addData('key_resp_5.keys',key_resp_5.keys)
    if key_resp_5.keys != None:  # we had a response
        thisExp.addData('key_resp_5.rt', key_resp_5.rt)
        thisExp.addData('key_resp_5.duration', key_resp_5.duration)
    thisExp.nextEntry()
    # the Routine "BPSQI_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "B_PSQI_Q1_BedTime" ---
    # create an object to store info about Routine B_PSQI_Q1_BedTime
    B_PSQI_Q1_BedTime = data.Routine(
        name='B_PSQI_Q1_BedTime',
        components=[Q1_BedTime, textbox_Q1Bedtime, enter_hint, Q31],
    )
    B_PSQI_Q1_BedTime.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_Q1Bedtime.reset()
    # store start times for B_PSQI_Q1_BedTime
    B_PSQI_Q1_BedTime.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    B_PSQI_Q1_BedTime.tStart = globalClock.getTime(format='float')
    B_PSQI_Q1_BedTime.status = STARTED
    thisExp.addData('B_PSQI_Q1_BedTime.started', B_PSQI_Q1_BedTime.tStart)
    B_PSQI_Q1_BedTime.maxDuration = None
    # keep track of which components have finished
    B_PSQI_Q1_BedTimeComponents = B_PSQI_Q1_BedTime.components
    for thisComponent in B_PSQI_Q1_BedTime.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "B_PSQI_Q1_BedTime" ---
    B_PSQI_Q1_BedTime.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q1_BedTime* updates
        
        # if Q1_BedTime is starting this frame...
        if Q1_BedTime.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q1_BedTime.frameNStart = frameN  # exact frame index
            Q1_BedTime.tStart = t  # local t and not account for scr refresh
            Q1_BedTime.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q1_BedTime, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q1_BedTime.started')
            # update status
            Q1_BedTime.status = STARTED
            Q1_BedTime.setAutoDraw(True)
        
        # if Q1_BedTime is active this frame...
        if Q1_BedTime.status == STARTED:
            # update params
            pass
        
        # *textbox_Q1Bedtime* updates
        
        # if textbox_Q1Bedtime is starting this frame...
        if textbox_Q1Bedtime.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_Q1Bedtime.frameNStart = frameN  # exact frame index
            textbox_Q1Bedtime.tStart = t  # local t and not account for scr refresh
            textbox_Q1Bedtime.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_Q1Bedtime, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_Q1Bedtime.started')
            # update status
            textbox_Q1Bedtime.status = STARTED
            textbox_Q1Bedtime.setAutoDraw(True)
        
        # if textbox_Q1Bedtime is active this frame...
        if textbox_Q1Bedtime.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_Q1Bedtime
        # 每帧检测是否按下回车并验证输入框内容
        if not hasattr(thisExp, 'allow_advance_Q1'):
            thisExp.allow_advance_Q1 = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_Q1Bedtime.text.strip()
            if user_input != '':
                thisExp.allow_advance_Q1 = True
        
        if thisExp.allow_advance_Q1:
            continueRoutine = False
        
        
        # *enter_hint* updates
        
        # if enter_hint is starting this frame...
        if enter_hint.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            enter_hint.frameNStart = frameN  # exact frame index
            enter_hint.tStart = t  # local t and not account for scr refresh
            enter_hint.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(enter_hint, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'enter_hint.started')
            # update status
            enter_hint.status = STARTED
            enter_hint.setAutoDraw(True)
        
        # if enter_hint is active this frame...
        if enter_hint.status == STARTED:
            # update params
            pass
        
        # *Q31* updates
        
        # if Q31 is starting this frame...
        if Q31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q31.frameNStart = frameN  # exact frame index
            Q31.tStart = t  # local t and not account for scr refresh
            Q31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q31.started')
            # update status
            Q31.status = STARTED
            Q31.setAutoDraw(True)
        
        # if Q31 is active this frame...
        if Q31.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=B_PSQI_Q1_BedTime,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            B_PSQI_Q1_BedTime.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in B_PSQI_Q1_BedTime.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "B_PSQI_Q1_BedTime" ---
    for thisComponent in B_PSQI_Q1_BedTime.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for B_PSQI_Q1_BedTime
    B_PSQI_Q1_BedTime.tStop = globalClock.getTime(format='float')
    B_PSQI_Q1_BedTime.tStopRefresh = tThisFlipGlobal
    thisExp.addData('B_PSQI_Q1_BedTime.stopped', B_PSQI_Q1_BedTime.tStop)
    thisExp.addData('textbox_Q1Bedtime.text',textbox_Q1Bedtime.text)
    # Run 'End Routine' code from code_Q1Bedtime
    thisExp.addData('Q1_bed_time', textbox_Q1Bedtime.text)
    
    
    thisExp.nextEntry()
    # the Routine "B_PSQI_Q1_BedTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "B_PSQI_Q2_WakeTime" ---
    # create an object to store info about Routine B_PSQI_Q2_WakeTime
    B_PSQI_Q2_WakeTime = data.Routine(
        name='B_PSQI_Q2_WakeTime',
        components=[Q2_WakeTime, textbox_Q2WakeTime, enter_hint_2, Q32],
    )
    B_PSQI_Q2_WakeTime.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_Q2WakeTime.reset()
    # store start times for B_PSQI_Q2_WakeTime
    B_PSQI_Q2_WakeTime.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    B_PSQI_Q2_WakeTime.tStart = globalClock.getTime(format='float')
    B_PSQI_Q2_WakeTime.status = STARTED
    thisExp.addData('B_PSQI_Q2_WakeTime.started', B_PSQI_Q2_WakeTime.tStart)
    B_PSQI_Q2_WakeTime.maxDuration = None
    # keep track of which components have finished
    B_PSQI_Q2_WakeTimeComponents = B_PSQI_Q2_WakeTime.components
    for thisComponent in B_PSQI_Q2_WakeTime.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "B_PSQI_Q2_WakeTime" ---
    B_PSQI_Q2_WakeTime.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q2_WakeTime* updates
        
        # if Q2_WakeTime is starting this frame...
        if Q2_WakeTime.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q2_WakeTime.frameNStart = frameN  # exact frame index
            Q2_WakeTime.tStart = t  # local t and not account for scr refresh
            Q2_WakeTime.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q2_WakeTime, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q2_WakeTime.started')
            # update status
            Q2_WakeTime.status = STARTED
            Q2_WakeTime.setAutoDraw(True)
        
        # if Q2_WakeTime is active this frame...
        if Q2_WakeTime.status == STARTED:
            # update params
            pass
        
        # *textbox_Q2WakeTime* updates
        
        # if textbox_Q2WakeTime is starting this frame...
        if textbox_Q2WakeTime.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_Q2WakeTime.frameNStart = frameN  # exact frame index
            textbox_Q2WakeTime.tStart = t  # local t and not account for scr refresh
            textbox_Q2WakeTime.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_Q2WakeTime, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_Q2WakeTime.started')
            # update status
            textbox_Q2WakeTime.status = STARTED
            textbox_Q2WakeTime.setAutoDraw(True)
        
        # if textbox_Q2WakeTime is active this frame...
        if textbox_Q2WakeTime.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_Q2WakeTime
        if not hasattr(thisExp, 'allow_advance_Q2'):
            thisExp.allow_advance_Q2 = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_Q2WakeTime.text.strip()
            if user_input != '':
                thisExp.allow_advance_Q2 = True
        
        if thisExp.allow_advance_Q2:
            continueRoutine = False
        
        
        # *enter_hint_2* updates
        
        # if enter_hint_2 is starting this frame...
        if enter_hint_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            enter_hint_2.frameNStart = frameN  # exact frame index
            enter_hint_2.tStart = t  # local t and not account for scr refresh
            enter_hint_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(enter_hint_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'enter_hint_2.started')
            # update status
            enter_hint_2.status = STARTED
            enter_hint_2.setAutoDraw(True)
        
        # if enter_hint_2 is active this frame...
        if enter_hint_2.status == STARTED:
            # update params
            pass
        
        # *Q32* updates
        
        # if Q32 is starting this frame...
        if Q32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q32.frameNStart = frameN  # exact frame index
            Q32.tStart = t  # local t and not account for scr refresh
            Q32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q32.started')
            # update status
            Q32.status = STARTED
            Q32.setAutoDraw(True)
        
        # if Q32 is active this frame...
        if Q32.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=B_PSQI_Q2_WakeTime,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            B_PSQI_Q2_WakeTime.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in B_PSQI_Q2_WakeTime.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "B_PSQI_Q2_WakeTime" ---
    for thisComponent in B_PSQI_Q2_WakeTime.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for B_PSQI_Q2_WakeTime
    B_PSQI_Q2_WakeTime.tStop = globalClock.getTime(format='float')
    B_PSQI_Q2_WakeTime.tStopRefresh = tThisFlipGlobal
    thisExp.addData('B_PSQI_Q2_WakeTime.stopped', B_PSQI_Q2_WakeTime.tStop)
    thisExp.addData('textbox_Q2WakeTime.text',textbox_Q2WakeTime.text)
    # Run 'End Routine' code from code_Q2WakeTime
    thisExp.addData('Q2_wake_time', textbox_Q2WakeTime.text)
    
    
    
    thisExp.nextEntry()
    # the Routine "B_PSQI_Q2_WakeTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "B_PSQI_Q3_SleepLatency" ---
    # create an object to store info about Routine B_PSQI_Q3_SleepLatency
    B_PSQI_Q3_SleepLatency = data.Routine(
        name='B_PSQI_Q3_SleepLatency',
        components=[Q3_SleepLatency, textbox_Q3SleepLatency, enter_hint_3, Q33],
    )
    B_PSQI_Q3_SleepLatency.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_Q3SleepLatency.reset()
    # store start times for B_PSQI_Q3_SleepLatency
    B_PSQI_Q3_SleepLatency.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    B_PSQI_Q3_SleepLatency.tStart = globalClock.getTime(format='float')
    B_PSQI_Q3_SleepLatency.status = STARTED
    thisExp.addData('B_PSQI_Q3_SleepLatency.started', B_PSQI_Q3_SleepLatency.tStart)
    B_PSQI_Q3_SleepLatency.maxDuration = None
    # keep track of which components have finished
    B_PSQI_Q3_SleepLatencyComponents = B_PSQI_Q3_SleepLatency.components
    for thisComponent in B_PSQI_Q3_SleepLatency.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "B_PSQI_Q3_SleepLatency" ---
    B_PSQI_Q3_SleepLatency.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q3_SleepLatency* updates
        
        # if Q3_SleepLatency is starting this frame...
        if Q3_SleepLatency.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q3_SleepLatency.frameNStart = frameN  # exact frame index
            Q3_SleepLatency.tStart = t  # local t and not account for scr refresh
            Q3_SleepLatency.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q3_SleepLatency, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q3_SleepLatency.started')
            # update status
            Q3_SleepLatency.status = STARTED
            Q3_SleepLatency.setAutoDraw(True)
        
        # if Q3_SleepLatency is active this frame...
        if Q3_SleepLatency.status == STARTED:
            # update params
            pass
        
        # *textbox_Q3SleepLatency* updates
        
        # if textbox_Q3SleepLatency is starting this frame...
        if textbox_Q3SleepLatency.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_Q3SleepLatency.frameNStart = frameN  # exact frame index
            textbox_Q3SleepLatency.tStart = t  # local t and not account for scr refresh
            textbox_Q3SleepLatency.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_Q3SleepLatency, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_Q3SleepLatency.started')
            # update status
            textbox_Q3SleepLatency.status = STARTED
            textbox_Q3SleepLatency.setAutoDraw(True)
        
        # if textbox_Q3SleepLatency is active this frame...
        if textbox_Q3SleepLatency.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_Q3SleepLatency
        if not hasattr(thisExp, 'allow_advance_Q3'):
            thisExp.allow_advance_Q3 = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_Q3SleepLatency.text.strip()
            if user_input != '':
                thisExp.allow_advance_Q3 = True
        
        if thisExp.allow_advance_Q3:
            continueRoutine = False
        
        
        # *enter_hint_3* updates
        
        # if enter_hint_3 is starting this frame...
        if enter_hint_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            enter_hint_3.frameNStart = frameN  # exact frame index
            enter_hint_3.tStart = t  # local t and not account for scr refresh
            enter_hint_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(enter_hint_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'enter_hint_3.started')
            # update status
            enter_hint_3.status = STARTED
            enter_hint_3.setAutoDraw(True)
        
        # if enter_hint_3 is active this frame...
        if enter_hint_3.status == STARTED:
            # update params
            pass
        
        # *Q33* updates
        
        # if Q33 is starting this frame...
        if Q33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q33.frameNStart = frameN  # exact frame index
            Q33.tStart = t  # local t and not account for scr refresh
            Q33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q33.started')
            # update status
            Q33.status = STARTED
            Q33.setAutoDraw(True)
        
        # if Q33 is active this frame...
        if Q33.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=B_PSQI_Q3_SleepLatency,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            B_PSQI_Q3_SleepLatency.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in B_PSQI_Q3_SleepLatency.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "B_PSQI_Q3_SleepLatency" ---
    for thisComponent in B_PSQI_Q3_SleepLatency.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for B_PSQI_Q3_SleepLatency
    B_PSQI_Q3_SleepLatency.tStop = globalClock.getTime(format='float')
    B_PSQI_Q3_SleepLatency.tStopRefresh = tThisFlipGlobal
    thisExp.addData('B_PSQI_Q3_SleepLatency.stopped', B_PSQI_Q3_SleepLatency.tStop)
    thisExp.addData('textbox_Q3SleepLatency.text',textbox_Q3SleepLatency.text)
    # Run 'End Routine' code from code_Q3SleepLatency
    thisExp.addData('Q3_sleep_latency', textbox_Q3SleepLatency.text)
    
    thisExp.nextEntry()
    # the Routine "B_PSQI_Q3_SleepLatency" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "B_PSQI_Q4_ActualSleep" ---
    # create an object to store info about Routine B_PSQI_Q4_ActualSleep
    B_PSQI_Q4_ActualSleep = data.Routine(
        name='B_PSQI_Q4_ActualSleep',
        components=[Q4_ActualSleep, textbox_Q4ActualSleep, enter_hint_4, Q34],
    )
    B_PSQI_Q4_ActualSleep.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    textbox_Q4ActualSleep.reset()
    # store start times for B_PSQI_Q4_ActualSleep
    B_PSQI_Q4_ActualSleep.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    B_PSQI_Q4_ActualSleep.tStart = globalClock.getTime(format='float')
    B_PSQI_Q4_ActualSleep.status = STARTED
    thisExp.addData('B_PSQI_Q4_ActualSleep.started', B_PSQI_Q4_ActualSleep.tStart)
    B_PSQI_Q4_ActualSleep.maxDuration = None
    # keep track of which components have finished
    B_PSQI_Q4_ActualSleepComponents = B_PSQI_Q4_ActualSleep.components
    for thisComponent in B_PSQI_Q4_ActualSleep.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "B_PSQI_Q4_ActualSleep" ---
    B_PSQI_Q4_ActualSleep.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q4_ActualSleep* updates
        
        # if Q4_ActualSleep is starting this frame...
        if Q4_ActualSleep.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q4_ActualSleep.frameNStart = frameN  # exact frame index
            Q4_ActualSleep.tStart = t  # local t and not account for scr refresh
            Q4_ActualSleep.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q4_ActualSleep, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q4_ActualSleep.started')
            # update status
            Q4_ActualSleep.status = STARTED
            Q4_ActualSleep.setAutoDraw(True)
        
        # if Q4_ActualSleep is active this frame...
        if Q4_ActualSleep.status == STARTED:
            # update params
            pass
        
        # *textbox_Q4ActualSleep* updates
        
        # if textbox_Q4ActualSleep is starting this frame...
        if textbox_Q4ActualSleep.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbox_Q4ActualSleep.frameNStart = frameN  # exact frame index
            textbox_Q4ActualSleep.tStart = t  # local t and not account for scr refresh
            textbox_Q4ActualSleep.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbox_Q4ActualSleep, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'textbox_Q4ActualSleep.started')
            # update status
            textbox_Q4ActualSleep.status = STARTED
            textbox_Q4ActualSleep.setAutoDraw(True)
        
        # if textbox_Q4ActualSleep is active this frame...
        if textbox_Q4ActualSleep.status == STARTED:
            # update params
            pass
        # Run 'Each Frame' code from code_Q4ActualSleep
        if not hasattr(thisExp, 'allow_advance_Q4'):
            thisExp.allow_advance_Q4 = False
        
        keys = event.getKeys()
        if 'return' in keys:
            user_input = textbox_Q4ActualSleep.text.strip()
            if user_input != '':
                thisExp.allow_advance_Q4 = True
        
        if thisExp.allow_advance_Q4:
            continueRoutine = False
        
        
        # *enter_hint_4* updates
        
        # if enter_hint_4 is starting this frame...
        if enter_hint_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            enter_hint_4.frameNStart = frameN  # exact frame index
            enter_hint_4.tStart = t  # local t and not account for scr refresh
            enter_hint_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(enter_hint_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'enter_hint_4.started')
            # update status
            enter_hint_4.status = STARTED
            enter_hint_4.setAutoDraw(True)
        
        # if enter_hint_4 is active this frame...
        if enter_hint_4.status == STARTED:
            # update params
            pass
        
        # *Q34* updates
        
        # if Q34 is starting this frame...
        if Q34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q34.frameNStart = frameN  # exact frame index
            Q34.tStart = t  # local t and not account for scr refresh
            Q34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q34.started')
            # update status
            Q34.status = STARTED
            Q34.setAutoDraw(True)
        
        # if Q34 is active this frame...
        if Q34.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=B_PSQI_Q4_ActualSleep,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            B_PSQI_Q4_ActualSleep.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in B_PSQI_Q4_ActualSleep.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "B_PSQI_Q4_ActualSleep" ---
    for thisComponent in B_PSQI_Q4_ActualSleep.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for B_PSQI_Q4_ActualSleep
    B_PSQI_Q4_ActualSleep.tStop = globalClock.getTime(format='float')
    B_PSQI_Q4_ActualSleep.tStopRefresh = tThisFlipGlobal
    thisExp.addData('B_PSQI_Q4_ActualSleep.stopped', B_PSQI_Q4_ActualSleep.tStop)
    thisExp.addData('textbox_Q4ActualSleep.text',textbox_Q4ActualSleep.text)
    # Run 'End Routine' code from code_Q4ActualSleep
    thisExp.addData('Q4_actual_sleep_hour', textbox_Q4ActualSleep.text)
    
    thisExp.nextEntry()
    # the Routine "B_PSQI_Q4_ActualSleep" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_PSQI = data.TrialHandler2(
        name='trials_PSQI',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('B_PSQIQUESTIONTEXT5.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_PSQI)  # add the loop to the experiment
    thisTrials_PSQI = trials_PSQI.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_PSQI.rgb)
    if thisTrials_PSQI != None:
        for paramName in thisTrials_PSQI:
            globals()[paramName] = thisTrials_PSQI[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_PSQI in trials_PSQI:
        trials_PSQI.status = STARTED
        if hasattr(thisTrials_PSQI, 'status'):
            thisTrials_PSQI.status = STARTED
        currentLoop = trials_PSQI
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_PSQI.rgb)
        if thisTrials_PSQI != None:
            for paramName in thisTrials_PSQI:
                globals()[paramName] = thisTrials_PSQI[paramName]
        
        # --- Prepare to start Routine "B_PSQI5" ---
        # create an object to store info about Routine B_PSQI5
        B_PSQI5 = data.Routine(
            name='B_PSQI5',
            components=[B_PSQIquestionText, B_PSQIquestionslide, Q35],
        )
        B_PSQI5.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        B_PSQIquestionText.setText(PSQI5qText
        )
        B_PSQIquestionslide.reset()
        Q35.setText('Question 35 of 89\n')
        # store start times for B_PSQI5
        B_PSQI5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        B_PSQI5.tStart = globalClock.getTime(format='float')
        B_PSQI5.status = STARTED
        thisExp.addData('B_PSQI5.started', B_PSQI5.tStart)
        B_PSQI5.maxDuration = None
        # keep track of which components have finished
        B_PSQI5Components = B_PSQI5.components
        for thisComponent in B_PSQI5.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "B_PSQI5" ---
        B_PSQI5.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_PSQI, 'status') and thisTrials_PSQI.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *B_PSQIquestionText* updates
            
            # if B_PSQIquestionText is starting this frame...
            if B_PSQIquestionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                B_PSQIquestionText.frameNStart = frameN  # exact frame index
                B_PSQIquestionText.tStart = t  # local t and not account for scr refresh
                B_PSQIquestionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(B_PSQIquestionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'B_PSQIquestionText.started')
                # update status
                B_PSQIquestionText.status = STARTED
                B_PSQIquestionText.setAutoDraw(True)
            
            # if B_PSQIquestionText is active this frame...
            if B_PSQIquestionText.status == STARTED:
                # update params
                pass
            
            # *B_PSQIquestionslide* updates
            
            # if B_PSQIquestionslide is starting this frame...
            if B_PSQIquestionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                B_PSQIquestionslide.frameNStart = frameN  # exact frame index
                B_PSQIquestionslide.tStart = t  # local t and not account for scr refresh
                B_PSQIquestionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(B_PSQIquestionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'B_PSQIquestionslide.started')
                # update status
                B_PSQIquestionslide.status = STARTED
                B_PSQIquestionslide.setAutoDraw(True)
            
            # if B_PSQIquestionslide is active this frame...
            if B_PSQIquestionslide.status == STARTED:
                # update params
                pass
            
            # Check B_PSQIquestionslide for response to end Routine
            if B_PSQIquestionslide.getRating() is not None and B_PSQIquestionslide.status == STARTED:
                continueRoutine = False
            
            # *Q35* updates
            
            # if Q35 is starting this frame...
            if Q35.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q35.frameNStart = frameN  # exact frame index
                Q35.tStart = t  # local t and not account for scr refresh
                Q35.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q35, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q35.started')
                # update status
                Q35.status = STARTED
                Q35.setAutoDraw(True)
            
            # if Q35 is active this frame...
            if Q35.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=B_PSQI5,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                B_PSQI5.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in B_PSQI5.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "B_PSQI5" ---
        for thisComponent in B_PSQI5.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for B_PSQI5
        B_PSQI5.tStop = globalClock.getTime(format='float')
        B_PSQI5.tStopRefresh = tThisFlipGlobal
        thisExp.addData('B_PSQI5.stopped', B_PSQI5.tStop)
        trials_PSQI.addData('B_PSQIquestionslide.response', B_PSQIquestionslide.getRating())
        trials_PSQI.addData('B_PSQIquestionslide.rt', B_PSQIquestionslide.getRT())
        # the Routine "B_PSQI5" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_PSQI as finished
        if hasattr(thisTrials_PSQI, 'status'):
            thisTrials_PSQI.status = FINISHED
        # if awaiting a pause, pause now
        if trials_PSQI.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_PSQI.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_PSQI'
    trials_PSQI.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_PSQI.trialList in ([], [None], None):
        params = []
    else:
        params = trials_PSQI.trialList[0].keys()
    # save data for this loop
    trials_PSQI.saveAsExcel(filename + '.xlsx', sheetName='trials_PSQI',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_PSQI.saveAsText(filename + '_trials_PSQI.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # set up handler to look after randomisation of conditions etc
    trials_PSQI_6 = data.TrialHandler2(
        name='trials_PSQI_6',
        nReps=1.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('B_PSQIQUESTIONTEXT6.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_PSQI_6)  # add the loop to the experiment
    thisTrials_PSQI_6 = trials_PSQI_6.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_PSQI_6.rgb)
    if thisTrials_PSQI_6 != None:
        for paramName in thisTrials_PSQI_6:
            globals()[paramName] = thisTrials_PSQI_6[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_PSQI_6 in trials_PSQI_6:
        trials_PSQI_6.status = STARTED
        if hasattr(thisTrials_PSQI_6, 'status'):
            thisTrials_PSQI_6.status = STARTED
        currentLoop = trials_PSQI_6
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_PSQI_6.rgb)
        if thisTrials_PSQI_6 != None:
            for paramName in thisTrials_PSQI_6:
                globals()[paramName] = thisTrials_PSQI_6[paramName]
        
        # --- Prepare to start Routine "B_PSQI6" ---
        # create an object to store info about Routine B_PSQI6
        B_PSQI6 = data.Routine(
            name='B_PSQI6',
            components=[B_PSQIquestionText6, B_PSQIquestionslide6, Q36],
        )
        B_PSQI6.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        B_PSQIquestionText6.setText(PSQI6qText
        )
        B_PSQIquestionslide6.reset()
        Q36.setText('Question 36 of 89\n')
        # store start times for B_PSQI6
        B_PSQI6.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        B_PSQI6.tStart = globalClock.getTime(format='float')
        B_PSQI6.status = STARTED
        thisExp.addData('B_PSQI6.started', B_PSQI6.tStart)
        B_PSQI6.maxDuration = None
        # keep track of which components have finished
        B_PSQI6Components = B_PSQI6.components
        for thisComponent in B_PSQI6.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "B_PSQI6" ---
        B_PSQI6.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_PSQI_6, 'status') and thisTrials_PSQI_6.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *B_PSQIquestionText6* updates
            
            # if B_PSQIquestionText6 is starting this frame...
            if B_PSQIquestionText6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                B_PSQIquestionText6.frameNStart = frameN  # exact frame index
                B_PSQIquestionText6.tStart = t  # local t and not account for scr refresh
                B_PSQIquestionText6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(B_PSQIquestionText6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'B_PSQIquestionText6.started')
                # update status
                B_PSQIquestionText6.status = STARTED
                B_PSQIquestionText6.setAutoDraw(True)
            
            # if B_PSQIquestionText6 is active this frame...
            if B_PSQIquestionText6.status == STARTED:
                # update params
                pass
            
            # *B_PSQIquestionslide6* updates
            
            # if B_PSQIquestionslide6 is starting this frame...
            if B_PSQIquestionslide6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                B_PSQIquestionslide6.frameNStart = frameN  # exact frame index
                B_PSQIquestionslide6.tStart = t  # local t and not account for scr refresh
                B_PSQIquestionslide6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(B_PSQIquestionslide6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'B_PSQIquestionslide6.started')
                # update status
                B_PSQIquestionslide6.status = STARTED
                B_PSQIquestionslide6.setAutoDraw(True)
            
            # if B_PSQIquestionslide6 is active this frame...
            if B_PSQIquestionslide6.status == STARTED:
                # update params
                pass
            
            # Check B_PSQIquestionslide6 for response to end Routine
            if B_PSQIquestionslide6.getRating() is not None and B_PSQIquestionslide6.status == STARTED:
                continueRoutine = False
            
            # *Q36* updates
            
            # if Q36 is starting this frame...
            if Q36.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q36.frameNStart = frameN  # exact frame index
                Q36.tStart = t  # local t and not account for scr refresh
                Q36.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q36, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q36.started')
                # update status
                Q36.status = STARTED
                Q36.setAutoDraw(True)
            
            # if Q36 is active this frame...
            if Q36.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=B_PSQI6,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                B_PSQI6.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in B_PSQI6.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "B_PSQI6" ---
        for thisComponent in B_PSQI6.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for B_PSQI6
        B_PSQI6.tStop = globalClock.getTime(format='float')
        B_PSQI6.tStopRefresh = tThisFlipGlobal
        thisExp.addData('B_PSQI6.stopped', B_PSQI6.tStop)
        trials_PSQI_6.addData('B_PSQIquestionslide6.response', B_PSQIquestionslide6.getRating())
        trials_PSQI_6.addData('B_PSQIquestionslide6.rt', B_PSQIquestionslide6.getRT())
        # the Routine "B_PSQI6" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_PSQI_6 as finished
        if hasattr(thisTrials_PSQI_6, 'status'):
            thisTrials_PSQI_6.status = FINISHED
        # if awaiting a pause, pause now
        if trials_PSQI_6.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_PSQI_6.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_PSQI_6'
    trials_PSQI_6.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_PSQI_6.trialList in ([], [None], None):
        params = []
    else:
        params = trials_PSQI_6.trialList[0].keys()
    # save data for this loop
    trials_PSQI_6.saveAsExcel(filename + '.xlsx', sheetName='trials_PSQI_6',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_PSQI_6.saveAsText(filename + '_trials_PSQI_6.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "Durel_intro" ---
    # create an object to store info about Routine Durel_intro
    Durel_intro = data.Routine(
        name='Durel_intro',
        components=[DUREL_intro_image, key_resp_6],
    )
    Durel_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_6
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # store start times for Durel_intro
    Durel_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Durel_intro.tStart = globalClock.getTime(format='float')
    Durel_intro.status = STARTED
    thisExp.addData('Durel_intro.started', Durel_intro.tStart)
    Durel_intro.maxDuration = None
    # keep track of which components have finished
    Durel_introComponents = Durel_intro.components
    for thisComponent in Durel_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Durel_intro" ---
    Durel_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *DUREL_intro_image* updates
        
        # if DUREL_intro_image is starting this frame...
        if DUREL_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            DUREL_intro_image.frameNStart = frameN  # exact frame index
            DUREL_intro_image.tStart = t  # local t and not account for scr refresh
            DUREL_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(DUREL_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'DUREL_intro_image.started')
            # update status
            DUREL_intro_image.status = STARTED
            DUREL_intro_image.setAutoDraw(True)
        
        # if DUREL_intro_image is active this frame...
        if DUREL_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_6* updates
        waitOnFlip = False
        
        # if key_resp_6 is starting this frame...
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_6.started')
            # update status
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                key_resp_6.duration = _key_resp_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Durel_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Durel_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Durel_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Durel_intro" ---
    for thisComponent in Durel_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Durel_intro
    Durel_intro.tStop = globalClock.getTime(format='float')
    Durel_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Durel_intro.stopped', Durel_intro.tStop)
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    thisExp.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        thisExp.addData('key_resp_6.rt', key_resp_6.rt)
        thisExp.addData('key_resp_6.duration', key_resp_6.duration)
    thisExp.nextEntry()
    # the Routine "Durel_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_DUREL1 = data.TrialHandler2(
        name='trials_DUREL1',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('DURELquestion1.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_DUREL1)  # add the loop to the experiment
    thisTrials_DUREL1 = trials_DUREL1.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL1.rgb)
    if thisTrials_DUREL1 != None:
        for paramName in thisTrials_DUREL1:
            globals()[paramName] = thisTrials_DUREL1[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_DUREL1 in trials_DUREL1:
        trials_DUREL1.status = STARTED
        if hasattr(thisTrials_DUREL1, 'status'):
            thisTrials_DUREL1.status = STARTED
        currentLoop = trials_DUREL1
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL1.rgb)
        if thisTrials_DUREL1 != None:
            for paramName in thisTrials_DUREL1:
                globals()[paramName] = thisTrials_DUREL1[paramName]
        
        # --- Prepare to start Routine "DUREL1" ---
        # create an object to store info about Routine DUREL1
        DUREL1 = data.Routine(
            name='DUREL1',
            components=[DUREL_questionText, DURELquestionslide, Q37],
        )
        DUREL1.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        DUREL_questionText.setText(DUREL1qText)
        DURELquestionslide.reset()
        Q37.setText('Question 37 of 89\n')
        # store start times for DUREL1
        DUREL1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DUREL1.tStart = globalClock.getTime(format='float')
        DUREL1.status = STARTED
        thisExp.addData('DUREL1.started', DUREL1.tStart)
        DUREL1.maxDuration = None
        # keep track of which components have finished
        DUREL1Components = DUREL1.components
        for thisComponent in DUREL1.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DUREL1" ---
        DUREL1.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_DUREL1, 'status') and thisTrials_DUREL1.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *DUREL_questionText* updates
            
            # if DUREL_questionText is starting this frame...
            if DUREL_questionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DUREL_questionText.frameNStart = frameN  # exact frame index
                DUREL_questionText.tStart = t  # local t and not account for scr refresh
                DUREL_questionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DUREL_questionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DUREL_questionText.started')
                # update status
                DUREL_questionText.status = STARTED
                DUREL_questionText.setAutoDraw(True)
            
            # if DUREL_questionText is active this frame...
            if DUREL_questionText.status == STARTED:
                # update params
                pass
            
            # *DURELquestionslide* updates
            
            # if DURELquestionslide is starting this frame...
            if DURELquestionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DURELquestionslide.frameNStart = frameN  # exact frame index
                DURELquestionslide.tStart = t  # local t and not account for scr refresh
                DURELquestionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DURELquestionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DURELquestionslide.started')
                # update status
                DURELquestionslide.status = STARTED
                DURELquestionslide.setAutoDraw(True)
            
            # if DURELquestionslide is active this frame...
            if DURELquestionslide.status == STARTED:
                # update params
                pass
            
            # Check DURELquestionslide for response to end Routine
            if DURELquestionslide.getRating() is not None and DURELquestionslide.status == STARTED:
                continueRoutine = False
            
            # *Q37* updates
            
            # if Q37 is starting this frame...
            if Q37.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q37.frameNStart = frameN  # exact frame index
                Q37.tStart = t  # local t and not account for scr refresh
                Q37.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q37, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q37.started')
                # update status
                Q37.status = STARTED
                Q37.setAutoDraw(True)
            
            # if Q37 is active this frame...
            if Q37.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=DUREL1,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DUREL1.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DUREL1.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DUREL1" ---
        for thisComponent in DUREL1.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DUREL1
        DUREL1.tStop = globalClock.getTime(format='float')
        DUREL1.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DUREL1.stopped', DUREL1.tStop)
        trials_DUREL1.addData('DURELquestionslide.response', DURELquestionslide.getRating())
        trials_DUREL1.addData('DURELquestionslide.rt', DURELquestionslide.getRT())
        # the Routine "DUREL1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_DUREL1 as finished
        if hasattr(thisTrials_DUREL1, 'status'):
            thisTrials_DUREL1.status = FINISHED
        # if awaiting a pause, pause now
        if trials_DUREL1.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_DUREL1.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_DUREL1'
    trials_DUREL1.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_DUREL1.trialList in ([], [None], None):
        params = []
    else:
        params = trials_DUREL1.trialList[0].keys()
    # save data for this loop
    trials_DUREL1.saveAsExcel(filename + '.xlsx', sheetName='trials_DUREL1',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_DUREL1.saveAsText(filename + '_trials_DUREL1.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # set up handler to look after randomisation of conditions etc
    trials_DUREL2 = data.TrialHandler2(
        name='trials_DUREL2',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('DURELquestion2.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_DUREL2)  # add the loop to the experiment
    thisTrials_DUREL2 = trials_DUREL2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL2.rgb)
    if thisTrials_DUREL2 != None:
        for paramName in thisTrials_DUREL2:
            globals()[paramName] = thisTrials_DUREL2[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_DUREL2 in trials_DUREL2:
        trials_DUREL2.status = STARTED
        if hasattr(thisTrials_DUREL2, 'status'):
            thisTrials_DUREL2.status = STARTED
        currentLoop = trials_DUREL2
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL2.rgb)
        if thisTrials_DUREL2 != None:
            for paramName in thisTrials_DUREL2:
                globals()[paramName] = thisTrials_DUREL2[paramName]
        
        # --- Prepare to start Routine "DUREL2" ---
        # create an object to store info about Routine DUREL2
        DUREL2 = data.Routine(
            name='DUREL2',
            components=[DUREL_questionText2, DURELquestionslide2, Q38],
        )
        DUREL2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        DUREL_questionText2.setText(DUREL2qText)
        DURELquestionslide2.reset()
        Q38.setText('Question 38 of 89\n')
        # store start times for DUREL2
        DUREL2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DUREL2.tStart = globalClock.getTime(format='float')
        DUREL2.status = STARTED
        thisExp.addData('DUREL2.started', DUREL2.tStart)
        DUREL2.maxDuration = None
        # keep track of which components have finished
        DUREL2Components = DUREL2.components
        for thisComponent in DUREL2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DUREL2" ---
        DUREL2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_DUREL2, 'status') and thisTrials_DUREL2.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *DUREL_questionText2* updates
            
            # if DUREL_questionText2 is starting this frame...
            if DUREL_questionText2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DUREL_questionText2.frameNStart = frameN  # exact frame index
                DUREL_questionText2.tStart = t  # local t and not account for scr refresh
                DUREL_questionText2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DUREL_questionText2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DUREL_questionText2.started')
                # update status
                DUREL_questionText2.status = STARTED
                DUREL_questionText2.setAutoDraw(True)
            
            # if DUREL_questionText2 is active this frame...
            if DUREL_questionText2.status == STARTED:
                # update params
                pass
            
            # *DURELquestionslide2* updates
            
            # if DURELquestionslide2 is starting this frame...
            if DURELquestionslide2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DURELquestionslide2.frameNStart = frameN  # exact frame index
                DURELquestionslide2.tStart = t  # local t and not account for scr refresh
                DURELquestionslide2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DURELquestionslide2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DURELquestionslide2.started')
                # update status
                DURELquestionslide2.status = STARTED
                DURELquestionslide2.setAutoDraw(True)
            
            # if DURELquestionslide2 is active this frame...
            if DURELquestionslide2.status == STARTED:
                # update params
                pass
            
            # Check DURELquestionslide2 for response to end Routine
            if DURELquestionslide2.getRating() is not None and DURELquestionslide2.status == STARTED:
                continueRoutine = False
            
            # *Q38* updates
            
            # if Q38 is starting this frame...
            if Q38.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q38.frameNStart = frameN  # exact frame index
                Q38.tStart = t  # local t and not account for scr refresh
                Q38.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q38, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q38.started')
                # update status
                Q38.status = STARTED
                Q38.setAutoDraw(True)
            
            # if Q38 is active this frame...
            if Q38.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=DUREL2,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DUREL2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DUREL2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DUREL2" ---
        for thisComponent in DUREL2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DUREL2
        DUREL2.tStop = globalClock.getTime(format='float')
        DUREL2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DUREL2.stopped', DUREL2.tStop)
        trials_DUREL2.addData('DURELquestionslide2.response', DURELquestionslide2.getRating())
        trials_DUREL2.addData('DURELquestionslide2.rt', DURELquestionslide2.getRT())
        # the Routine "DUREL2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_DUREL2 as finished
        if hasattr(thisTrials_DUREL2, 'status'):
            thisTrials_DUREL2.status = FINISHED
        # if awaiting a pause, pause now
        if trials_DUREL2.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_DUREL2.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_DUREL2'
    trials_DUREL2.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_DUREL2.trialList in ([], [None], None):
        params = []
    else:
        params = trials_DUREL2.trialList[0].keys()
    # save data for this loop
    trials_DUREL2.saveAsExcel(filename + '.xlsx', sheetName='trials_DUREL2',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_DUREL2.saveAsText(filename + '_trials_DUREL2.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # set up handler to look after randomisation of conditions etc
    trials_DUREL345 = data.TrialHandler2(
        name='trials_DUREL345',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('DURELquestion345.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_DUREL345)  # add the loop to the experiment
    thisTrials_DUREL345 = trials_DUREL345.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL345.rgb)
    if thisTrials_DUREL345 != None:
        for paramName in thisTrials_DUREL345:
            globals()[paramName] = thisTrials_DUREL345[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_DUREL345 in trials_DUREL345:
        trials_DUREL345.status = STARTED
        if hasattr(thisTrials_DUREL345, 'status'):
            thisTrials_DUREL345.status = STARTED
        currentLoop = trials_DUREL345
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_DUREL345.rgb)
        if thisTrials_DUREL345 != None:
            for paramName in thisTrials_DUREL345:
                globals()[paramName] = thisTrials_DUREL345[paramName]
        
        # --- Prepare to start Routine "DUREL345" ---
        # create an object to store info about Routine DUREL345
        DUREL345 = data.Routine(
            name='DUREL345',
            components=[DUREL_questionText345, DURELquestionslide345, Q39toQ41],
        )
        DUREL345.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        DUREL_questionText345.setText(DUREL345qText)
        DURELquestionslide345.reset()
        Q39toQ41.setText(DUREL345qIndex)
        # store start times for DUREL345
        DUREL345.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DUREL345.tStart = globalClock.getTime(format='float')
        DUREL345.status = STARTED
        thisExp.addData('DUREL345.started', DUREL345.tStart)
        DUREL345.maxDuration = None
        # keep track of which components have finished
        DUREL345Components = DUREL345.components
        for thisComponent in DUREL345.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DUREL345" ---
        DUREL345.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_DUREL345, 'status') and thisTrials_DUREL345.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *DUREL_questionText345* updates
            
            # if DUREL_questionText345 is starting this frame...
            if DUREL_questionText345.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DUREL_questionText345.frameNStart = frameN  # exact frame index
                DUREL_questionText345.tStart = t  # local t and not account for scr refresh
                DUREL_questionText345.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DUREL_questionText345, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DUREL_questionText345.started')
                # update status
                DUREL_questionText345.status = STARTED
                DUREL_questionText345.setAutoDraw(True)
            
            # if DUREL_questionText345 is active this frame...
            if DUREL_questionText345.status == STARTED:
                # update params
                pass
            
            # *DURELquestionslide345* updates
            
            # if DURELquestionslide345 is starting this frame...
            if DURELquestionslide345.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                DURELquestionslide345.frameNStart = frameN  # exact frame index
                DURELquestionslide345.tStart = t  # local t and not account for scr refresh
                DURELquestionslide345.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(DURELquestionslide345, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'DURELquestionslide345.started')
                # update status
                DURELquestionslide345.status = STARTED
                DURELquestionslide345.setAutoDraw(True)
            
            # if DURELquestionslide345 is active this frame...
            if DURELquestionslide345.status == STARTED:
                # update params
                pass
            
            # Check DURELquestionslide345 for response to end Routine
            if DURELquestionslide345.getRating() is not None and DURELquestionslide345.status == STARTED:
                continueRoutine = False
            
            # *Q39toQ41* updates
            
            # if Q39toQ41 is starting this frame...
            if Q39toQ41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q39toQ41.frameNStart = frameN  # exact frame index
                Q39toQ41.tStart = t  # local t and not account for scr refresh
                Q39toQ41.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q39toQ41, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q39toQ41.started')
                # update status
                Q39toQ41.status = STARTED
                Q39toQ41.setAutoDraw(True)
            
            # if Q39toQ41 is active this frame...
            if Q39toQ41.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=DUREL345,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DUREL345.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DUREL345.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DUREL345" ---
        for thisComponent in DUREL345.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DUREL345
        DUREL345.tStop = globalClock.getTime(format='float')
        DUREL345.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DUREL345.stopped', DUREL345.tStop)
        trials_DUREL345.addData('DURELquestionslide345.response', DURELquestionslide345.getRating())
        trials_DUREL345.addData('DURELquestionslide345.rt', DURELquestionslide345.getRT())
        # the Routine "DUREL345" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_DUREL345 as finished
        if hasattr(thisTrials_DUREL345, 'status'):
            thisTrials_DUREL345.status = FINISHED
        # if awaiting a pause, pause now
        if trials_DUREL345.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_DUREL345.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_DUREL345'
    trials_DUREL345.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_DUREL345.trialList in ([], [None], None):
        params = []
    else:
        params = trials_DUREL345.trialList[0].keys()
    # save data for this loop
    trials_DUREL345.saveAsExcel(filename + '.xlsx', sheetName='trials_DUREL345',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_DUREL345.saveAsText(filename + '_trials_DUREL345.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "BMRQ_intro" ---
    # create an object to store info about Routine BMRQ_intro
    BMRQ_intro = data.Routine(
        name='BMRQ_intro',
        components=[BMRQ_intro_image, key_resp_7],
    )
    BMRQ_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_7
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # store start times for BMRQ_intro
    BMRQ_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    BMRQ_intro.tStart = globalClock.getTime(format='float')
    BMRQ_intro.status = STARTED
    thisExp.addData('BMRQ_intro.started', BMRQ_intro.tStart)
    BMRQ_intro.maxDuration = None
    # keep track of which components have finished
    BMRQ_introComponents = BMRQ_intro.components
    for thisComponent in BMRQ_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "BMRQ_intro" ---
    BMRQ_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *BMRQ_intro_image* updates
        
        # if BMRQ_intro_image is starting this frame...
        if BMRQ_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            BMRQ_intro_image.frameNStart = frameN  # exact frame index
            BMRQ_intro_image.tStart = t  # local t and not account for scr refresh
            BMRQ_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(BMRQ_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'BMRQ_intro_image.started')
            # update status
            BMRQ_intro_image.status = STARTED
            BMRQ_intro_image.setAutoDraw(True)
        
        # if BMRQ_intro_image is active this frame...
        if BMRQ_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_7* updates
        waitOnFlip = False
        
        # if key_resp_7 is starting this frame...
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_7.started')
            # update status
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                key_resp_7.duration = _key_resp_7_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=BMRQ_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            BMRQ_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BMRQ_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "BMRQ_intro" ---
    for thisComponent in BMRQ_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for BMRQ_intro
    BMRQ_intro.tStop = globalClock.getTime(format='float')
    BMRQ_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('BMRQ_intro.stopped', BMRQ_intro.tStop)
    # check responses
    if key_resp_7.keys in ['', [], None]:  # No response was made
        key_resp_7.keys = None
    thisExp.addData('key_resp_7.keys',key_resp_7.keys)
    if key_resp_7.keys != None:  # we had a response
        thisExp.addData('key_resp_7.rt', key_resp_7.rt)
        thisExp.addData('key_resp_7.duration', key_resp_7.duration)
    thisExp.nextEntry()
    # the Routine "BMRQ_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_BMRQ = data.TrialHandler2(
        name='trials_BMRQ',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('BMRQ.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_BMRQ)  # add the loop to the experiment
    thisTrials_BMRQ = trials_BMRQ.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_BMRQ.rgb)
    if thisTrials_BMRQ != None:
        for paramName in thisTrials_BMRQ:
            globals()[paramName] = thisTrials_BMRQ[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_BMRQ in trials_BMRQ:
        trials_BMRQ.status = STARTED
        if hasattr(thisTrials_BMRQ, 'status'):
            thisTrials_BMRQ.status = STARTED
        currentLoop = trials_BMRQ
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_BMRQ.rgb)
        if thisTrials_BMRQ != None:
            for paramName in thisTrials_BMRQ:
                globals()[paramName] = thisTrials_BMRQ[paramName]
        
        # --- Prepare to start Routine "BMRQ" ---
        # create an object to store info about Routine BMRQ
        BMRQ = data.Routine(
            name='BMRQ',
            components=[BMRQ_questionText, BMRQ_slider, Q42toQ61],
        )
        BMRQ.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        BMRQ_questionText.setText(BMRQqText)
        BMRQ_slider.reset()
        Q42toQ61.setText(BMRQqIndex)
        # store start times for BMRQ
        BMRQ.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        BMRQ.tStart = globalClock.getTime(format='float')
        BMRQ.status = STARTED
        thisExp.addData('BMRQ.started', BMRQ.tStart)
        BMRQ.maxDuration = None
        # keep track of which components have finished
        BMRQComponents = BMRQ.components
        for thisComponent in BMRQ.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "BMRQ" ---
        BMRQ.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_BMRQ, 'status') and thisTrials_BMRQ.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *BMRQ_questionText* updates
            
            # if BMRQ_questionText is starting this frame...
            if BMRQ_questionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BMRQ_questionText.frameNStart = frameN  # exact frame index
                BMRQ_questionText.tStart = t  # local t and not account for scr refresh
                BMRQ_questionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BMRQ_questionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BMRQ_questionText.started')
                # update status
                BMRQ_questionText.status = STARTED
                BMRQ_questionText.setAutoDraw(True)
            
            # if BMRQ_questionText is active this frame...
            if BMRQ_questionText.status == STARTED:
                # update params
                pass
            
            # *BMRQ_slider* updates
            
            # if BMRQ_slider is starting this frame...
            if BMRQ_slider.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BMRQ_slider.frameNStart = frameN  # exact frame index
                BMRQ_slider.tStart = t  # local t and not account for scr refresh
                BMRQ_slider.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BMRQ_slider, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BMRQ_slider.started')
                # update status
                BMRQ_slider.status = STARTED
                BMRQ_slider.setAutoDraw(True)
            
            # if BMRQ_slider is active this frame...
            if BMRQ_slider.status == STARTED:
                # update params
                pass
            
            # Check BMRQ_slider for response to end Routine
            if BMRQ_slider.getRating() is not None and BMRQ_slider.status == STARTED:
                continueRoutine = False
            
            # *Q42toQ61* updates
            
            # if Q42toQ61 is starting this frame...
            if Q42toQ61.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q42toQ61.frameNStart = frameN  # exact frame index
                Q42toQ61.tStart = t  # local t and not account for scr refresh
                Q42toQ61.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q42toQ61, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q42toQ61.started')
                # update status
                Q42toQ61.status = STARTED
                Q42toQ61.setAutoDraw(True)
            
            # if Q42toQ61 is active this frame...
            if Q42toQ61.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=BMRQ,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                BMRQ.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in BMRQ.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "BMRQ" ---
        for thisComponent in BMRQ.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for BMRQ
        BMRQ.tStop = globalClock.getTime(format='float')
        BMRQ.tStopRefresh = tThisFlipGlobal
        thisExp.addData('BMRQ.stopped', BMRQ.tStop)
        trials_BMRQ.addData('BMRQ_slider.response', BMRQ_slider.getRating())
        trials_BMRQ.addData('BMRQ_slider.rt', BMRQ_slider.getRT())
        # the Routine "BMRQ" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_BMRQ as finished
        if hasattr(thisTrials_BMRQ, 'status'):
            thisTrials_BMRQ.status = FINISHED
        # if awaiting a pause, pause now
        if trials_BMRQ.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_BMRQ.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_BMRQ'
    trials_BMRQ.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_BMRQ.trialList in ([], [None], None):
        params = []
    else:
        params = trials_BMRQ.trialList[0].keys()
    # save data for this loop
    trials_BMRQ.saveAsExcel(filename + '.xlsx', sheetName='trials_BMRQ',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_BMRQ.saveAsText(filename + '_trials_BMRQ.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "PAI_intro" ---
    # create an object to store info about Routine PAI_intro
    PAI_intro = data.Routine(
        name='PAI_intro',
        components=[PAI_intro_image, key_resp_8],
    )
    PAI_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_8
    key_resp_8.keys = []
    key_resp_8.rt = []
    _key_resp_8_allKeys = []
    # store start times for PAI_intro
    PAI_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    PAI_intro.tStart = globalClock.getTime(format='float')
    PAI_intro.status = STARTED
    thisExp.addData('PAI_intro.started', PAI_intro.tStart)
    PAI_intro.maxDuration = None
    # keep track of which components have finished
    PAI_introComponents = PAI_intro.components
    for thisComponent in PAI_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PAI_intro" ---
    PAI_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *PAI_intro_image* updates
        
        # if PAI_intro_image is starting this frame...
        if PAI_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            PAI_intro_image.frameNStart = frameN  # exact frame index
            PAI_intro_image.tStart = t  # local t and not account for scr refresh
            PAI_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(PAI_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'PAI_intro_image.started')
            # update status
            PAI_intro_image.status = STARTED
            PAI_intro_image.setAutoDraw(True)
        
        # if PAI_intro_image is active this frame...
        if PAI_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_8* updates
        waitOnFlip = False
        
        # if key_resp_8 is starting this frame...
        if key_resp_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_8.frameNStart = frameN  # exact frame index
            key_resp_8.tStart = t  # local t and not account for scr refresh
            key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_8.started')
            # update status
            key_resp_8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_8.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_8_allKeys.extend(theseKeys)
            if len(_key_resp_8_allKeys):
                key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
                key_resp_8.rt = _key_resp_8_allKeys[-1].rt
                key_resp_8.duration = _key_resp_8_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=PAI_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            PAI_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PAI_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PAI_intro" ---
    for thisComponent in PAI_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for PAI_intro
    PAI_intro.tStop = globalClock.getTime(format='float')
    PAI_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('PAI_intro.stopped', PAI_intro.tStop)
    # check responses
    if key_resp_8.keys in ['', [], None]:  # No response was made
        key_resp_8.keys = None
    thisExp.addData('key_resp_8.keys',key_resp_8.keys)
    if key_resp_8.keys != None:  # we had a response
        thisExp.addData('key_resp_8.rt', key_resp_8.rt)
        thisExp.addData('key_resp_8.duration', key_resp_8.duration)
    thisExp.nextEntry()
    # the Routine "PAI_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_PAI = data.TrialHandler2(
        name='trials_PAI',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('PAI.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_PAI)  # add the loop to the experiment
    thisTrials_PAI = trials_PAI.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_PAI.rgb)
    if thisTrials_PAI != None:
        for paramName in thisTrials_PAI:
            globals()[paramName] = thisTrials_PAI[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_PAI in trials_PAI:
        trials_PAI.status = STARTED
        if hasattr(thisTrials_PAI, 'status'):
            thisTrials_PAI.status = STARTED
        currentLoop = trials_PAI
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_PAI.rgb)
        if thisTrials_PAI != None:
            for paramName in thisTrials_PAI:
                globals()[paramName] = thisTrials_PAI[paramName]
        
        # --- Prepare to start Routine "PAI" ---
        # create an object to store info about Routine PAI
        PAI = data.Routine(
            name='PAI',
            components=[PAI_questionText, PAIquestionslide, Q62toQ65],
        )
        PAI.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        PAI_questionText.setText(PAIqText)
        PAIquestionslide.reset()
        Q62toQ65.setText(PAIqIndex)
        # store start times for PAI
        PAI.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        PAI.tStart = globalClock.getTime(format='float')
        PAI.status = STARTED
        thisExp.addData('PAI.started', PAI.tStart)
        PAI.maxDuration = None
        # keep track of which components have finished
        PAIComponents = PAI.components
        for thisComponent in PAI.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "PAI" ---
        PAI.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_PAI, 'status') and thisTrials_PAI.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *PAI_questionText* updates
            
            # if PAI_questionText is starting this frame...
            if PAI_questionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                PAI_questionText.frameNStart = frameN  # exact frame index
                PAI_questionText.tStart = t  # local t and not account for scr refresh
                PAI_questionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(PAI_questionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'PAI_questionText.started')
                # update status
                PAI_questionText.status = STARTED
                PAI_questionText.setAutoDraw(True)
            
            # if PAI_questionText is active this frame...
            if PAI_questionText.status == STARTED:
                # update params
                pass
            
            # *PAIquestionslide* updates
            
            # if PAIquestionslide is starting this frame...
            if PAIquestionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                PAIquestionslide.frameNStart = frameN  # exact frame index
                PAIquestionslide.tStart = t  # local t and not account for scr refresh
                PAIquestionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(PAIquestionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'PAIquestionslide.started')
                # update status
                PAIquestionslide.status = STARTED
                PAIquestionslide.setAutoDraw(True)
            
            # if PAIquestionslide is active this frame...
            if PAIquestionslide.status == STARTED:
                # update params
                pass
            
            # Check PAIquestionslide for response to end Routine
            if PAIquestionslide.getRating() is not None and PAIquestionslide.status == STARTED:
                continueRoutine = False
            
            # *Q62toQ65* updates
            
            # if Q62toQ65 is starting this frame...
            if Q62toQ65.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q62toQ65.frameNStart = frameN  # exact frame index
                Q62toQ65.tStart = t  # local t and not account for scr refresh
                Q62toQ65.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q62toQ65, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q62toQ65.started')
                # update status
                Q62toQ65.status = STARTED
                Q62toQ65.setAutoDraw(True)
            
            # if Q62toQ65 is active this frame...
            if Q62toQ65.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=PAI,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                PAI.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in PAI.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "PAI" ---
        for thisComponent in PAI.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for PAI
        PAI.tStop = globalClock.getTime(format='float')
        PAI.tStopRefresh = tThisFlipGlobal
        thisExp.addData('PAI.stopped', PAI.tStop)
        trials_PAI.addData('PAIquestionslide.response', PAIquestionslide.getRating())
        trials_PAI.addData('PAIquestionslide.rt', PAIquestionslide.getRT())
        # the Routine "PAI" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_PAI as finished
        if hasattr(thisTrials_PAI, 'status'):
            thisTrials_PAI.status = FINISHED
        # if awaiting a pause, pause now
        if trials_PAI.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_PAI.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_PAI'
    trials_PAI.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_PAI.trialList in ([], [None], None):
        params = []
    else:
        params = trials_PAI.trialList[0].keys()
    # save data for this loop
    trials_PAI.saveAsExcel(filename + '.xlsx', sheetName='trials_PAI',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_PAI.saveAsText(filename + '_trials_PAI.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "SOI_intro" ---
    # create an object to store info about Routine SOI_intro
    SOI_intro = data.Routine(
        name='SOI_intro',
        components=[SOI_intro_image, key_resp_12],
    )
    SOI_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_12
    key_resp_12.keys = []
    key_resp_12.rt = []
    _key_resp_12_allKeys = []
    # store start times for SOI_intro
    SOI_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SOI_intro.tStart = globalClock.getTime(format='float')
    SOI_intro.status = STARTED
    thisExp.addData('SOI_intro.started', SOI_intro.tStart)
    SOI_intro.maxDuration = None
    # keep track of which components have finished
    SOI_introComponents = SOI_intro.components
    for thisComponent in SOI_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SOI_intro" ---
    SOI_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *SOI_intro_image* updates
        
        # if SOI_intro_image is starting this frame...
        if SOI_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            SOI_intro_image.frameNStart = frameN  # exact frame index
            SOI_intro_image.tStart = t  # local t and not account for scr refresh
            SOI_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI_intro_image.started')
            # update status
            SOI_intro_image.status = STARTED
            SOI_intro_image.setAutoDraw(True)
        
        # if SOI_intro_image is active this frame...
        if SOI_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_12* updates
        waitOnFlip = False
        
        # if key_resp_12 is starting this frame...
        if key_resp_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_12.frameNStart = frameN  # exact frame index
            key_resp_12.tStart = t  # local t and not account for scr refresh
            key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_12.started')
            # update status
            key_resp_12.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_12.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_12.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_12_allKeys.extend(theseKeys)
            if len(_key_resp_12_allKeys):
                key_resp_12.keys = _key_resp_12_allKeys[-1].name  # just the last key pressed
                key_resp_12.rt = _key_resp_12_allKeys[-1].rt
                key_resp_12.duration = _key_resp_12_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=SOI_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SOI_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SOI_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SOI_intro" ---
    for thisComponent in SOI_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SOI_intro
    SOI_intro.tStop = globalClock.getTime(format='float')
    SOI_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SOI_intro.stopped', SOI_intro.tStop)
    # check responses
    if key_resp_12.keys in ['', [], None]:  # No response was made
        key_resp_12.keys = None
    thisExp.addData('key_resp_12.keys',key_resp_12.keys)
    if key_resp_12.keys != None:  # we had a response
        thisExp.addData('key_resp_12.rt', key_resp_12.rt)
        thisExp.addData('key_resp_12.duration', key_resp_12.duration)
    thisExp.nextEntry()
    # the Routine "SOI_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_SOI123 = data.TrialHandler2(
        name='trials_SOI123',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('SOI123.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_SOI123)  # add the loop to the experiment
    thisTrials_SOI123 = trials_SOI123.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_SOI123.rgb)
    if thisTrials_SOI123 != None:
        for paramName in thisTrials_SOI123:
            globals()[paramName] = thisTrials_SOI123[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_SOI123 in trials_SOI123:
        trials_SOI123.status = STARTED
        if hasattr(thisTrials_SOI123, 'status'):
            thisTrials_SOI123.status = STARTED
        currentLoop = trials_SOI123
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_SOI123.rgb)
        if thisTrials_SOI123 != None:
            for paramName in thisTrials_SOI123:
                globals()[paramName] = thisTrials_SOI123[paramName]
        
        # --- Prepare to start Routine "Soi123" ---
        # create an object to store info about Routine Soi123
        Soi123 = data.Routine(
            name='Soi123',
            components=[Q_Soi123, SOI123_slide, Q66toQ68, text_3],
        )
        Soi123.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        Q_Soi123.setText(SOI123qText)
        SOI123_slide.reset()
        Q66toQ68.setText(SOI123qIndex)
        # store start times for Soi123
        Soi123.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        Soi123.tStart = globalClock.getTime(format='float')
        Soi123.status = STARTED
        thisExp.addData('Soi123.started', Soi123.tStart)
        Soi123.maxDuration = None
        # keep track of which components have finished
        Soi123Components = Soi123.components
        for thisComponent in Soi123.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "Soi123" ---
        Soi123.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_SOI123, 'status') and thisTrials_SOI123.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *Q_Soi123* updates
            
            # if Q_Soi123 is starting this frame...
            if Q_Soi123.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q_Soi123.frameNStart = frameN  # exact frame index
                Q_Soi123.tStart = t  # local t and not account for scr refresh
                Q_Soi123.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q_Soi123, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q_Soi123.started')
                # update status
                Q_Soi123.status = STARTED
                Q_Soi123.setAutoDraw(True)
            
            # if Q_Soi123 is active this frame...
            if Q_Soi123.status == STARTED:
                # update params
                pass
            
            # *SOI123_slide* updates
            
            # if SOI123_slide is starting this frame...
            if SOI123_slide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                SOI123_slide.frameNStart = frameN  # exact frame index
                SOI123_slide.tStart = t  # local t and not account for scr refresh
                SOI123_slide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(SOI123_slide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'SOI123_slide.started')
                # update status
                SOI123_slide.status = STARTED
                SOI123_slide.setAutoDraw(True)
            
            # if SOI123_slide is active this frame...
            if SOI123_slide.status == STARTED:
                # update params
                pass
            
            # Check SOI123_slide for response to end Routine
            if SOI123_slide.getRating() is not None and SOI123_slide.status == STARTED:
                continueRoutine = False
            
            # *Q66toQ68* updates
            
            # if Q66toQ68 is starting this frame...
            if Q66toQ68.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q66toQ68.frameNStart = frameN  # exact frame index
                Q66toQ68.tStart = t  # local t and not account for scr refresh
                Q66toQ68.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q66toQ68, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q66toQ68.started')
                # update status
                Q66toQ68.status = STARTED
                Q66toQ68.setAutoDraw(True)
            
            # if Q66toQ68 is active this frame...
            if Q66toQ68.status == STARTED:
                # update params
                pass
            
            # *text_3* updates
            
            # if text_3 is starting this frame...
            if text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_3.frameNStart = frameN  # exact frame index
                text_3.tStart = t  # local t and not account for scr refresh
                text_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_3.started')
                # update status
                text_3.status = STARTED
                text_3.setAutoDraw(True)
            
            # if text_3 is active this frame...
            if text_3.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=Soi123,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                Soi123.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in Soi123.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "Soi123" ---
        for thisComponent in Soi123.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for Soi123
        Soi123.tStop = globalClock.getTime(format='float')
        Soi123.tStopRefresh = tThisFlipGlobal
        thisExp.addData('Soi123.stopped', Soi123.tStop)
        trials_SOI123.addData('SOI123_slide.response', SOI123_slide.getRating())
        trials_SOI123.addData('SOI123_slide.rt', SOI123_slide.getRT())
        # the Routine "Soi123" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_SOI123 as finished
        if hasattr(thisTrials_SOI123, 'status'):
            thisTrials_SOI123.status = FINISHED
        # if awaiting a pause, pause now
        if trials_SOI123.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_SOI123.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_SOI123'
    trials_SOI123.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_SOI123.trialList in ([], [None], None):
        params = []
    else:
        params = trials_SOI123.trialList[0].keys()
    # save data for this loop
    trials_SOI123.saveAsExcel(filename + '.xlsx', sheetName='trials_SOI123',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_SOI123.saveAsText(filename + '_trials_SOI123.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # set up handler to look after randomisation of conditions etc
    trials_SOI456 = data.TrialHandler2(
        name='trials_SOI456',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('SOI456.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_SOI456)  # add the loop to the experiment
    thisTrials_SOI456 = trials_SOI456.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_SOI456.rgb)
    if thisTrials_SOI456 != None:
        for paramName in thisTrials_SOI456:
            globals()[paramName] = thisTrials_SOI456[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_SOI456 in trials_SOI456:
        trials_SOI456.status = STARTED
        if hasattr(thisTrials_SOI456, 'status'):
            thisTrials_SOI456.status = STARTED
        currentLoop = trials_SOI456
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_SOI456.rgb)
        if thisTrials_SOI456 != None:
            for paramName in thisTrials_SOI456:
                globals()[paramName] = thisTrials_SOI456[paramName]
        
        # --- Prepare to start Routine "Soi456" ---
        # create an object to store info about Routine Soi456
        Soi456 = data.Routine(
            name='Soi456',
            components=[Q_Soi456, SOI456_Slide, Q69toQ71, text_4],
        )
        Soi456.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        Q_Soi456.setText(SOI456qText)
        SOI456_Slide.reset()
        Q69toQ71.setText(SOI456qIndex)
        # store start times for Soi456
        Soi456.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        Soi456.tStart = globalClock.getTime(format='float')
        Soi456.status = STARTED
        thisExp.addData('Soi456.started', Soi456.tStart)
        Soi456.maxDuration = None
        # keep track of which components have finished
        Soi456Components = Soi456.components
        for thisComponent in Soi456.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "Soi456" ---
        Soi456.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_SOI456, 'status') and thisTrials_SOI456.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *Q_Soi456* updates
            
            # if Q_Soi456 is starting this frame...
            if Q_Soi456.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q_Soi456.frameNStart = frameN  # exact frame index
                Q_Soi456.tStart = t  # local t and not account for scr refresh
                Q_Soi456.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q_Soi456, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q_Soi456.started')
                # update status
                Q_Soi456.status = STARTED
                Q_Soi456.setAutoDraw(True)
            
            # if Q_Soi456 is active this frame...
            if Q_Soi456.status == STARTED:
                # update params
                pass
            
            # *SOI456_Slide* updates
            
            # if SOI456_Slide is starting this frame...
            if SOI456_Slide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                SOI456_Slide.frameNStart = frameN  # exact frame index
                SOI456_Slide.tStart = t  # local t and not account for scr refresh
                SOI456_Slide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(SOI456_Slide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'SOI456_Slide.started')
                # update status
                SOI456_Slide.status = STARTED
                SOI456_Slide.setAutoDraw(True)
            
            # if SOI456_Slide is active this frame...
            if SOI456_Slide.status == STARTED:
                # update params
                pass
            
            # Check SOI456_Slide for response to end Routine
            if SOI456_Slide.getRating() is not None and SOI456_Slide.status == STARTED:
                continueRoutine = False
            
            # *Q69toQ71* updates
            
            # if Q69toQ71 is starting this frame...
            if Q69toQ71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q69toQ71.frameNStart = frameN  # exact frame index
                Q69toQ71.tStart = t  # local t and not account for scr refresh
                Q69toQ71.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q69toQ71, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q69toQ71.started')
                # update status
                Q69toQ71.status = STARTED
                Q69toQ71.setAutoDraw(True)
            
            # if Q69toQ71 is active this frame...
            if Q69toQ71.status == STARTED:
                # update params
                pass
            
            # *text_4* updates
            
            # if text_4 is starting this frame...
            if text_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_4.frameNStart = frameN  # exact frame index
                text_4.tStart = t  # local t and not account for scr refresh
                text_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_4.started')
                # update status
                text_4.status = STARTED
                text_4.setAutoDraw(True)
            
            # if text_4 is active this frame...
            if text_4.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=Soi456,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                Soi456.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in Soi456.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "Soi456" ---
        for thisComponent in Soi456.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for Soi456
        Soi456.tStop = globalClock.getTime(format='float')
        Soi456.tStopRefresh = tThisFlipGlobal
        thisExp.addData('Soi456.stopped', Soi456.tStop)
        trials_SOI456.addData('SOI456_Slide.response', SOI456_Slide.getRating())
        trials_SOI456.addData('SOI456_Slide.rt', SOI456_Slide.getRT())
        # the Routine "Soi456" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_SOI456 as finished
        if hasattr(thisTrials_SOI456, 'status'):
            thisTrials_SOI456.status = FINISHED
        # if awaiting a pause, pause now
        if trials_SOI456.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_SOI456.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_SOI456'
    trials_SOI456.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_SOI456.trialList in ([], [None], None):
        params = []
    else:
        params = trials_SOI456.trialList[0].keys()
    # save data for this loop
    trials_SOI456.saveAsExcel(filename + '.xlsx', sheetName='trials_SOI456',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_SOI456.saveAsText(filename + '_trials_SOI456.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "SOI7" ---
    # create an object to store info about Routine SOI7
    SOI7 = data.Routine(
        name='SOI7',
        components=[Q_SOI7, SOI7_1_never, SOI7_2_veryseldom, SOI7_3_once_every_2or3_months, SOI7_4_onceamonth, SOI7_5_once_every_two_weeks, SOI7_6_onceaweek, SOI7_7_several_times_per_week, SOI7_8_early_every_day, SOI7_9_atleastonceaday, Q72],
    )
    SOI7.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset SOI7_1_never to account for continued clicks & clear times on/off
    SOI7_1_never.reset()
    # reset SOI7_2_veryseldom to account for continued clicks & clear times on/off
    SOI7_2_veryseldom.reset()
    # reset SOI7_3_once_every_2or3_months to account for continued clicks & clear times on/off
    SOI7_3_once_every_2or3_months.reset()
    # reset SOI7_4_onceamonth to account for continued clicks & clear times on/off
    SOI7_4_onceamonth.reset()
    # reset SOI7_5_once_every_two_weeks to account for continued clicks & clear times on/off
    SOI7_5_once_every_two_weeks.reset()
    # reset SOI7_6_onceaweek to account for continued clicks & clear times on/off
    SOI7_6_onceaweek.reset()
    # reset SOI7_7_several_times_per_week to account for continued clicks & clear times on/off
    SOI7_7_several_times_per_week.reset()
    # reset SOI7_8_early_every_day to account for continued clicks & clear times on/off
    SOI7_8_early_every_day.reset()
    # reset SOI7_9_atleastonceaday to account for continued clicks & clear times on/off
    SOI7_9_atleastonceaday.reset()
    # store start times for SOI7
    SOI7.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SOI7.tStart = globalClock.getTime(format='float')
    SOI7.status = STARTED
    thisExp.addData('SOI7.started', SOI7.tStart)
    SOI7.maxDuration = None
    # keep track of which components have finished
    SOI7Components = SOI7.components
    for thisComponent in SOI7.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SOI7" ---
    SOI7.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_SOI7* updates
        
        # if Q_SOI7 is starting this frame...
        if Q_SOI7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_SOI7.frameNStart = frameN  # exact frame index
            Q_SOI7.tStart = t  # local t and not account for scr refresh
            Q_SOI7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_SOI7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_SOI7.started')
            # update status
            Q_SOI7.status = STARTED
            Q_SOI7.setAutoDraw(True)
        
        # if Q_SOI7 is active this frame...
        if Q_SOI7.status == STARTED:
            # update params
            pass
        # *SOI7_1_never* updates
        
        # if SOI7_1_never is starting this frame...
        if SOI7_1_never.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_1_never.frameNStart = frameN  # exact frame index
            SOI7_1_never.tStart = t  # local t and not account for scr refresh
            SOI7_1_never.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_1_never, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_1_never.started')
            # update status
            SOI7_1_never.status = STARTED
            win.callOnFlip(SOI7_1_never.buttonClock.reset)
            SOI7_1_never.setAutoDraw(True)
        
        # if SOI7_1_never is active this frame...
        if SOI7_1_never.status == STARTED:
            # update params
            pass
            # check whether SOI7_1_never has been pressed
            if SOI7_1_never.isClicked:
                if not SOI7_1_never.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_1_never.timesOn.append(SOI7_1_never.buttonClock.getTime())
                    SOI7_1_never.timesOff.append(SOI7_1_never.buttonClock.getTime())
                elif len(SOI7_1_never.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_1_never.timesOff[-1] = SOI7_1_never.buttonClock.getTime()
                if not SOI7_1_never.wasClicked:
                    # end routine when SOI7_1_never is clicked
                    continueRoutine = False
                if not SOI7_1_never.wasClicked:
                    # run callback code when SOI7_1_never is clicked
                    thisExp.addData('SOI7', '1')
        # take note of whether SOI7_1_never was clicked, so that next frame we know if clicks are new
        SOI7_1_never.wasClicked = SOI7_1_never.isClicked and SOI7_1_never.status == STARTED
        # *SOI7_2_veryseldom* updates
        
        # if SOI7_2_veryseldom is starting this frame...
        if SOI7_2_veryseldom.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_2_veryseldom.frameNStart = frameN  # exact frame index
            SOI7_2_veryseldom.tStart = t  # local t and not account for scr refresh
            SOI7_2_veryseldom.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_2_veryseldom, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_2_veryseldom.started')
            # update status
            SOI7_2_veryseldom.status = STARTED
            win.callOnFlip(SOI7_2_veryseldom.buttonClock.reset)
            SOI7_2_veryseldom.setAutoDraw(True)
        
        # if SOI7_2_veryseldom is active this frame...
        if SOI7_2_veryseldom.status == STARTED:
            # update params
            pass
            # check whether SOI7_2_veryseldom has been pressed
            if SOI7_2_veryseldom.isClicked:
                if not SOI7_2_veryseldom.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_2_veryseldom.timesOn.append(SOI7_2_veryseldom.buttonClock.getTime())
                    SOI7_2_veryseldom.timesOff.append(SOI7_2_veryseldom.buttonClock.getTime())
                elif len(SOI7_2_veryseldom.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_2_veryseldom.timesOff[-1] = SOI7_2_veryseldom.buttonClock.getTime()
                if not SOI7_2_veryseldom.wasClicked:
                    # end routine when SOI7_2_veryseldom is clicked
                    continueRoutine = False
                if not SOI7_2_veryseldom.wasClicked:
                    # run callback code when SOI7_2_veryseldom is clicked
                    thisExp.addData('SOI7', '2')
        # take note of whether SOI7_2_veryseldom was clicked, so that next frame we know if clicks are new
        SOI7_2_veryseldom.wasClicked = SOI7_2_veryseldom.isClicked and SOI7_2_veryseldom.status == STARTED
        # *SOI7_3_once_every_2or3_months* updates
        
        # if SOI7_3_once_every_2or3_months is starting this frame...
        if SOI7_3_once_every_2or3_months.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_3_once_every_2or3_months.frameNStart = frameN  # exact frame index
            SOI7_3_once_every_2or3_months.tStart = t  # local t and not account for scr refresh
            SOI7_3_once_every_2or3_months.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_3_once_every_2or3_months, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_3_once_every_2or3_months.started')
            # update status
            SOI7_3_once_every_2or3_months.status = STARTED
            win.callOnFlip(SOI7_3_once_every_2or3_months.buttonClock.reset)
            SOI7_3_once_every_2or3_months.setAutoDraw(True)
        
        # if SOI7_3_once_every_2or3_months is active this frame...
        if SOI7_3_once_every_2or3_months.status == STARTED:
            # update params
            pass
            # check whether SOI7_3_once_every_2or3_months has been pressed
            if SOI7_3_once_every_2or3_months.isClicked:
                if not SOI7_3_once_every_2or3_months.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_3_once_every_2or3_months.timesOn.append(SOI7_3_once_every_2or3_months.buttonClock.getTime())
                    SOI7_3_once_every_2or3_months.timesOff.append(SOI7_3_once_every_2or3_months.buttonClock.getTime())
                elif len(SOI7_3_once_every_2or3_months.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_3_once_every_2or3_months.timesOff[-1] = SOI7_3_once_every_2or3_months.buttonClock.getTime()
                if not SOI7_3_once_every_2or3_months.wasClicked:
                    # end routine when SOI7_3_once_every_2or3_months is clicked
                    continueRoutine = False
                if not SOI7_3_once_every_2or3_months.wasClicked:
                    # run callback code when SOI7_3_once_every_2or3_months is clicked
                    thisExp.addData('SOI7', '3')
                    
        # take note of whether SOI7_3_once_every_2or3_months was clicked, so that next frame we know if clicks are new
        SOI7_3_once_every_2or3_months.wasClicked = SOI7_3_once_every_2or3_months.isClicked and SOI7_3_once_every_2or3_months.status == STARTED
        # *SOI7_4_onceamonth* updates
        
        # if SOI7_4_onceamonth is starting this frame...
        if SOI7_4_onceamonth.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_4_onceamonth.frameNStart = frameN  # exact frame index
            SOI7_4_onceamonth.tStart = t  # local t and not account for scr refresh
            SOI7_4_onceamonth.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_4_onceamonth, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_4_onceamonth.started')
            # update status
            SOI7_4_onceamonth.status = STARTED
            win.callOnFlip(SOI7_4_onceamonth.buttonClock.reset)
            SOI7_4_onceamonth.setAutoDraw(True)
        
        # if SOI7_4_onceamonth is active this frame...
        if SOI7_4_onceamonth.status == STARTED:
            # update params
            pass
            # check whether SOI7_4_onceamonth has been pressed
            if SOI7_4_onceamonth.isClicked:
                if not SOI7_4_onceamonth.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_4_onceamonth.timesOn.append(SOI7_4_onceamonth.buttonClock.getTime())
                    SOI7_4_onceamonth.timesOff.append(SOI7_4_onceamonth.buttonClock.getTime())
                elif len(SOI7_4_onceamonth.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_4_onceamonth.timesOff[-1] = SOI7_4_onceamonth.buttonClock.getTime()
                if not SOI7_4_onceamonth.wasClicked:
                    # end routine when SOI7_4_onceamonth is clicked
                    continueRoutine = False
                if not SOI7_4_onceamonth.wasClicked:
                    # run callback code when SOI7_4_onceamonth is clicked
                    thisExp.addData('SOI7', '4')
        # take note of whether SOI7_4_onceamonth was clicked, so that next frame we know if clicks are new
        SOI7_4_onceamonth.wasClicked = SOI7_4_onceamonth.isClicked and SOI7_4_onceamonth.status == STARTED
        # *SOI7_5_once_every_two_weeks* updates
        
        # if SOI7_5_once_every_two_weeks is starting this frame...
        if SOI7_5_once_every_two_weeks.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_5_once_every_two_weeks.frameNStart = frameN  # exact frame index
            SOI7_5_once_every_two_weeks.tStart = t  # local t and not account for scr refresh
            SOI7_5_once_every_two_weeks.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_5_once_every_two_weeks, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_5_once_every_two_weeks.started')
            # update status
            SOI7_5_once_every_two_weeks.status = STARTED
            win.callOnFlip(SOI7_5_once_every_two_weeks.buttonClock.reset)
            SOI7_5_once_every_two_weeks.setAutoDraw(True)
        
        # if SOI7_5_once_every_two_weeks is active this frame...
        if SOI7_5_once_every_two_weeks.status == STARTED:
            # update params
            pass
            # check whether SOI7_5_once_every_two_weeks has been pressed
            if SOI7_5_once_every_two_weeks.isClicked:
                if not SOI7_5_once_every_two_weeks.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_5_once_every_two_weeks.timesOn.append(SOI7_5_once_every_two_weeks.buttonClock.getTime())
                    SOI7_5_once_every_two_weeks.timesOff.append(SOI7_5_once_every_two_weeks.buttonClock.getTime())
                elif len(SOI7_5_once_every_two_weeks.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_5_once_every_two_weeks.timesOff[-1] = SOI7_5_once_every_two_weeks.buttonClock.getTime()
                if not SOI7_5_once_every_two_weeks.wasClicked:
                    # end routine when SOI7_5_once_every_two_weeks is clicked
                    continueRoutine = False
                if not SOI7_5_once_every_two_weeks.wasClicked:
                    # run callback code when SOI7_5_once_every_two_weeks is clicked
                    thisExp.addData('SOI7', '5')
        # take note of whether SOI7_5_once_every_two_weeks was clicked, so that next frame we know if clicks are new
        SOI7_5_once_every_two_weeks.wasClicked = SOI7_5_once_every_two_weeks.isClicked and SOI7_5_once_every_two_weeks.status == STARTED
        # *SOI7_6_onceaweek* updates
        
        # if SOI7_6_onceaweek is starting this frame...
        if SOI7_6_onceaweek.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_6_onceaweek.frameNStart = frameN  # exact frame index
            SOI7_6_onceaweek.tStart = t  # local t and not account for scr refresh
            SOI7_6_onceaweek.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_6_onceaweek, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_6_onceaweek.started')
            # update status
            SOI7_6_onceaweek.status = STARTED
            win.callOnFlip(SOI7_6_onceaweek.buttonClock.reset)
            SOI7_6_onceaweek.setAutoDraw(True)
        
        # if SOI7_6_onceaweek is active this frame...
        if SOI7_6_onceaweek.status == STARTED:
            # update params
            pass
            # check whether SOI7_6_onceaweek has been pressed
            if SOI7_6_onceaweek.isClicked:
                if not SOI7_6_onceaweek.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_6_onceaweek.timesOn.append(SOI7_6_onceaweek.buttonClock.getTime())
                    SOI7_6_onceaweek.timesOff.append(SOI7_6_onceaweek.buttonClock.getTime())
                elif len(SOI7_6_onceaweek.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_6_onceaweek.timesOff[-1] = SOI7_6_onceaweek.buttonClock.getTime()
                if not SOI7_6_onceaweek.wasClicked:
                    # end routine when SOI7_6_onceaweek is clicked
                    continueRoutine = False
                if not SOI7_6_onceaweek.wasClicked:
                    # run callback code when SOI7_6_onceaweek is clicked
                    thisExp.addData('SOI7', '6')
        # take note of whether SOI7_6_onceaweek was clicked, so that next frame we know if clicks are new
        SOI7_6_onceaweek.wasClicked = SOI7_6_onceaweek.isClicked and SOI7_6_onceaweek.status == STARTED
        # *SOI7_7_several_times_per_week* updates
        
        # if SOI7_7_several_times_per_week is starting this frame...
        if SOI7_7_several_times_per_week.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_7_several_times_per_week.frameNStart = frameN  # exact frame index
            SOI7_7_several_times_per_week.tStart = t  # local t and not account for scr refresh
            SOI7_7_several_times_per_week.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_7_several_times_per_week, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_7_several_times_per_week.started')
            # update status
            SOI7_7_several_times_per_week.status = STARTED
            win.callOnFlip(SOI7_7_several_times_per_week.buttonClock.reset)
            SOI7_7_several_times_per_week.setAutoDraw(True)
        
        # if SOI7_7_several_times_per_week is active this frame...
        if SOI7_7_several_times_per_week.status == STARTED:
            # update params
            pass
            # check whether SOI7_7_several_times_per_week has been pressed
            if SOI7_7_several_times_per_week.isClicked:
                if not SOI7_7_several_times_per_week.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_7_several_times_per_week.timesOn.append(SOI7_7_several_times_per_week.buttonClock.getTime())
                    SOI7_7_several_times_per_week.timesOff.append(SOI7_7_several_times_per_week.buttonClock.getTime())
                elif len(SOI7_7_several_times_per_week.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_7_several_times_per_week.timesOff[-1] = SOI7_7_several_times_per_week.buttonClock.getTime()
                if not SOI7_7_several_times_per_week.wasClicked:
                    # end routine when SOI7_7_several_times_per_week is clicked
                    continueRoutine = False
                if not SOI7_7_several_times_per_week.wasClicked:
                    # run callback code when SOI7_7_several_times_per_week is clicked
                    thisExp.addData('SOI7', '7')
        # take note of whether SOI7_7_several_times_per_week was clicked, so that next frame we know if clicks are new
        SOI7_7_several_times_per_week.wasClicked = SOI7_7_several_times_per_week.isClicked and SOI7_7_several_times_per_week.status == STARTED
        # *SOI7_8_early_every_day* updates
        
        # if SOI7_8_early_every_day is starting this frame...
        if SOI7_8_early_every_day.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_8_early_every_day.frameNStart = frameN  # exact frame index
            SOI7_8_early_every_day.tStart = t  # local t and not account for scr refresh
            SOI7_8_early_every_day.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_8_early_every_day, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_8_early_every_day.started')
            # update status
            SOI7_8_early_every_day.status = STARTED
            win.callOnFlip(SOI7_8_early_every_day.buttonClock.reset)
            SOI7_8_early_every_day.setAutoDraw(True)
        
        # if SOI7_8_early_every_day is active this frame...
        if SOI7_8_early_every_day.status == STARTED:
            # update params
            pass
            # check whether SOI7_8_early_every_day has been pressed
            if SOI7_8_early_every_day.isClicked:
                if not SOI7_8_early_every_day.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_8_early_every_day.timesOn.append(SOI7_8_early_every_day.buttonClock.getTime())
                    SOI7_8_early_every_day.timesOff.append(SOI7_8_early_every_day.buttonClock.getTime())
                elif len(SOI7_8_early_every_day.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_8_early_every_day.timesOff[-1] = SOI7_8_early_every_day.buttonClock.getTime()
                if not SOI7_8_early_every_day.wasClicked:
                    # end routine when SOI7_8_early_every_day is clicked
                    continueRoutine = False
                if not SOI7_8_early_every_day.wasClicked:
                    # run callback code when SOI7_8_early_every_day is clicked
                    thisExp.addData('SOI7', '8')
        # take note of whether SOI7_8_early_every_day was clicked, so that next frame we know if clicks are new
        SOI7_8_early_every_day.wasClicked = SOI7_8_early_every_day.isClicked and SOI7_8_early_every_day.status == STARTED
        # *SOI7_9_atleastonceaday* updates
        
        # if SOI7_9_atleastonceaday is starting this frame...
        if SOI7_9_atleastonceaday.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI7_9_atleastonceaday.frameNStart = frameN  # exact frame index
            SOI7_9_atleastonceaday.tStart = t  # local t and not account for scr refresh
            SOI7_9_atleastonceaday.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI7_9_atleastonceaday, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI7_9_atleastonceaday.started')
            # update status
            SOI7_9_atleastonceaday.status = STARTED
            win.callOnFlip(SOI7_9_atleastonceaday.buttonClock.reset)
            SOI7_9_atleastonceaday.setAutoDraw(True)
        
        # if SOI7_9_atleastonceaday is active this frame...
        if SOI7_9_atleastonceaday.status == STARTED:
            # update params
            pass
            # check whether SOI7_9_atleastonceaday has been pressed
            if SOI7_9_atleastonceaday.isClicked:
                if not SOI7_9_atleastonceaday.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI7_9_atleastonceaday.timesOn.append(SOI7_9_atleastonceaday.buttonClock.getTime())
                    SOI7_9_atleastonceaday.timesOff.append(SOI7_9_atleastonceaday.buttonClock.getTime())
                elif len(SOI7_9_atleastonceaday.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI7_9_atleastonceaday.timesOff[-1] = SOI7_9_atleastonceaday.buttonClock.getTime()
                if not SOI7_9_atleastonceaday.wasClicked:
                    # end routine when SOI7_9_atleastonceaday is clicked
                    continueRoutine = False
                if not SOI7_9_atleastonceaday.wasClicked:
                    # run callback code when SOI7_9_atleastonceaday is clicked
                    thisExp.addData('SOI7', '99')
        # take note of whether SOI7_9_atleastonceaday was clicked, so that next frame we know if clicks are new
        SOI7_9_atleastonceaday.wasClicked = SOI7_9_atleastonceaday.isClicked and SOI7_9_atleastonceaday.status == STARTED
        
        # *Q72* updates
        
        # if Q72 is starting this frame...
        if Q72.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q72.frameNStart = frameN  # exact frame index
            Q72.tStart = t  # local t and not account for scr refresh
            Q72.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q72, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q72.started')
            # update status
            Q72.status = STARTED
            Q72.setAutoDraw(True)
        
        # if Q72 is active this frame...
        if Q72.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=SOI7,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SOI7.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SOI7.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SOI7" ---
    for thisComponent in SOI7.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SOI7
    SOI7.tStop = globalClock.getTime(format='float')
    SOI7.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SOI7.stopped', SOI7.tStop)
    thisExp.addData('SOI7_1_never.numClicks', SOI7_1_never.numClicks)
    if SOI7_1_never.numClicks:
       thisExp.addData('SOI7_1_never.timesOn', SOI7_1_never.timesOn)
       thisExp.addData('SOI7_1_never.timesOff', SOI7_1_never.timesOff)
    else:
       thisExp.addData('SOI7_1_never.timesOn', "")
       thisExp.addData('SOI7_1_never.timesOff', "")
    thisExp.addData('SOI7_2_veryseldom.numClicks', SOI7_2_veryseldom.numClicks)
    if SOI7_2_veryseldom.numClicks:
       thisExp.addData('SOI7_2_veryseldom.timesOn', SOI7_2_veryseldom.timesOn)
       thisExp.addData('SOI7_2_veryseldom.timesOff', SOI7_2_veryseldom.timesOff)
    else:
       thisExp.addData('SOI7_2_veryseldom.timesOn', "")
       thisExp.addData('SOI7_2_veryseldom.timesOff', "")
    thisExp.addData('SOI7_3_once_every_2or3_months.numClicks', SOI7_3_once_every_2or3_months.numClicks)
    if SOI7_3_once_every_2or3_months.numClicks:
       thisExp.addData('SOI7_3_once_every_2or3_months.timesOn', SOI7_3_once_every_2or3_months.timesOn)
       thisExp.addData('SOI7_3_once_every_2or3_months.timesOff', SOI7_3_once_every_2or3_months.timesOff)
    else:
       thisExp.addData('SOI7_3_once_every_2or3_months.timesOn', "")
       thisExp.addData('SOI7_3_once_every_2or3_months.timesOff', "")
    thisExp.addData('SOI7_4_onceamonth.numClicks', SOI7_4_onceamonth.numClicks)
    if SOI7_4_onceamonth.numClicks:
       thisExp.addData('SOI7_4_onceamonth.timesOn', SOI7_4_onceamonth.timesOn)
       thisExp.addData('SOI7_4_onceamonth.timesOff', SOI7_4_onceamonth.timesOff)
    else:
       thisExp.addData('SOI7_4_onceamonth.timesOn', "")
       thisExp.addData('SOI7_4_onceamonth.timesOff', "")
    thisExp.addData('SOI7_5_once_every_two_weeks.numClicks', SOI7_5_once_every_two_weeks.numClicks)
    if SOI7_5_once_every_two_weeks.numClicks:
       thisExp.addData('SOI7_5_once_every_two_weeks.timesOn', SOI7_5_once_every_two_weeks.timesOn)
       thisExp.addData('SOI7_5_once_every_two_weeks.timesOff', SOI7_5_once_every_two_weeks.timesOff)
    else:
       thisExp.addData('SOI7_5_once_every_two_weeks.timesOn', "")
       thisExp.addData('SOI7_5_once_every_two_weeks.timesOff', "")
    thisExp.addData('SOI7_6_onceaweek.numClicks', SOI7_6_onceaweek.numClicks)
    if SOI7_6_onceaweek.numClicks:
       thisExp.addData('SOI7_6_onceaweek.timesOn', SOI7_6_onceaweek.timesOn)
       thisExp.addData('SOI7_6_onceaweek.timesOff', SOI7_6_onceaweek.timesOff)
    else:
       thisExp.addData('SOI7_6_onceaweek.timesOn', "")
       thisExp.addData('SOI7_6_onceaweek.timesOff', "")
    thisExp.addData('SOI7_7_several_times_per_week.numClicks', SOI7_7_several_times_per_week.numClicks)
    if SOI7_7_several_times_per_week.numClicks:
       thisExp.addData('SOI7_7_several_times_per_week.timesOn', SOI7_7_several_times_per_week.timesOn)
       thisExp.addData('SOI7_7_several_times_per_week.timesOff', SOI7_7_several_times_per_week.timesOff)
    else:
       thisExp.addData('SOI7_7_several_times_per_week.timesOn', "")
       thisExp.addData('SOI7_7_several_times_per_week.timesOff', "")
    thisExp.addData('SOI7_8_early_every_day.numClicks', SOI7_8_early_every_day.numClicks)
    if SOI7_8_early_every_day.numClicks:
       thisExp.addData('SOI7_8_early_every_day.timesOn', SOI7_8_early_every_day.timesOn)
       thisExp.addData('SOI7_8_early_every_day.timesOff', SOI7_8_early_every_day.timesOff)
    else:
       thisExp.addData('SOI7_8_early_every_day.timesOn', "")
       thisExp.addData('SOI7_8_early_every_day.timesOff', "")
    thisExp.addData('SOI7_9_atleastonceaday.numClicks', SOI7_9_atleastonceaday.numClicks)
    if SOI7_9_atleastonceaday.numClicks:
       thisExp.addData('SOI7_9_atleastonceaday.timesOn', SOI7_9_atleastonceaday.timesOn)
       thisExp.addData('SOI7_9_atleastonceaday.timesOff', SOI7_9_atleastonceaday.timesOff)
    else:
       thisExp.addData('SOI7_9_atleastonceaday.timesOn', "")
       thisExp.addData('SOI7_9_atleastonceaday.timesOff', "")
    thisExp.nextEntry()
    # the Routine "SOI7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SOI8" ---
    # create an object to store info about Routine SOI8
    SOI8 = data.Routine(
        name='SOI8',
        components=[Q_SOI8, SOI8_1_never, SOI8_2_veryseldom, SOI8_3_once_every_2or3_months, SOI8_4_onceamonth, SOI8_5_once_every_two_weeks, SOI8_6_onceaweek, SOI8_7_several_times_per_week, SOI8_8_early_every_day, SOI8_9_atleastonceaday, Q73],
    )
    SOI8.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset SOI8_1_never to account for continued clicks & clear times on/off
    SOI8_1_never.reset()
    # reset SOI8_2_veryseldom to account for continued clicks & clear times on/off
    SOI8_2_veryseldom.reset()
    # reset SOI8_3_once_every_2or3_months to account for continued clicks & clear times on/off
    SOI8_3_once_every_2or3_months.reset()
    # reset SOI8_4_onceamonth to account for continued clicks & clear times on/off
    SOI8_4_onceamonth.reset()
    # reset SOI8_5_once_every_two_weeks to account for continued clicks & clear times on/off
    SOI8_5_once_every_two_weeks.reset()
    # reset SOI8_6_onceaweek to account for continued clicks & clear times on/off
    SOI8_6_onceaweek.reset()
    # reset SOI8_7_several_times_per_week to account for continued clicks & clear times on/off
    SOI8_7_several_times_per_week.reset()
    # reset SOI8_8_early_every_day to account for continued clicks & clear times on/off
    SOI8_8_early_every_day.reset()
    # reset SOI8_9_atleastonceaday to account for continued clicks & clear times on/off
    SOI8_9_atleastonceaday.reset()
    # store start times for SOI8
    SOI8.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SOI8.tStart = globalClock.getTime(format='float')
    SOI8.status = STARTED
    thisExp.addData('SOI8.started', SOI8.tStart)
    SOI8.maxDuration = None
    # keep track of which components have finished
    SOI8Components = SOI8.components
    for thisComponent in SOI8.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SOI8" ---
    SOI8.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_SOI8* updates
        
        # if Q_SOI8 is starting this frame...
        if Q_SOI8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_SOI8.frameNStart = frameN  # exact frame index
            Q_SOI8.tStart = t  # local t and not account for scr refresh
            Q_SOI8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_SOI8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_SOI8.started')
            # update status
            Q_SOI8.status = STARTED
            Q_SOI8.setAutoDraw(True)
        
        # if Q_SOI8 is active this frame...
        if Q_SOI8.status == STARTED:
            # update params
            pass
        # *SOI8_1_never* updates
        
        # if SOI8_1_never is starting this frame...
        if SOI8_1_never.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_1_never.frameNStart = frameN  # exact frame index
            SOI8_1_never.tStart = t  # local t and not account for scr refresh
            SOI8_1_never.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_1_never, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_1_never.started')
            # update status
            SOI8_1_never.status = STARTED
            win.callOnFlip(SOI8_1_never.buttonClock.reset)
            SOI8_1_never.setAutoDraw(True)
        
        # if SOI8_1_never is active this frame...
        if SOI8_1_never.status == STARTED:
            # update params
            pass
            # check whether SOI8_1_never has been pressed
            if SOI8_1_never.isClicked:
                if not SOI8_1_never.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_1_never.timesOn.append(SOI8_1_never.buttonClock.getTime())
                    SOI8_1_never.timesOff.append(SOI8_1_never.buttonClock.getTime())
                elif len(SOI8_1_never.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_1_never.timesOff[-1] = SOI8_1_never.buttonClock.getTime()
                if not SOI8_1_never.wasClicked:
                    # end routine when SOI8_1_never is clicked
                    continueRoutine = False
                if not SOI8_1_never.wasClicked:
                    # run callback code when SOI8_1_never is clicked
                    thisExp.addData('SOI8', '1')
        # take note of whether SOI8_1_never was clicked, so that next frame we know if clicks are new
        SOI8_1_never.wasClicked = SOI8_1_never.isClicked and SOI8_1_never.status == STARTED
        # *SOI8_2_veryseldom* updates
        
        # if SOI8_2_veryseldom is starting this frame...
        if SOI8_2_veryseldom.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_2_veryseldom.frameNStart = frameN  # exact frame index
            SOI8_2_veryseldom.tStart = t  # local t and not account for scr refresh
            SOI8_2_veryseldom.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_2_veryseldom, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_2_veryseldom.started')
            # update status
            SOI8_2_veryseldom.status = STARTED
            win.callOnFlip(SOI8_2_veryseldom.buttonClock.reset)
            SOI8_2_veryseldom.setAutoDraw(True)
        
        # if SOI8_2_veryseldom is active this frame...
        if SOI8_2_veryseldom.status == STARTED:
            # update params
            pass
            # check whether SOI8_2_veryseldom has been pressed
            if SOI8_2_veryseldom.isClicked:
                if not SOI8_2_veryseldom.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_2_veryseldom.timesOn.append(SOI8_2_veryseldom.buttonClock.getTime())
                    SOI8_2_veryseldom.timesOff.append(SOI8_2_veryseldom.buttonClock.getTime())
                elif len(SOI8_2_veryseldom.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_2_veryseldom.timesOff[-1] = SOI8_2_veryseldom.buttonClock.getTime()
                if not SOI8_2_veryseldom.wasClicked:
                    # end routine when SOI8_2_veryseldom is clicked
                    continueRoutine = False
                if not SOI8_2_veryseldom.wasClicked:
                    # run callback code when SOI8_2_veryseldom is clicked
                    thisExp.addData('SOI8', '2')
        # take note of whether SOI8_2_veryseldom was clicked, so that next frame we know if clicks are new
        SOI8_2_veryseldom.wasClicked = SOI8_2_veryseldom.isClicked and SOI8_2_veryseldom.status == STARTED
        # *SOI8_3_once_every_2or3_months* updates
        
        # if SOI8_3_once_every_2or3_months is starting this frame...
        if SOI8_3_once_every_2or3_months.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_3_once_every_2or3_months.frameNStart = frameN  # exact frame index
            SOI8_3_once_every_2or3_months.tStart = t  # local t and not account for scr refresh
            SOI8_3_once_every_2or3_months.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_3_once_every_2or3_months, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_3_once_every_2or3_months.started')
            # update status
            SOI8_3_once_every_2or3_months.status = STARTED
            win.callOnFlip(SOI8_3_once_every_2or3_months.buttonClock.reset)
            SOI8_3_once_every_2or3_months.setAutoDraw(True)
        
        # if SOI8_3_once_every_2or3_months is active this frame...
        if SOI8_3_once_every_2or3_months.status == STARTED:
            # update params
            pass
            # check whether SOI8_3_once_every_2or3_months has been pressed
            if SOI8_3_once_every_2or3_months.isClicked:
                if not SOI8_3_once_every_2or3_months.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_3_once_every_2or3_months.timesOn.append(SOI8_3_once_every_2or3_months.buttonClock.getTime())
                    SOI8_3_once_every_2or3_months.timesOff.append(SOI8_3_once_every_2or3_months.buttonClock.getTime())
                elif len(SOI8_3_once_every_2or3_months.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_3_once_every_2or3_months.timesOff[-1] = SOI8_3_once_every_2or3_months.buttonClock.getTime()
                if not SOI8_3_once_every_2or3_months.wasClicked:
                    # end routine when SOI8_3_once_every_2or3_months is clicked
                    continueRoutine = False
                if not SOI8_3_once_every_2or3_months.wasClicked:
                    # run callback code when SOI8_3_once_every_2or3_months is clicked
                    thisExp.addData('SOI8', '3')
                    
        # take note of whether SOI8_3_once_every_2or3_months was clicked, so that next frame we know if clicks are new
        SOI8_3_once_every_2or3_months.wasClicked = SOI8_3_once_every_2or3_months.isClicked and SOI8_3_once_every_2or3_months.status == STARTED
        # *SOI8_4_onceamonth* updates
        
        # if SOI8_4_onceamonth is starting this frame...
        if SOI8_4_onceamonth.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_4_onceamonth.frameNStart = frameN  # exact frame index
            SOI8_4_onceamonth.tStart = t  # local t and not account for scr refresh
            SOI8_4_onceamonth.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_4_onceamonth, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_4_onceamonth.started')
            # update status
            SOI8_4_onceamonth.status = STARTED
            win.callOnFlip(SOI8_4_onceamonth.buttonClock.reset)
            SOI8_4_onceamonth.setAutoDraw(True)
        
        # if SOI8_4_onceamonth is active this frame...
        if SOI8_4_onceamonth.status == STARTED:
            # update params
            pass
            # check whether SOI8_4_onceamonth has been pressed
            if SOI8_4_onceamonth.isClicked:
                if not SOI8_4_onceamonth.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_4_onceamonth.timesOn.append(SOI8_4_onceamonth.buttonClock.getTime())
                    SOI8_4_onceamonth.timesOff.append(SOI8_4_onceamonth.buttonClock.getTime())
                elif len(SOI8_4_onceamonth.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_4_onceamonth.timesOff[-1] = SOI8_4_onceamonth.buttonClock.getTime()
                if not SOI8_4_onceamonth.wasClicked:
                    # end routine when SOI8_4_onceamonth is clicked
                    continueRoutine = False
                if not SOI8_4_onceamonth.wasClicked:
                    # run callback code when SOI8_4_onceamonth is clicked
                    thisExp.addData('SOI8', '4')
        # take note of whether SOI8_4_onceamonth was clicked, so that next frame we know if clicks are new
        SOI8_4_onceamonth.wasClicked = SOI8_4_onceamonth.isClicked and SOI8_4_onceamonth.status == STARTED
        # *SOI8_5_once_every_two_weeks* updates
        
        # if SOI8_5_once_every_two_weeks is starting this frame...
        if SOI8_5_once_every_two_weeks.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_5_once_every_two_weeks.frameNStart = frameN  # exact frame index
            SOI8_5_once_every_two_weeks.tStart = t  # local t and not account for scr refresh
            SOI8_5_once_every_two_weeks.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_5_once_every_two_weeks, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_5_once_every_two_weeks.started')
            # update status
            SOI8_5_once_every_two_weeks.status = STARTED
            win.callOnFlip(SOI8_5_once_every_two_weeks.buttonClock.reset)
            SOI8_5_once_every_two_weeks.setAutoDraw(True)
        
        # if SOI8_5_once_every_two_weeks is active this frame...
        if SOI8_5_once_every_two_weeks.status == STARTED:
            # update params
            pass
            # check whether SOI8_5_once_every_two_weeks has been pressed
            if SOI8_5_once_every_two_weeks.isClicked:
                if not SOI8_5_once_every_two_weeks.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_5_once_every_two_weeks.timesOn.append(SOI8_5_once_every_two_weeks.buttonClock.getTime())
                    SOI8_5_once_every_two_weeks.timesOff.append(SOI8_5_once_every_two_weeks.buttonClock.getTime())
                elif len(SOI8_5_once_every_two_weeks.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_5_once_every_two_weeks.timesOff[-1] = SOI8_5_once_every_two_weeks.buttonClock.getTime()
                if not SOI8_5_once_every_two_weeks.wasClicked:
                    # end routine when SOI8_5_once_every_two_weeks is clicked
                    continueRoutine = False
                if not SOI8_5_once_every_two_weeks.wasClicked:
                    # run callback code when SOI8_5_once_every_two_weeks is clicked
                    thisExp.addData('SOI8', '5')
        # take note of whether SOI8_5_once_every_two_weeks was clicked, so that next frame we know if clicks are new
        SOI8_5_once_every_two_weeks.wasClicked = SOI8_5_once_every_two_weeks.isClicked and SOI8_5_once_every_two_weeks.status == STARTED
        # *SOI8_6_onceaweek* updates
        
        # if SOI8_6_onceaweek is starting this frame...
        if SOI8_6_onceaweek.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_6_onceaweek.frameNStart = frameN  # exact frame index
            SOI8_6_onceaweek.tStart = t  # local t and not account for scr refresh
            SOI8_6_onceaweek.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_6_onceaweek, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_6_onceaweek.started')
            # update status
            SOI8_6_onceaweek.status = STARTED
            win.callOnFlip(SOI8_6_onceaweek.buttonClock.reset)
            SOI8_6_onceaweek.setAutoDraw(True)
        
        # if SOI8_6_onceaweek is active this frame...
        if SOI8_6_onceaweek.status == STARTED:
            # update params
            pass
            # check whether SOI8_6_onceaweek has been pressed
            if SOI8_6_onceaweek.isClicked:
                if not SOI8_6_onceaweek.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_6_onceaweek.timesOn.append(SOI8_6_onceaweek.buttonClock.getTime())
                    SOI8_6_onceaweek.timesOff.append(SOI8_6_onceaweek.buttonClock.getTime())
                elif len(SOI8_6_onceaweek.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_6_onceaweek.timesOff[-1] = SOI8_6_onceaweek.buttonClock.getTime()
                if not SOI8_6_onceaweek.wasClicked:
                    # end routine when SOI8_6_onceaweek is clicked
                    continueRoutine = False
                if not SOI8_6_onceaweek.wasClicked:
                    # run callback code when SOI8_6_onceaweek is clicked
                    thisExp.addData('SOI8', '6')
        # take note of whether SOI8_6_onceaweek was clicked, so that next frame we know if clicks are new
        SOI8_6_onceaweek.wasClicked = SOI8_6_onceaweek.isClicked and SOI8_6_onceaweek.status == STARTED
        # *SOI8_7_several_times_per_week* updates
        
        # if SOI8_7_several_times_per_week is starting this frame...
        if SOI8_7_several_times_per_week.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_7_several_times_per_week.frameNStart = frameN  # exact frame index
            SOI8_7_several_times_per_week.tStart = t  # local t and not account for scr refresh
            SOI8_7_several_times_per_week.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_7_several_times_per_week, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_7_several_times_per_week.started')
            # update status
            SOI8_7_several_times_per_week.status = STARTED
            win.callOnFlip(SOI8_7_several_times_per_week.buttonClock.reset)
            SOI8_7_several_times_per_week.setAutoDraw(True)
        
        # if SOI8_7_several_times_per_week is active this frame...
        if SOI8_7_several_times_per_week.status == STARTED:
            # update params
            pass
            # check whether SOI8_7_several_times_per_week has been pressed
            if SOI8_7_several_times_per_week.isClicked:
                if not SOI8_7_several_times_per_week.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_7_several_times_per_week.timesOn.append(SOI8_7_several_times_per_week.buttonClock.getTime())
                    SOI8_7_several_times_per_week.timesOff.append(SOI8_7_several_times_per_week.buttonClock.getTime())
                elif len(SOI8_7_several_times_per_week.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_7_several_times_per_week.timesOff[-1] = SOI8_7_several_times_per_week.buttonClock.getTime()
                if not SOI8_7_several_times_per_week.wasClicked:
                    # end routine when SOI8_7_several_times_per_week is clicked
                    continueRoutine = False
                if not SOI8_7_several_times_per_week.wasClicked:
                    # run callback code when SOI8_7_several_times_per_week is clicked
                    thisExp.addData('SOI8', '7')
        # take note of whether SOI8_7_several_times_per_week was clicked, so that next frame we know if clicks are new
        SOI8_7_several_times_per_week.wasClicked = SOI8_7_several_times_per_week.isClicked and SOI8_7_several_times_per_week.status == STARTED
        # *SOI8_8_early_every_day* updates
        
        # if SOI8_8_early_every_day is starting this frame...
        if SOI8_8_early_every_day.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_8_early_every_day.frameNStart = frameN  # exact frame index
            SOI8_8_early_every_day.tStart = t  # local t and not account for scr refresh
            SOI8_8_early_every_day.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_8_early_every_day, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_8_early_every_day.started')
            # update status
            SOI8_8_early_every_day.status = STARTED
            win.callOnFlip(SOI8_8_early_every_day.buttonClock.reset)
            SOI8_8_early_every_day.setAutoDraw(True)
        
        # if SOI8_8_early_every_day is active this frame...
        if SOI8_8_early_every_day.status == STARTED:
            # update params
            pass
            # check whether SOI8_8_early_every_day has been pressed
            if SOI8_8_early_every_day.isClicked:
                if not SOI8_8_early_every_day.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_8_early_every_day.timesOn.append(SOI8_8_early_every_day.buttonClock.getTime())
                    SOI8_8_early_every_day.timesOff.append(SOI8_8_early_every_day.buttonClock.getTime())
                elif len(SOI8_8_early_every_day.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_8_early_every_day.timesOff[-1] = SOI8_8_early_every_day.buttonClock.getTime()
                if not SOI8_8_early_every_day.wasClicked:
                    # end routine when SOI8_8_early_every_day is clicked
                    continueRoutine = False
                if not SOI8_8_early_every_day.wasClicked:
                    # run callback code when SOI8_8_early_every_day is clicked
                    thisExp.addData('SOI8', '8')
        # take note of whether SOI8_8_early_every_day was clicked, so that next frame we know if clicks are new
        SOI8_8_early_every_day.wasClicked = SOI8_8_early_every_day.isClicked and SOI8_8_early_every_day.status == STARTED
        # *SOI8_9_atleastonceaday* updates
        
        # if SOI8_9_atleastonceaday is starting this frame...
        if SOI8_9_atleastonceaday.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI8_9_atleastonceaday.frameNStart = frameN  # exact frame index
            SOI8_9_atleastonceaday.tStart = t  # local t and not account for scr refresh
            SOI8_9_atleastonceaday.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI8_9_atleastonceaday, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI8_9_atleastonceaday.started')
            # update status
            SOI8_9_atleastonceaday.status = STARTED
            win.callOnFlip(SOI8_9_atleastonceaday.buttonClock.reset)
            SOI8_9_atleastonceaday.setAutoDraw(True)
        
        # if SOI8_9_atleastonceaday is active this frame...
        if SOI8_9_atleastonceaday.status == STARTED:
            # update params
            pass
            # check whether SOI8_9_atleastonceaday has been pressed
            if SOI8_9_atleastonceaday.isClicked:
                if not SOI8_9_atleastonceaday.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI8_9_atleastonceaday.timesOn.append(SOI8_9_atleastonceaday.buttonClock.getTime())
                    SOI8_9_atleastonceaday.timesOff.append(SOI8_9_atleastonceaday.buttonClock.getTime())
                elif len(SOI8_9_atleastonceaday.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI8_9_atleastonceaday.timesOff[-1] = SOI8_9_atleastonceaday.buttonClock.getTime()
                if not SOI8_9_atleastonceaday.wasClicked:
                    # end routine when SOI8_9_atleastonceaday is clicked
                    continueRoutine = False
                if not SOI8_9_atleastonceaday.wasClicked:
                    # run callback code when SOI8_9_atleastonceaday is clicked
                    thisExp.addData('SOI8', '9')
        # take note of whether SOI8_9_atleastonceaday was clicked, so that next frame we know if clicks are new
        SOI8_9_atleastonceaday.wasClicked = SOI8_9_atleastonceaday.isClicked and SOI8_9_atleastonceaday.status == STARTED
        
        # *Q73* updates
        
        # if Q73 is starting this frame...
        if Q73.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q73.frameNStart = frameN  # exact frame index
            Q73.tStart = t  # local t and not account for scr refresh
            Q73.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q73, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q73.started')
            # update status
            Q73.status = STARTED
            Q73.setAutoDraw(True)
        
        # if Q73 is active this frame...
        if Q73.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=SOI8,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SOI8.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SOI8.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SOI8" ---
    for thisComponent in SOI8.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SOI8
    SOI8.tStop = globalClock.getTime(format='float')
    SOI8.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SOI8.stopped', SOI8.tStop)
    thisExp.addData('SOI8_1_never.numClicks', SOI8_1_never.numClicks)
    if SOI8_1_never.numClicks:
       thisExp.addData('SOI8_1_never.timesOn', SOI8_1_never.timesOn)
       thisExp.addData('SOI8_1_never.timesOff', SOI8_1_never.timesOff)
    else:
       thisExp.addData('SOI8_1_never.timesOn', "")
       thisExp.addData('SOI8_1_never.timesOff', "")
    thisExp.addData('SOI8_2_veryseldom.numClicks', SOI8_2_veryseldom.numClicks)
    if SOI8_2_veryseldom.numClicks:
       thisExp.addData('SOI8_2_veryseldom.timesOn', SOI8_2_veryseldom.timesOn)
       thisExp.addData('SOI8_2_veryseldom.timesOff', SOI8_2_veryseldom.timesOff)
    else:
       thisExp.addData('SOI8_2_veryseldom.timesOn', "")
       thisExp.addData('SOI8_2_veryseldom.timesOff', "")
    thisExp.addData('SOI8_3_once_every_2or3_months.numClicks', SOI8_3_once_every_2or3_months.numClicks)
    if SOI8_3_once_every_2or3_months.numClicks:
       thisExp.addData('SOI8_3_once_every_2or3_months.timesOn', SOI8_3_once_every_2or3_months.timesOn)
       thisExp.addData('SOI8_3_once_every_2or3_months.timesOff', SOI8_3_once_every_2or3_months.timesOff)
    else:
       thisExp.addData('SOI8_3_once_every_2or3_months.timesOn', "")
       thisExp.addData('SOI8_3_once_every_2or3_months.timesOff', "")
    thisExp.addData('SOI8_4_onceamonth.numClicks', SOI8_4_onceamonth.numClicks)
    if SOI8_4_onceamonth.numClicks:
       thisExp.addData('SOI8_4_onceamonth.timesOn', SOI8_4_onceamonth.timesOn)
       thisExp.addData('SOI8_4_onceamonth.timesOff', SOI8_4_onceamonth.timesOff)
    else:
       thisExp.addData('SOI8_4_onceamonth.timesOn', "")
       thisExp.addData('SOI8_4_onceamonth.timesOff', "")
    thisExp.addData('SOI8_5_once_every_two_weeks.numClicks', SOI8_5_once_every_two_weeks.numClicks)
    if SOI8_5_once_every_two_weeks.numClicks:
       thisExp.addData('SOI8_5_once_every_two_weeks.timesOn', SOI8_5_once_every_two_weeks.timesOn)
       thisExp.addData('SOI8_5_once_every_two_weeks.timesOff', SOI8_5_once_every_two_weeks.timesOff)
    else:
       thisExp.addData('SOI8_5_once_every_two_weeks.timesOn', "")
       thisExp.addData('SOI8_5_once_every_two_weeks.timesOff', "")
    thisExp.addData('SOI8_6_onceaweek.numClicks', SOI8_6_onceaweek.numClicks)
    if SOI8_6_onceaweek.numClicks:
       thisExp.addData('SOI8_6_onceaweek.timesOn', SOI8_6_onceaweek.timesOn)
       thisExp.addData('SOI8_6_onceaweek.timesOff', SOI8_6_onceaweek.timesOff)
    else:
       thisExp.addData('SOI8_6_onceaweek.timesOn', "")
       thisExp.addData('SOI8_6_onceaweek.timesOff', "")
    thisExp.addData('SOI8_7_several_times_per_week.numClicks', SOI8_7_several_times_per_week.numClicks)
    if SOI8_7_several_times_per_week.numClicks:
       thisExp.addData('SOI8_7_several_times_per_week.timesOn', SOI8_7_several_times_per_week.timesOn)
       thisExp.addData('SOI8_7_several_times_per_week.timesOff', SOI8_7_several_times_per_week.timesOff)
    else:
       thisExp.addData('SOI8_7_several_times_per_week.timesOn', "")
       thisExp.addData('SOI8_7_several_times_per_week.timesOff', "")
    thisExp.addData('SOI8_8_early_every_day.numClicks', SOI8_8_early_every_day.numClicks)
    if SOI8_8_early_every_day.numClicks:
       thisExp.addData('SOI8_8_early_every_day.timesOn', SOI8_8_early_every_day.timesOn)
       thisExp.addData('SOI8_8_early_every_day.timesOff', SOI8_8_early_every_day.timesOff)
    else:
       thisExp.addData('SOI8_8_early_every_day.timesOn', "")
       thisExp.addData('SOI8_8_early_every_day.timesOff', "")
    thisExp.addData('SOI8_9_atleastonceaday.numClicks', SOI8_9_atleastonceaday.numClicks)
    if SOI8_9_atleastonceaday.numClicks:
       thisExp.addData('SOI8_9_atleastonceaday.timesOn', SOI8_9_atleastonceaday.timesOn)
       thisExp.addData('SOI8_9_atleastonceaday.timesOff', SOI8_9_atleastonceaday.timesOff)
    else:
       thisExp.addData('SOI8_9_atleastonceaday.timesOn', "")
       thisExp.addData('SOI8_9_atleastonceaday.timesOff', "")
    thisExp.nextEntry()
    # the Routine "SOI8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SOI9" ---
    # create an object to store info about Routine SOI9
    SOI9 = data.Routine(
        name='SOI9',
        components=[Q_SOI9, SOI9_1_never, SOI9_2_veryseldom, SOI9_3_once_every_2or3_months, SOI9_4_onceamonth, SOI9_5_once_every_two_weeks, SOI9_6_onceaweek, SOI9_7_several_times_per_week, SOI9_8_early_every_day, SOI9_9_atleastonceaday, Q74],
    )
    SOI9.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # reset SOI9_1_never to account for continued clicks & clear times on/off
    SOI9_1_never.reset()
    # reset SOI9_2_veryseldom to account for continued clicks & clear times on/off
    SOI9_2_veryseldom.reset()
    # reset SOI9_3_once_every_2or3_months to account for continued clicks & clear times on/off
    SOI9_3_once_every_2or3_months.reset()
    # reset SOI9_4_onceamonth to account for continued clicks & clear times on/off
    SOI9_4_onceamonth.reset()
    # reset SOI9_5_once_every_two_weeks to account for continued clicks & clear times on/off
    SOI9_5_once_every_two_weeks.reset()
    # reset SOI9_6_onceaweek to account for continued clicks & clear times on/off
    SOI9_6_onceaweek.reset()
    # reset SOI9_7_several_times_per_week to account for continued clicks & clear times on/off
    SOI9_7_several_times_per_week.reset()
    # reset SOI9_8_early_every_day to account for continued clicks & clear times on/off
    SOI9_8_early_every_day.reset()
    # reset SOI9_9_atleastonceaday to account for continued clicks & clear times on/off
    SOI9_9_atleastonceaday.reset()
    # store start times for SOI9
    SOI9.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SOI9.tStart = globalClock.getTime(format='float')
    SOI9.status = STARTED
    thisExp.addData('SOI9.started', SOI9.tStart)
    SOI9.maxDuration = None
    # keep track of which components have finished
    SOI9Components = SOI9.components
    for thisComponent in SOI9.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SOI9" ---
    SOI9.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Q_SOI9* updates
        
        # if Q_SOI9 is starting this frame...
        if Q_SOI9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q_SOI9.frameNStart = frameN  # exact frame index
            Q_SOI9.tStart = t  # local t and not account for scr refresh
            Q_SOI9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q_SOI9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q_SOI9.started')
            # update status
            Q_SOI9.status = STARTED
            Q_SOI9.setAutoDraw(True)
        
        # if Q_SOI9 is active this frame...
        if Q_SOI9.status == STARTED:
            # update params
            pass
        # *SOI9_1_never* updates
        
        # if SOI9_1_never is starting this frame...
        if SOI9_1_never.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_1_never.frameNStart = frameN  # exact frame index
            SOI9_1_never.tStart = t  # local t and not account for scr refresh
            SOI9_1_never.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_1_never, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_1_never.started')
            # update status
            SOI9_1_never.status = STARTED
            win.callOnFlip(SOI9_1_never.buttonClock.reset)
            SOI9_1_never.setAutoDraw(True)
        
        # if SOI9_1_never is active this frame...
        if SOI9_1_never.status == STARTED:
            # update params
            pass
            # check whether SOI9_1_never has been pressed
            if SOI9_1_never.isClicked:
                if not SOI9_1_never.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_1_never.timesOn.append(SOI9_1_never.buttonClock.getTime())
                    SOI9_1_never.timesOff.append(SOI9_1_never.buttonClock.getTime())
                elif len(SOI9_1_never.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_1_never.timesOff[-1] = SOI9_1_never.buttonClock.getTime()
                if not SOI9_1_never.wasClicked:
                    # end routine when SOI9_1_never is clicked
                    continueRoutine = False
                if not SOI9_1_never.wasClicked:
                    # run callback code when SOI9_1_never is clicked
                    thisExp.addData('SOI9', '1')
        # take note of whether SOI9_1_never was clicked, so that next frame we know if clicks are new
        SOI9_1_never.wasClicked = SOI9_1_never.isClicked and SOI9_1_never.status == STARTED
        # *SOI9_2_veryseldom* updates
        
        # if SOI9_2_veryseldom is starting this frame...
        if SOI9_2_veryseldom.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_2_veryseldom.frameNStart = frameN  # exact frame index
            SOI9_2_veryseldom.tStart = t  # local t and not account for scr refresh
            SOI9_2_veryseldom.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_2_veryseldom, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_2_veryseldom.started')
            # update status
            SOI9_2_veryseldom.status = STARTED
            win.callOnFlip(SOI9_2_veryseldom.buttonClock.reset)
            SOI9_2_veryseldom.setAutoDraw(True)
        
        # if SOI9_2_veryseldom is active this frame...
        if SOI9_2_veryseldom.status == STARTED:
            # update params
            pass
            # check whether SOI9_2_veryseldom has been pressed
            if SOI9_2_veryseldom.isClicked:
                if not SOI9_2_veryseldom.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_2_veryseldom.timesOn.append(SOI9_2_veryseldom.buttonClock.getTime())
                    SOI9_2_veryseldom.timesOff.append(SOI9_2_veryseldom.buttonClock.getTime())
                elif len(SOI9_2_veryseldom.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_2_veryseldom.timesOff[-1] = SOI9_2_veryseldom.buttonClock.getTime()
                if not SOI9_2_veryseldom.wasClicked:
                    # end routine when SOI9_2_veryseldom is clicked
                    continueRoutine = False
                if not SOI9_2_veryseldom.wasClicked:
                    # run callback code when SOI9_2_veryseldom is clicked
                    thisExp.addData('SOI9', '2')
        # take note of whether SOI9_2_veryseldom was clicked, so that next frame we know if clicks are new
        SOI9_2_veryseldom.wasClicked = SOI9_2_veryseldom.isClicked and SOI9_2_veryseldom.status == STARTED
        # *SOI9_3_once_every_2or3_months* updates
        
        # if SOI9_3_once_every_2or3_months is starting this frame...
        if SOI9_3_once_every_2or3_months.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_3_once_every_2or3_months.frameNStart = frameN  # exact frame index
            SOI9_3_once_every_2or3_months.tStart = t  # local t and not account for scr refresh
            SOI9_3_once_every_2or3_months.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_3_once_every_2or3_months, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_3_once_every_2or3_months.started')
            # update status
            SOI9_3_once_every_2or3_months.status = STARTED
            win.callOnFlip(SOI9_3_once_every_2or3_months.buttonClock.reset)
            SOI9_3_once_every_2or3_months.setAutoDraw(True)
        
        # if SOI9_3_once_every_2or3_months is active this frame...
        if SOI9_3_once_every_2or3_months.status == STARTED:
            # update params
            pass
            # check whether SOI9_3_once_every_2or3_months has been pressed
            if SOI9_3_once_every_2or3_months.isClicked:
                if not SOI9_3_once_every_2or3_months.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_3_once_every_2or3_months.timesOn.append(SOI9_3_once_every_2or3_months.buttonClock.getTime())
                    SOI9_3_once_every_2or3_months.timesOff.append(SOI9_3_once_every_2or3_months.buttonClock.getTime())
                elif len(SOI9_3_once_every_2or3_months.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_3_once_every_2or3_months.timesOff[-1] = SOI9_3_once_every_2or3_months.buttonClock.getTime()
                if not SOI9_3_once_every_2or3_months.wasClicked:
                    # end routine when SOI9_3_once_every_2or3_months is clicked
                    continueRoutine = False
                if not SOI9_3_once_every_2or3_months.wasClicked:
                    # run callback code when SOI9_3_once_every_2or3_months is clicked
                    thisExp.addData('SOI9', '3')
        # take note of whether SOI9_3_once_every_2or3_months was clicked, so that next frame we know if clicks are new
        SOI9_3_once_every_2or3_months.wasClicked = SOI9_3_once_every_2or3_months.isClicked and SOI9_3_once_every_2or3_months.status == STARTED
        # *SOI9_4_onceamonth* updates
        
        # if SOI9_4_onceamonth is starting this frame...
        if SOI9_4_onceamonth.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_4_onceamonth.frameNStart = frameN  # exact frame index
            SOI9_4_onceamonth.tStart = t  # local t and not account for scr refresh
            SOI9_4_onceamonth.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_4_onceamonth, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_4_onceamonth.started')
            # update status
            SOI9_4_onceamonth.status = STARTED
            win.callOnFlip(SOI9_4_onceamonth.buttonClock.reset)
            SOI9_4_onceamonth.setAutoDraw(True)
        
        # if SOI9_4_onceamonth is active this frame...
        if SOI9_4_onceamonth.status == STARTED:
            # update params
            pass
            # check whether SOI9_4_onceamonth has been pressed
            if SOI9_4_onceamonth.isClicked:
                if not SOI9_4_onceamonth.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_4_onceamonth.timesOn.append(SOI9_4_onceamonth.buttonClock.getTime())
                    SOI9_4_onceamonth.timesOff.append(SOI9_4_onceamonth.buttonClock.getTime())
                elif len(SOI9_4_onceamonth.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_4_onceamonth.timesOff[-1] = SOI9_4_onceamonth.buttonClock.getTime()
                if not SOI9_4_onceamonth.wasClicked:
                    # end routine when SOI9_4_onceamonth is clicked
                    continueRoutine = False
                if not SOI9_4_onceamonth.wasClicked:
                    # run callback code when SOI9_4_onceamonth is clicked
                    thisExp.addData('SOI9', '4')
                    
        # take note of whether SOI9_4_onceamonth was clicked, so that next frame we know if clicks are new
        SOI9_4_onceamonth.wasClicked = SOI9_4_onceamonth.isClicked and SOI9_4_onceamonth.status == STARTED
        # *SOI9_5_once_every_two_weeks* updates
        
        # if SOI9_5_once_every_two_weeks is starting this frame...
        if SOI9_5_once_every_two_weeks.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_5_once_every_two_weeks.frameNStart = frameN  # exact frame index
            SOI9_5_once_every_two_weeks.tStart = t  # local t and not account for scr refresh
            SOI9_5_once_every_two_weeks.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_5_once_every_two_weeks, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_5_once_every_two_weeks.started')
            # update status
            SOI9_5_once_every_two_weeks.status = STARTED
            win.callOnFlip(SOI9_5_once_every_two_weeks.buttonClock.reset)
            SOI9_5_once_every_two_weeks.setAutoDraw(True)
        
        # if SOI9_5_once_every_two_weeks is active this frame...
        if SOI9_5_once_every_two_weeks.status == STARTED:
            # update params
            pass
            # check whether SOI9_5_once_every_two_weeks has been pressed
            if SOI9_5_once_every_two_weeks.isClicked:
                if not SOI9_5_once_every_two_weeks.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_5_once_every_two_weeks.timesOn.append(SOI9_5_once_every_two_weeks.buttonClock.getTime())
                    SOI9_5_once_every_two_weeks.timesOff.append(SOI9_5_once_every_two_weeks.buttonClock.getTime())
                elif len(SOI9_5_once_every_two_weeks.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_5_once_every_two_weeks.timesOff[-1] = SOI9_5_once_every_two_weeks.buttonClock.getTime()
                if not SOI9_5_once_every_two_weeks.wasClicked:
                    # end routine when SOI9_5_once_every_two_weeks is clicked
                    continueRoutine = False
                if not SOI9_5_once_every_two_weeks.wasClicked:
                    # run callback code when SOI9_5_once_every_two_weeks is clicked
                    thisExp.addData('SOI9', '5')
        # take note of whether SOI9_5_once_every_two_weeks was clicked, so that next frame we know if clicks are new
        SOI9_5_once_every_two_weeks.wasClicked = SOI9_5_once_every_two_weeks.isClicked and SOI9_5_once_every_two_weeks.status == STARTED
        # *SOI9_6_onceaweek* updates
        
        # if SOI9_6_onceaweek is starting this frame...
        if SOI9_6_onceaweek.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_6_onceaweek.frameNStart = frameN  # exact frame index
            SOI9_6_onceaweek.tStart = t  # local t and not account for scr refresh
            SOI9_6_onceaweek.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_6_onceaweek, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_6_onceaweek.started')
            # update status
            SOI9_6_onceaweek.status = STARTED
            win.callOnFlip(SOI9_6_onceaweek.buttonClock.reset)
            SOI9_6_onceaweek.setAutoDraw(True)
        
        # if SOI9_6_onceaweek is active this frame...
        if SOI9_6_onceaweek.status == STARTED:
            # update params
            pass
            # check whether SOI9_6_onceaweek has been pressed
            if SOI9_6_onceaweek.isClicked:
                if not SOI9_6_onceaweek.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_6_onceaweek.timesOn.append(SOI9_6_onceaweek.buttonClock.getTime())
                    SOI9_6_onceaweek.timesOff.append(SOI9_6_onceaweek.buttonClock.getTime())
                elif len(SOI9_6_onceaweek.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_6_onceaweek.timesOff[-1] = SOI9_6_onceaweek.buttonClock.getTime()
                if not SOI9_6_onceaweek.wasClicked:
                    # end routine when SOI9_6_onceaweek is clicked
                    continueRoutine = False
                if not SOI9_6_onceaweek.wasClicked:
                    # run callback code when SOI9_6_onceaweek is clicked
                    thisExp.addData('SOI9', '6')
        # take note of whether SOI9_6_onceaweek was clicked, so that next frame we know if clicks are new
        SOI9_6_onceaweek.wasClicked = SOI9_6_onceaweek.isClicked and SOI9_6_onceaweek.status == STARTED
        # *SOI9_7_several_times_per_week* updates
        
        # if SOI9_7_several_times_per_week is starting this frame...
        if SOI9_7_several_times_per_week.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_7_several_times_per_week.frameNStart = frameN  # exact frame index
            SOI9_7_several_times_per_week.tStart = t  # local t and not account for scr refresh
            SOI9_7_several_times_per_week.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_7_several_times_per_week, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_7_several_times_per_week.started')
            # update status
            SOI9_7_several_times_per_week.status = STARTED
            win.callOnFlip(SOI9_7_several_times_per_week.buttonClock.reset)
            SOI9_7_several_times_per_week.setAutoDraw(True)
        
        # if SOI9_7_several_times_per_week is active this frame...
        if SOI9_7_several_times_per_week.status == STARTED:
            # update params
            pass
            # check whether SOI9_7_several_times_per_week has been pressed
            if SOI9_7_several_times_per_week.isClicked:
                if not SOI9_7_several_times_per_week.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_7_several_times_per_week.timesOn.append(SOI9_7_several_times_per_week.buttonClock.getTime())
                    SOI9_7_several_times_per_week.timesOff.append(SOI9_7_several_times_per_week.buttonClock.getTime())
                elif len(SOI9_7_several_times_per_week.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_7_several_times_per_week.timesOff[-1] = SOI9_7_several_times_per_week.buttonClock.getTime()
                if not SOI9_7_several_times_per_week.wasClicked:
                    # end routine when SOI9_7_several_times_per_week is clicked
                    continueRoutine = False
                if not SOI9_7_several_times_per_week.wasClicked:
                    # run callback code when SOI9_7_several_times_per_week is clicked
                    thisExp.addData('SOI9', '7')
        # take note of whether SOI9_7_several_times_per_week was clicked, so that next frame we know if clicks are new
        SOI9_7_several_times_per_week.wasClicked = SOI9_7_several_times_per_week.isClicked and SOI9_7_several_times_per_week.status == STARTED
        # *SOI9_8_early_every_day* updates
        
        # if SOI9_8_early_every_day is starting this frame...
        if SOI9_8_early_every_day.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_8_early_every_day.frameNStart = frameN  # exact frame index
            SOI9_8_early_every_day.tStart = t  # local t and not account for scr refresh
            SOI9_8_early_every_day.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_8_early_every_day, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_8_early_every_day.started')
            # update status
            SOI9_8_early_every_day.status = STARTED
            win.callOnFlip(SOI9_8_early_every_day.buttonClock.reset)
            SOI9_8_early_every_day.setAutoDraw(True)
        
        # if SOI9_8_early_every_day is active this frame...
        if SOI9_8_early_every_day.status == STARTED:
            # update params
            pass
            # check whether SOI9_8_early_every_day has been pressed
            if SOI9_8_early_every_day.isClicked:
                if not SOI9_8_early_every_day.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_8_early_every_day.timesOn.append(SOI9_8_early_every_day.buttonClock.getTime())
                    SOI9_8_early_every_day.timesOff.append(SOI9_8_early_every_day.buttonClock.getTime())
                elif len(SOI9_8_early_every_day.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_8_early_every_day.timesOff[-1] = SOI9_8_early_every_day.buttonClock.getTime()
                if not SOI9_8_early_every_day.wasClicked:
                    # end routine when SOI9_8_early_every_day is clicked
                    continueRoutine = False
                if not SOI9_8_early_every_day.wasClicked:
                    # run callback code when SOI9_8_early_every_day is clicked
                    thisExp.addData('SOI9', '8')
        # take note of whether SOI9_8_early_every_day was clicked, so that next frame we know if clicks are new
        SOI9_8_early_every_day.wasClicked = SOI9_8_early_every_day.isClicked and SOI9_8_early_every_day.status == STARTED
        # *SOI9_9_atleastonceaday* updates
        
        # if SOI9_9_atleastonceaday is starting this frame...
        if SOI9_9_atleastonceaday.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            SOI9_9_atleastonceaday.frameNStart = frameN  # exact frame index
            SOI9_9_atleastonceaday.tStart = t  # local t and not account for scr refresh
            SOI9_9_atleastonceaday.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SOI9_9_atleastonceaday, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'SOI9_9_atleastonceaday.started')
            # update status
            SOI9_9_atleastonceaday.status = STARTED
            win.callOnFlip(SOI9_9_atleastonceaday.buttonClock.reset)
            SOI9_9_atleastonceaday.setAutoDraw(True)
        
        # if SOI9_9_atleastonceaday is active this frame...
        if SOI9_9_atleastonceaday.status == STARTED:
            # update params
            pass
            # check whether SOI9_9_atleastonceaday has been pressed
            if SOI9_9_atleastonceaday.isClicked:
                if not SOI9_9_atleastonceaday.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    SOI9_9_atleastonceaday.timesOn.append(SOI9_9_atleastonceaday.buttonClock.getTime())
                    SOI9_9_atleastonceaday.timesOff.append(SOI9_9_atleastonceaday.buttonClock.getTime())
                elif len(SOI9_9_atleastonceaday.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    SOI9_9_atleastonceaday.timesOff[-1] = SOI9_9_atleastonceaday.buttonClock.getTime()
                if not SOI9_9_atleastonceaday.wasClicked:
                    # end routine when SOI9_9_atleastonceaday is clicked
                    continueRoutine = False
                if not SOI9_9_atleastonceaday.wasClicked:
                    # run callback code when SOI9_9_atleastonceaday is clicked
                    thisExp.addData('SOI9', '9')
        # take note of whether SOI9_9_atleastonceaday was clicked, so that next frame we know if clicks are new
        SOI9_9_atleastonceaday.wasClicked = SOI9_9_atleastonceaday.isClicked and SOI9_9_atleastonceaday.status == STARTED
        
        # *Q74* updates
        
        # if Q74 is starting this frame...
        if Q74.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Q74.frameNStart = frameN  # exact frame index
            Q74.tStart = t  # local t and not account for scr refresh
            Q74.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Q74, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'Q74.started')
            # update status
            Q74.status = STARTED
            Q74.setAutoDraw(True)
        
        # if Q74 is active this frame...
        if Q74.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=SOI9,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SOI9.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SOI9.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SOI9" ---
    for thisComponent in SOI9.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SOI9
    SOI9.tStop = globalClock.getTime(format='float')
    SOI9.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SOI9.stopped', SOI9.tStop)
    thisExp.addData('SOI9_1_never.numClicks', SOI9_1_never.numClicks)
    if SOI9_1_never.numClicks:
       thisExp.addData('SOI9_1_never.timesOn', SOI9_1_never.timesOn)
       thisExp.addData('SOI9_1_never.timesOff', SOI9_1_never.timesOff)
    else:
       thisExp.addData('SOI9_1_never.timesOn', "")
       thisExp.addData('SOI9_1_never.timesOff', "")
    thisExp.addData('SOI9_2_veryseldom.numClicks', SOI9_2_veryseldom.numClicks)
    if SOI9_2_veryseldom.numClicks:
       thisExp.addData('SOI9_2_veryseldom.timesOn', SOI9_2_veryseldom.timesOn)
       thisExp.addData('SOI9_2_veryseldom.timesOff', SOI9_2_veryseldom.timesOff)
    else:
       thisExp.addData('SOI9_2_veryseldom.timesOn', "")
       thisExp.addData('SOI9_2_veryseldom.timesOff', "")
    thisExp.addData('SOI9_3_once_every_2or3_months.numClicks', SOI9_3_once_every_2or3_months.numClicks)
    if SOI9_3_once_every_2or3_months.numClicks:
       thisExp.addData('SOI9_3_once_every_2or3_months.timesOn', SOI9_3_once_every_2or3_months.timesOn)
       thisExp.addData('SOI9_3_once_every_2or3_months.timesOff', SOI9_3_once_every_2or3_months.timesOff)
    else:
       thisExp.addData('SOI9_3_once_every_2or3_months.timesOn', "")
       thisExp.addData('SOI9_3_once_every_2or3_months.timesOff', "")
    thisExp.addData('SOI9_4_onceamonth.numClicks', SOI9_4_onceamonth.numClicks)
    if SOI9_4_onceamonth.numClicks:
       thisExp.addData('SOI9_4_onceamonth.timesOn', SOI9_4_onceamonth.timesOn)
       thisExp.addData('SOI9_4_onceamonth.timesOff', SOI9_4_onceamonth.timesOff)
    else:
       thisExp.addData('SOI9_4_onceamonth.timesOn', "")
       thisExp.addData('SOI9_4_onceamonth.timesOff', "")
    thisExp.addData('SOI9_5_once_every_two_weeks.numClicks', SOI9_5_once_every_two_weeks.numClicks)
    if SOI9_5_once_every_two_weeks.numClicks:
       thisExp.addData('SOI9_5_once_every_two_weeks.timesOn', SOI9_5_once_every_two_weeks.timesOn)
       thisExp.addData('SOI9_5_once_every_two_weeks.timesOff', SOI9_5_once_every_two_weeks.timesOff)
    else:
       thisExp.addData('SOI9_5_once_every_two_weeks.timesOn', "")
       thisExp.addData('SOI9_5_once_every_two_weeks.timesOff', "")
    thisExp.addData('SOI9_6_onceaweek.numClicks', SOI9_6_onceaweek.numClicks)
    if SOI9_6_onceaweek.numClicks:
       thisExp.addData('SOI9_6_onceaweek.timesOn', SOI9_6_onceaweek.timesOn)
       thisExp.addData('SOI9_6_onceaweek.timesOff', SOI9_6_onceaweek.timesOff)
    else:
       thisExp.addData('SOI9_6_onceaweek.timesOn', "")
       thisExp.addData('SOI9_6_onceaweek.timesOff', "")
    thisExp.addData('SOI9_7_several_times_per_week.numClicks', SOI9_7_several_times_per_week.numClicks)
    if SOI9_7_several_times_per_week.numClicks:
       thisExp.addData('SOI9_7_several_times_per_week.timesOn', SOI9_7_several_times_per_week.timesOn)
       thisExp.addData('SOI9_7_several_times_per_week.timesOff', SOI9_7_several_times_per_week.timesOff)
    else:
       thisExp.addData('SOI9_7_several_times_per_week.timesOn', "")
       thisExp.addData('SOI9_7_several_times_per_week.timesOff', "")
    thisExp.addData('SOI9_8_early_every_day.numClicks', SOI9_8_early_every_day.numClicks)
    if SOI9_8_early_every_day.numClicks:
       thisExp.addData('SOI9_8_early_every_day.timesOn', SOI9_8_early_every_day.timesOn)
       thisExp.addData('SOI9_8_early_every_day.timesOff', SOI9_8_early_every_day.timesOff)
    else:
       thisExp.addData('SOI9_8_early_every_day.timesOn', "")
       thisExp.addData('SOI9_8_early_every_day.timesOff', "")
    thisExp.addData('SOI9_9_atleastonceaday.numClicks', SOI9_9_atleastonceaday.numClicks)
    if SOI9_9_atleastonceaday.numClicks:
       thisExp.addData('SOI9_9_atleastonceaday.timesOn', SOI9_9_atleastonceaday.timesOn)
       thisExp.addData('SOI9_9_atleastonceaday.timesOff', SOI9_9_atleastonceaday.timesOff)
    else:
       thisExp.addData('SOI9_9_atleastonceaday.timesOn', "")
       thisExp.addData('SOI9_9_atleastonceaday.timesOff', "")
    thisExp.nextEntry()
    # the Routine "SOI9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ATAI_intro" ---
    # create an object to store info about Routine ATAI_intro
    ATAI_intro = data.Routine(
        name='ATAI_intro',
        components=[ATAI_intro_image, key_resp_9],
    )
    ATAI_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_9
    key_resp_9.keys = []
    key_resp_9.rt = []
    _key_resp_9_allKeys = []
    # store start times for ATAI_intro
    ATAI_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ATAI_intro.tStart = globalClock.getTime(format='float')
    ATAI_intro.status = STARTED
    thisExp.addData('ATAI_intro.started', ATAI_intro.tStart)
    ATAI_intro.maxDuration = None
    # keep track of which components have finished
    ATAI_introComponents = ATAI_intro.components
    for thisComponent in ATAI_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ATAI_intro" ---
    ATAI_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *ATAI_intro_image* updates
        
        # if ATAI_intro_image is starting this frame...
        if ATAI_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            ATAI_intro_image.frameNStart = frameN  # exact frame index
            ATAI_intro_image.tStart = t  # local t and not account for scr refresh
            ATAI_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ATAI_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'ATAI_intro_image.started')
            # update status
            ATAI_intro_image.status = STARTED
            ATAI_intro_image.setAutoDraw(True)
        
        # if ATAI_intro_image is active this frame...
        if ATAI_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_9* updates
        waitOnFlip = False
        
        # if key_resp_9 is starting this frame...
        if key_resp_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_9.frameNStart = frameN  # exact frame index
            key_resp_9.tStart = t  # local t and not account for scr refresh
            key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_9.started')
            # update status
            key_resp_9.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_9.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_9.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_9_allKeys.extend(theseKeys)
            if len(_key_resp_9_allKeys):
                key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
                key_resp_9.rt = _key_resp_9_allKeys[-1].rt
                key_resp_9.duration = _key_resp_9_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=ATAI_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ATAI_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ATAI_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ATAI_intro" ---
    for thisComponent in ATAI_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ATAI_intro
    ATAI_intro.tStop = globalClock.getTime(format='float')
    ATAI_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ATAI_intro.stopped', ATAI_intro.tStop)
    # check responses
    if key_resp_9.keys in ['', [], None]:  # No response was made
        key_resp_9.keys = None
    thisExp.addData('key_resp_9.keys',key_resp_9.keys)
    if key_resp_9.keys != None:  # we had a response
        thisExp.addData('key_resp_9.rt', key_resp_9.rt)
        thisExp.addData('key_resp_9.duration', key_resp_9.duration)
    thisExp.nextEntry()
    # the Routine "ATAI_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_ATAI = data.TrialHandler2(
        name='trials_ATAI',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('ATAIQUESTIONTEXT.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_ATAI)  # add the loop to the experiment
    thisTrials_ATAI = trials_ATAI.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_ATAI.rgb)
    if thisTrials_ATAI != None:
        for paramName in thisTrials_ATAI:
            globals()[paramName] = thisTrials_ATAI[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_ATAI in trials_ATAI:
        trials_ATAI.status = STARTED
        if hasattr(thisTrials_ATAI, 'status'):
            thisTrials_ATAI.status = STARTED
        currentLoop = trials_ATAI
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_ATAI.rgb)
        if thisTrials_ATAI != None:
            for paramName in thisTrials_ATAI:
                globals()[paramName] = thisTrials_ATAI[paramName]
        
        # --- Prepare to start Routine "ATAI" ---
        # create an object to store info about Routine ATAI
        ATAI = data.Routine(
            name='ATAI',
            components=[ATAI_QuestionText, ATAIquestionslide, Q75toQ79],
        )
        ATAI.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        ATAI_QuestionText.setText(ATAIqText)
        ATAIquestionslide.reset()
        Q75toQ79.setText(ATAIqIndex)
        # store start times for ATAI
        ATAI.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        ATAI.tStart = globalClock.getTime(format='float')
        ATAI.status = STARTED
        thisExp.addData('ATAI.started', ATAI.tStart)
        ATAI.maxDuration = None
        # keep track of which components have finished
        ATAIComponents = ATAI.components
        for thisComponent in ATAI.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "ATAI" ---
        ATAI.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_ATAI, 'status') and thisTrials_ATAI.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *ATAI_QuestionText* updates
            
            # if ATAI_QuestionText is starting this frame...
            if ATAI_QuestionText.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                ATAI_QuestionText.frameNStart = frameN  # exact frame index
                ATAI_QuestionText.tStart = t  # local t and not account for scr refresh
                ATAI_QuestionText.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(ATAI_QuestionText, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'ATAI_QuestionText.started')
                # update status
                ATAI_QuestionText.status = STARTED
                ATAI_QuestionText.setAutoDraw(True)
            
            # if ATAI_QuestionText is active this frame...
            if ATAI_QuestionText.status == STARTED:
                # update params
                pass
            
            # *ATAIquestionslide* updates
            
            # if ATAIquestionslide is starting this frame...
            if ATAIquestionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                ATAIquestionslide.frameNStart = frameN  # exact frame index
                ATAIquestionslide.tStart = t  # local t and not account for scr refresh
                ATAIquestionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(ATAIquestionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'ATAIquestionslide.started')
                # update status
                ATAIquestionslide.status = STARTED
                ATAIquestionslide.setAutoDraw(True)
            
            # if ATAIquestionslide is active this frame...
            if ATAIquestionslide.status == STARTED:
                # update params
                pass
            
            # Check ATAIquestionslide for response to end Routine
            if ATAIquestionslide.getRating() is not None and ATAIquestionslide.status == STARTED:
                continueRoutine = False
            
            # *Q75toQ79* updates
            
            # if Q75toQ79 is starting this frame...
            if Q75toQ79.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q75toQ79.frameNStart = frameN  # exact frame index
                Q75toQ79.tStart = t  # local t and not account for scr refresh
                Q75toQ79.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q75toQ79, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q75toQ79.started')
                # update status
                Q75toQ79.status = STARTED
                Q75toQ79.setAutoDraw(True)
            
            # if Q75toQ79 is active this frame...
            if Q75toQ79.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=ATAI,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                ATAI.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in ATAI.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "ATAI" ---
        for thisComponent in ATAI.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for ATAI
        ATAI.tStop = globalClock.getTime(format='float')
        ATAI.tStopRefresh = tThisFlipGlobal
        thisExp.addData('ATAI.stopped', ATAI.tStop)
        trials_ATAI.addData('ATAIquestionslide.response', ATAIquestionslide.getRating())
        trials_ATAI.addData('ATAIquestionslide.rt', ATAIquestionslide.getRT())
        # the Routine "ATAI" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_ATAI as finished
        if hasattr(thisTrials_ATAI, 'status'):
            thisTrials_ATAI.status = FINISHED
        # if awaiting a pause, pause now
        if trials_ATAI.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_ATAI.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_ATAI'
    trials_ATAI.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_ATAI.trialList in ([], [None], None):
        params = []
    else:
        params = trials_ATAI.trialList[0].keys()
    # save data for this loop
    trials_ATAI.saveAsExcel(filename + '.xlsx', sheetName='trials_ATAI',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_ATAI.saveAsText(filename + '_trials_ATAI.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "BSSS4_intro" ---
    # create an object to store info about Routine BSSS4_intro
    BSSS4_intro = data.Routine(
        name='BSSS4_intro',
        components=[BSSS4_intro_image, key_resp_10],
    )
    BSSS4_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_10
    key_resp_10.keys = []
    key_resp_10.rt = []
    _key_resp_10_allKeys = []
    # store start times for BSSS4_intro
    BSSS4_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    BSSS4_intro.tStart = globalClock.getTime(format='float')
    BSSS4_intro.status = STARTED
    thisExp.addData('BSSS4_intro.started', BSSS4_intro.tStart)
    BSSS4_intro.maxDuration = None
    # keep track of which components have finished
    BSSS4_introComponents = BSSS4_intro.components
    for thisComponent in BSSS4_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "BSSS4_intro" ---
    BSSS4_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *BSSS4_intro_image* updates
        
        # if BSSS4_intro_image is starting this frame...
        if BSSS4_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            BSSS4_intro_image.frameNStart = frameN  # exact frame index
            BSSS4_intro_image.tStart = t  # local t and not account for scr refresh
            BSSS4_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(BSSS4_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'BSSS4_intro_image.started')
            # update status
            BSSS4_intro_image.status = STARTED
            BSSS4_intro_image.setAutoDraw(True)
        
        # if BSSS4_intro_image is active this frame...
        if BSSS4_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_10* updates
        waitOnFlip = False
        
        # if key_resp_10 is starting this frame...
        if key_resp_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_10.frameNStart = frameN  # exact frame index
            key_resp_10.tStart = t  # local t and not account for scr refresh
            key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_10.started')
            # update status
            key_resp_10.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_10.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_10.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_10_allKeys.extend(theseKeys)
            if len(_key_resp_10_allKeys):
                key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
                key_resp_10.rt = _key_resp_10_allKeys[-1].rt
                key_resp_10.duration = _key_resp_10_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=BSSS4_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            BSSS4_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BSSS4_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "BSSS4_intro" ---
    for thisComponent in BSSS4_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for BSSS4_intro
    BSSS4_intro.tStop = globalClock.getTime(format='float')
    BSSS4_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('BSSS4_intro.stopped', BSSS4_intro.tStop)
    # check responses
    if key_resp_10.keys in ['', [], None]:  # No response was made
        key_resp_10.keys = None
    thisExp.addData('key_resp_10.keys',key_resp_10.keys)
    if key_resp_10.keys != None:  # we had a response
        thisExp.addData('key_resp_10.rt', key_resp_10.rt)
        thisExp.addData('key_resp_10.duration', key_resp_10.duration)
    thisExp.nextEntry()
    # the Routine "BSSS4_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_BSSS = data.TrialHandler2(
        name='trials_BSSS',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('BSSSQUESTIONTEXT.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_BSSS)  # add the loop to the experiment
    thisTrials_BSSS = trials_BSSS.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_BSSS.rgb)
    if thisTrials_BSSS != None:
        for paramName in thisTrials_BSSS:
            globals()[paramName] = thisTrials_BSSS[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_BSSS in trials_BSSS:
        trials_BSSS.status = STARTED
        if hasattr(thisTrials_BSSS, 'status'):
            thisTrials_BSSS.status = STARTED
        currentLoop = trials_BSSS
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_BSSS.rgb)
        if thisTrials_BSSS != None:
            for paramName in thisTrials_BSSS:
                globals()[paramName] = thisTrials_BSSS[paramName]
        
        # --- Prepare to start Routine "BSSS" ---
        # create an object to store info about Routine BSSS
        BSSS = data.Routine(
            name='BSSS',
            components=[BSSS_questiontext, BSSS_questionslide, Q80toQ87],
        )
        BSSS.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        BSSS_questiontext.setText(BSSSqText)
        BSSS_questionslide.reset()
        Q80toQ87.setText(BSSSqIndex)
        # store start times for BSSS
        BSSS.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        BSSS.tStart = globalClock.getTime(format='float')
        BSSS.status = STARTED
        thisExp.addData('BSSS.started', BSSS.tStart)
        BSSS.maxDuration = None
        # keep track of which components have finished
        BSSSComponents = BSSS.components
        for thisComponent in BSSS.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "BSSS" ---
        BSSS.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_BSSS, 'status') and thisTrials_BSSS.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *BSSS_questiontext* updates
            
            # if BSSS_questiontext is starting this frame...
            if BSSS_questiontext.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BSSS_questiontext.frameNStart = frameN  # exact frame index
                BSSS_questiontext.tStart = t  # local t and not account for scr refresh
                BSSS_questiontext.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BSSS_questiontext, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BSSS_questiontext.started')
                # update status
                BSSS_questiontext.status = STARTED
                BSSS_questiontext.setAutoDraw(True)
            
            # if BSSS_questiontext is active this frame...
            if BSSS_questiontext.status == STARTED:
                # update params
                pass
            
            # *BSSS_questionslide* updates
            
            # if BSSS_questionslide is starting this frame...
            if BSSS_questionslide.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BSSS_questionslide.frameNStart = frameN  # exact frame index
                BSSS_questionslide.tStart = t  # local t and not account for scr refresh
                BSSS_questionslide.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BSSS_questionslide, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BSSS_questionslide.started')
                # update status
                BSSS_questionslide.status = STARTED
                BSSS_questionslide.setAutoDraw(True)
            
            # if BSSS_questionslide is active this frame...
            if BSSS_questionslide.status == STARTED:
                # update params
                pass
            
            # Check BSSS_questionslide for response to end Routine
            if BSSS_questionslide.getRating() is not None and BSSS_questionslide.status == STARTED:
                continueRoutine = False
            
            # *Q80toQ87* updates
            
            # if Q80toQ87 is starting this frame...
            if Q80toQ87.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q80toQ87.frameNStart = frameN  # exact frame index
                Q80toQ87.tStart = t  # local t and not account for scr refresh
                Q80toQ87.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q80toQ87, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q80toQ87.started')
                # update status
                Q80toQ87.status = STARTED
                Q80toQ87.setAutoDraw(True)
            
            # if Q80toQ87 is active this frame...
            if Q80toQ87.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=BSSS,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                BSSS.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in BSSS.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "BSSS" ---
        for thisComponent in BSSS.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for BSSS
        BSSS.tStop = globalClock.getTime(format='float')
        BSSS.tStopRefresh = tThisFlipGlobal
        thisExp.addData('BSSS.stopped', BSSS.tStop)
        trials_BSSS.addData('BSSS_questionslide.response', BSSS_questionslide.getRating())
        trials_BSSS.addData('BSSS_questionslide.rt', BSSS_questionslide.getRT())
        # the Routine "BSSS" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_BSSS as finished
        if hasattr(thisTrials_BSSS, 'status'):
            thisTrials_BSSS.status = FINISHED
        # if awaiting a pause, pause now
        if trials_BSSS.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_BSSS.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_BSSS'
    trials_BSSS.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_BSSS.trialList in ([], [None], None):
        params = []
    else:
        params = trials_BSSS.trialList[0].keys()
    # save data for this loop
    trials_BSSS.saveAsExcel(filename + '.xlsx', sheetName='trials_BSSS',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_BSSS.saveAsText(filename + '_trials_BSSS.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "BPAAT_intro" ---
    # create an object to store info about Routine BPAAT_intro
    BPAAT_intro = data.Routine(
        name='BPAAT_intro',
        components=[BPAAT_intro_image, key_resp_11],
    )
    BPAAT_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_11
    key_resp_11.keys = []
    key_resp_11.rt = []
    _key_resp_11_allKeys = []
    # store start times for BPAAT_intro
    BPAAT_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    BPAAT_intro.tStart = globalClock.getTime(format='float')
    BPAAT_intro.status = STARTED
    thisExp.addData('BPAAT_intro.started', BPAAT_intro.tStart)
    BPAAT_intro.maxDuration = None
    # keep track of which components have finished
    BPAAT_introComponents = BPAAT_intro.components
    for thisComponent in BPAAT_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "BPAAT_intro" ---
    BPAAT_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *BPAAT_intro_image* updates
        
        # if BPAAT_intro_image is starting this frame...
        if BPAAT_intro_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            BPAAT_intro_image.frameNStart = frameN  # exact frame index
            BPAAT_intro_image.tStart = t  # local t and not account for scr refresh
            BPAAT_intro_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(BPAAT_intro_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'BPAAT_intro_image.started')
            # update status
            BPAAT_intro_image.status = STARTED
            BPAAT_intro_image.setAutoDraw(True)
        
        # if BPAAT_intro_image is active this frame...
        if BPAAT_intro_image.status == STARTED:
            # update params
            pass
        
        # *key_resp_11* updates
        waitOnFlip = False
        
        # if key_resp_11 is starting this frame...
        if key_resp_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_11.frameNStart = frameN  # exact frame index
            key_resp_11.tStart = t  # local t and not account for scr refresh
            key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_11.started')
            # update status
            key_resp_11.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_11.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_11.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_11_allKeys.extend(theseKeys)
            if len(_key_resp_11_allKeys):
                key_resp_11.keys = _key_resp_11_allKeys[-1].name  # just the last key pressed
                key_resp_11.rt = _key_resp_11_allKeys[-1].rt
                key_resp_11.duration = _key_resp_11_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=BPAAT_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            BPAAT_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BPAAT_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "BPAAT_intro" ---
    for thisComponent in BPAAT_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for BPAAT_intro
    BPAAT_intro.tStop = globalClock.getTime(format='float')
    BPAAT_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('BPAAT_intro.stopped', BPAAT_intro.tStop)
    # check responses
    if key_resp_11.keys in ['', [], None]:  # No response was made
        key_resp_11.keys = None
    thisExp.addData('key_resp_11.keys',key_resp_11.keys)
    if key_resp_11.keys != None:  # we had a response
        thisExp.addData('key_resp_11.rt', key_resp_11.rt)
        thisExp.addData('key_resp_11.duration', key_resp_11.duration)
    thisExp.nextEntry()
    # the Routine "BPAAT_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_BPAAT1 = data.TrialHandler2(
        name='trials_BPAAT1',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('BPAATQT1.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_BPAAT1)  # add the loop to the experiment
    thisTrials_BPAAT1 = trials_BPAAT1.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_BPAAT1.rgb)
    if thisTrials_BPAAT1 != None:
        for paramName in thisTrials_BPAAT1:
            globals()[paramName] = thisTrials_BPAAT1[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_BPAAT1 in trials_BPAAT1:
        trials_BPAAT1.status = STARTED
        if hasattr(thisTrials_BPAAT1, 'status'):
            thisTrials_BPAAT1.status = STARTED
        currentLoop = trials_BPAAT1
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_BPAAT1.rgb)
        if thisTrials_BPAAT1 != None:
            for paramName in thisTrials_BPAAT1:
                globals()[paramName] = thisTrials_BPAAT1[paramName]
        
        # --- Prepare to start Routine "BPAAT1" ---
        # create an object to store info about Routine BPAAT1
        BPAAT1 = data.Routine(
            name='BPAAT1',
            components=[BPAAT_questiontext1, BPAATquestionslide1, Q88],
        )
        BPAAT1.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        BPAAT_questiontext1.setText(BPAAT1qText)
        BPAATquestionslide1.reset()
        Q88.setText('Question 88 of 89\n')
        # store start times for BPAAT1
        BPAAT1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        BPAAT1.tStart = globalClock.getTime(format='float')
        BPAAT1.status = STARTED
        thisExp.addData('BPAAT1.started', BPAAT1.tStart)
        BPAAT1.maxDuration = None
        # keep track of which components have finished
        BPAAT1Components = BPAAT1.components
        for thisComponent in BPAAT1.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "BPAAT1" ---
        BPAAT1.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_BPAAT1, 'status') and thisTrials_BPAAT1.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *BPAAT_questiontext1* updates
            
            # if BPAAT_questiontext1 is starting this frame...
            if BPAAT_questiontext1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BPAAT_questiontext1.frameNStart = frameN  # exact frame index
                BPAAT_questiontext1.tStart = t  # local t and not account for scr refresh
                BPAAT_questiontext1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BPAAT_questiontext1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BPAAT_questiontext1.started')
                # update status
                BPAAT_questiontext1.status = STARTED
                BPAAT_questiontext1.setAutoDraw(True)
            
            # if BPAAT_questiontext1 is active this frame...
            if BPAAT_questiontext1.status == STARTED:
                # update params
                pass
            
            # *BPAATquestionslide1* updates
            
            # if BPAATquestionslide1 is starting this frame...
            if BPAATquestionslide1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BPAATquestionslide1.frameNStart = frameN  # exact frame index
                BPAATquestionslide1.tStart = t  # local t and not account for scr refresh
                BPAATquestionslide1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BPAATquestionslide1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BPAATquestionslide1.started')
                # update status
                BPAATquestionslide1.status = STARTED
                BPAATquestionslide1.setAutoDraw(True)
            
            # if BPAATquestionslide1 is active this frame...
            if BPAATquestionslide1.status == STARTED:
                # update params
                pass
            
            # Check BPAATquestionslide1 for response to end Routine
            if BPAATquestionslide1.getRating() is not None and BPAATquestionslide1.status == STARTED:
                continueRoutine = False
            
            # *Q88* updates
            
            # if Q88 is starting this frame...
            if Q88.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q88.frameNStart = frameN  # exact frame index
                Q88.tStart = t  # local t and not account for scr refresh
                Q88.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q88, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q88.started')
                # update status
                Q88.status = STARTED
                Q88.setAutoDraw(True)
            
            # if Q88 is active this frame...
            if Q88.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=BPAAT1,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                BPAAT1.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in BPAAT1.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "BPAAT1" ---
        for thisComponent in BPAAT1.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for BPAAT1
        BPAAT1.tStop = globalClock.getTime(format='float')
        BPAAT1.tStopRefresh = tThisFlipGlobal
        thisExp.addData('BPAAT1.stopped', BPAAT1.tStop)
        trials_BPAAT1.addData('BPAATquestionslide1.response', BPAATquestionslide1.getRating())
        trials_BPAAT1.addData('BPAATquestionslide1.rt', BPAATquestionslide1.getRT())
        # the Routine "BPAAT1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_BPAAT1 as finished
        if hasattr(thisTrials_BPAAT1, 'status'):
            thisTrials_BPAAT1.status = FINISHED
        # if awaiting a pause, pause now
        if trials_BPAAT1.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_BPAAT1.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_BPAAT1'
    trials_BPAAT1.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_BPAAT1.trialList in ([], [None], None):
        params = []
    else:
        params = trials_BPAAT1.trialList[0].keys()
    # save data for this loop
    trials_BPAAT1.saveAsExcel(filename + '.xlsx', sheetName='trials_BPAAT1',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_BPAAT1.saveAsText(filename + '_trials_BPAAT1.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # set up handler to look after randomisation of conditions etc
    trials_BPAAT2 = data.TrialHandler2(
        name='trials_BPAAT2',
        nReps=1.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('BPAATQT2.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(trials_BPAAT2)  # add the loop to the experiment
    thisTrials_BPAAT2 = trials_BPAAT2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_BPAAT2.rgb)
    if thisTrials_BPAAT2 != None:
        for paramName in thisTrials_BPAAT2:
            globals()[paramName] = thisTrials_BPAAT2[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_BPAAT2 in trials_BPAAT2:
        trials_BPAAT2.status = STARTED
        if hasattr(thisTrials_BPAAT2, 'status'):
            thisTrials_BPAAT2.status = STARTED
        currentLoop = trials_BPAAT2
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_BPAAT2.rgb)
        if thisTrials_BPAAT2 != None:
            for paramName in thisTrials_BPAAT2:
                globals()[paramName] = thisTrials_BPAAT2[paramName]
        
        # --- Prepare to start Routine "BPAAT2" ---
        # create an object to store info about Routine BPAAT2
        BPAAT2 = data.Routine(
            name='BPAAT2',
            components=[BPAAT_questiontext2, BPAATquestionslide2, Q89],
        )
        BPAAT2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        BPAAT_questiontext2.setText(BPAAT2qText)
        BPAATquestionslide2.reset()
        Q89.setText('Question 89 of 89\n')
        # store start times for BPAAT2
        BPAAT2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        BPAAT2.tStart = globalClock.getTime(format='float')
        BPAAT2.status = STARTED
        thisExp.addData('BPAAT2.started', BPAAT2.tStart)
        BPAAT2.maxDuration = None
        # keep track of which components have finished
        BPAAT2Components = BPAAT2.components
        for thisComponent in BPAAT2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "BPAAT2" ---
        BPAAT2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_BPAAT2, 'status') and thisTrials_BPAAT2.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *BPAAT_questiontext2* updates
            
            # if BPAAT_questiontext2 is starting this frame...
            if BPAAT_questiontext2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BPAAT_questiontext2.frameNStart = frameN  # exact frame index
                BPAAT_questiontext2.tStart = t  # local t and not account for scr refresh
                BPAAT_questiontext2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BPAAT_questiontext2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BPAAT_questiontext2.started')
                # update status
                BPAAT_questiontext2.status = STARTED
                BPAAT_questiontext2.setAutoDraw(True)
            
            # if BPAAT_questiontext2 is active this frame...
            if BPAAT_questiontext2.status == STARTED:
                # update params
                pass
            
            # *BPAATquestionslide2* updates
            
            # if BPAATquestionslide2 is starting this frame...
            if BPAATquestionslide2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                BPAATquestionslide2.frameNStart = frameN  # exact frame index
                BPAATquestionslide2.tStart = t  # local t and not account for scr refresh
                BPAATquestionslide2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(BPAATquestionslide2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'BPAATquestionslide2.started')
                # update status
                BPAATquestionslide2.status = STARTED
                BPAATquestionslide2.setAutoDraw(True)
            
            # if BPAATquestionslide2 is active this frame...
            if BPAATquestionslide2.status == STARTED:
                # update params
                pass
            
            # Check BPAATquestionslide2 for response to end Routine
            if BPAATquestionslide2.getRating() is not None and BPAATquestionslide2.status == STARTED:
                continueRoutine = False
            
            # *Q89* updates
            
            # if Q89 is starting this frame...
            if Q89.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                Q89.frameNStart = frameN  # exact frame index
                Q89.tStart = t  # local t and not account for scr refresh
                Q89.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(Q89, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'Q89.started')
                # update status
                Q89.status = STARTED
                Q89.setAutoDraw(True)
            
            # if Q89 is active this frame...
            if Q89.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=BPAAT2,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                BPAAT2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in BPAAT2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "BPAAT2" ---
        for thisComponent in BPAAT2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for BPAAT2
        BPAAT2.tStop = globalClock.getTime(format='float')
        BPAAT2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('BPAAT2.stopped', BPAAT2.tStop)
        trials_BPAAT2.addData('BPAATquestionslide2.response', BPAATquestionslide2.getRating())
        trials_BPAAT2.addData('BPAATquestionslide2.rt', BPAATquestionslide2.getRT())
        # the Routine "BPAAT2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisTrials_BPAAT2 as finished
        if hasattr(thisTrials_BPAAT2, 'status'):
            thisTrials_BPAAT2.status = FINISHED
        # if awaiting a pause, pause now
        if trials_BPAAT2.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_BPAAT2.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_BPAAT2'
    trials_BPAAT2.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_BPAAT2.trialList in ([], [None], None):
        params = []
    else:
        params = trials_BPAAT2.trialList[0].keys()
    # save data for this loop
    trials_BPAAT2.saveAsExcel(filename + '.xlsx', sheetName='trials_BPAAT2',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_BPAAT2.saveAsText(filename + '_trials_BPAAT2.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "finishQUESTION_intro" ---
    # create an object to store info about Routine finishQUESTION_intro
    finishQUESTION_intro = data.Routine(
        name='finishQUESTION_intro',
        components=[finish_questions_image, resp_2],
    )
    finishQUESTION_intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for resp_2
    resp_2.keys = []
    resp_2.rt = []
    _resp_2_allKeys = []
    # store start times for finishQUESTION_intro
    finishQUESTION_intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    finishQUESTION_intro.tStart = globalClock.getTime(format='float')
    finishQUESTION_intro.status = STARTED
    thisExp.addData('finishQUESTION_intro.started', finishQUESTION_intro.tStart)
    finishQUESTION_intro.maxDuration = None
    # keep track of which components have finished
    finishQUESTION_introComponents = finishQUESTION_intro.components
    for thisComponent in finishQUESTION_intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "finishQUESTION_intro" ---
    finishQUESTION_intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *finish_questions_image* updates
        
        # if finish_questions_image is starting this frame...
        if finish_questions_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            finish_questions_image.frameNStart = frameN  # exact frame index
            finish_questions_image.tStart = t  # local t and not account for scr refresh
            finish_questions_image.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(finish_questions_image, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'finish_questions_image.started')
            # update status
            finish_questions_image.status = STARTED
            finish_questions_image.setAutoDraw(True)
        
        # if finish_questions_image is active this frame...
        if finish_questions_image.status == STARTED:
            # update params
            pass
        
        # *resp_2* updates
        waitOnFlip = False
        
        # if resp_2 is starting this frame...
        if resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            resp_2.frameNStart = frameN  # exact frame index
            resp_2.tStart = t  # local t and not account for scr refresh
            resp_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(resp_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'resp_2.started')
            # update status
            resp_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(resp_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if resp_2.status == STARTED and not waitOnFlip:
            theseKeys = resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _resp_2_allKeys.extend(theseKeys)
            if len(_resp_2_allKeys):
                resp_2.keys = _resp_2_allKeys[-1].name  # just the last key pressed
                resp_2.rt = _resp_2_allKeys[-1].rt
                resp_2.duration = _resp_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=finishQUESTION_intro,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            finishQUESTION_intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in finishQUESTION_intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "finishQUESTION_intro" ---
    for thisComponent in finishQUESTION_intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for finishQUESTION_intro
    finishQUESTION_intro.tStop = globalClock.getTime(format='float')
    finishQUESTION_intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('finishQUESTION_intro.stopped', finishQUESTION_intro.tStop)
    thisExp.nextEntry()
    # the Routine "finishQUESTION_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instructions" ---
    # create an object to store info about Routine instructions
    instructions = data.Routine(
        name='instructions',
        components=[background, resp, pop_sound],
    )
    instructions.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for resp
    resp.keys = []
    resp.rt = []
    _resp_allKeys = []
    pop_sound.setSound('assets/bang.wav', secs=1.0, hamming=True)
    pop_sound.setVolume(0.0, log=False)
    pop_sound.seek(0)
    # store start times for instructions
    instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instructions.tStart = globalClock.getTime(format='float')
    instructions.status = STARTED
    thisExp.addData('instructions.started', instructions.tStart)
    instructions.maxDuration = None
    # keep track of which components have finished
    instructionsComponents = instructions.components
    for thisComponent in instructions.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instructions" ---
    instructions.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *background* updates
        
        # if background is starting this frame...
        if background.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            background.frameNStart = frameN  # exact frame index
            background.tStart = t  # local t and not account for scr refresh
            background.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(background, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'background.started')
            # update status
            background.status = STARTED
            background.setAutoDraw(True)
        
        # if background is active this frame...
        if background.status == STARTED:
            # update params
            pass
        
        # *resp* updates
        waitOnFlip = False
        
        # if resp is starting this frame...
        if resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            resp.frameNStart = frameN  # exact frame index
            resp.tStart = t  # local t and not account for scr refresh
            resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(resp, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'resp.started')
            # update status
            resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if resp.status == STARTED and not waitOnFlip:
            theseKeys = resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _resp_allKeys.extend(theseKeys)
            if len(_resp_allKeys):
                resp.keys = _resp_allKeys[-1].name  # just the last key pressed
                resp.rt = _resp_allKeys[-1].rt
                resp.duration = _resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *pop_sound* updates
        
        # if pop_sound is starting this frame...
        if pop_sound.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            pop_sound.frameNStart = frameN  # exact frame index
            pop_sound.tStart = t  # local t and not account for scr refresh
            pop_sound.tStartRefresh = tThisFlipGlobal  # on global time
            # add timestamp to datafile
            thisExp.addData('pop_sound.started', tThisFlipGlobal)
            # update status
            pop_sound.status = STARTED
            pop_sound.play(when=win)  # sync with win flip
        
        # if pop_sound is stopping this frame...
        if pop_sound.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > pop_sound.tStartRefresh + 1.0-frameTolerance or pop_sound.isFinished:
                # keep track of stop time/frame for later
                pop_sound.tStop = t  # not accounting for scr refresh
                pop_sound.tStopRefresh = tThisFlipGlobal  # on global time
                pop_sound.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'pop_sound.stopped')
                # update status
                pop_sound.status = FINISHED
                pop_sound.stop()
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=instructions,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instructions.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instructions.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instructions" ---
    for thisComponent in instructions.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instructions
    instructions.tStop = globalClock.getTime(format='float')
    instructions.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instructions.stopped', instructions.tStop)
    pop_sound.pause()  # ensure sound has stopped at end of Routine
    thisExp.nextEntry()
    # the Routine "instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    comprehension_loop = data.TrialHandler2(
        name='comprehension_loop',
        nReps=1000.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(comprehension_loop)  # add the loop to the experiment
    thisComprehension_loop = comprehension_loop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisComprehension_loop.rgb)
    if thisComprehension_loop != None:
        for paramName in thisComprehension_loop:
            globals()[paramName] = thisComprehension_loop[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisComprehension_loop in comprehension_loop:
        comprehension_loop.status = STARTED
        if hasattr(thisComprehension_loop, 'status'):
            thisComprehension_loop.status = STARTED
        currentLoop = comprehension_loop
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisComprehension_loop.rgb)
        if thisComprehension_loop != None:
            for paramName in thisComprehension_loop:
                globals()[paramName] = thisComprehension_loop[paramName]
        
        # set up handler to look after randomisation of conditions etc
        practice_trials = data.TrialHandler2(
            name='practice_trials',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('spreadsheets/practice_conditions.xlsx'), 
            seed=1832, 
        )
        thisExp.addLoop(practice_trials)  # add the loop to the experiment
        thisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
        if thisPractice_trial != None:
            for paramName in thisPractice_trial:
                globals()[paramName] = thisPractice_trial[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisPractice_trial in practice_trials:
            practice_trials.status = STARTED
            if hasattr(thisPractice_trial, 'status'):
                thisPractice_trial.status = STARTED
            currentLoop = practice_trials
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
            if thisPractice_trial != None:
                for paramName in thisPractice_trial:
                    globals()[paramName] = thisPractice_trial[paramName]
            
            # --- Prepare to start Routine "reset_balloon" ---
            # create an object to store info about Routine reset_balloon
            reset_balloon = data.Routine(
                name='reset_balloon',
                components=[],
            )
            reset_balloon.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # Run 'Begin Routine' code from code
            balloonSize=0.08
            popped=False
            nPumps=0
            
            # store start times for reset_balloon
            reset_balloon.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            reset_balloon.tStart = globalClock.getTime(format='float')
            reset_balloon.status = STARTED
            thisExp.addData('reset_balloon.started', reset_balloon.tStart)
            reset_balloon.maxDuration = None
            # keep track of which components have finished
            reset_balloonComponents = reset_balloon.components
            for thisComponent in reset_balloon.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "reset_balloon" ---
            reset_balloon.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine:
                # if trial has changed, end Routine now
                if hasattr(thisPractice_trial, 'status') and thisPractice_trial.status == STOPPING:
                    continueRoutine = False
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer, globalClock], 
                        currentRoutine=reset_balloon,
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    reset_balloon.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in reset_balloon.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "reset_balloon" ---
            for thisComponent in reset_balloon.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for reset_balloon
            reset_balloon.tStop = globalClock.getTime(format='float')
            reset_balloon.tStopRefresh = tThisFlipGlobal
            thisExp.addData('reset_balloon.stopped', reset_balloon.tStop)
            # the Routine "reset_balloon" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # set up handler to look after randomisation of conditions etc
            practice_pump = data.TrialHandler2(
                name='practice_pump',
                nReps=practice_maxPumps, 
                method='random', 
                extraInfo=expInfo, 
                originPath=-1, 
                trialList=[None], 
                seed=None, 
            )
            thisExp.addLoop(practice_pump)  # add the loop to the experiment
            thisPractice_pump = practice_pump.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_pump.rgb)
            if thisPractice_pump != None:
                for paramName in thisPractice_pump:
                    globals()[paramName] = thisPractice_pump[paramName]
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            for thisPractice_pump in practice_pump:
                practice_pump.status = STARTED
                if hasattr(thisPractice_pump, 'status'):
                    thisPractice_pump.status = STARTED
                currentLoop = practice_pump
                thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
                # abbreviate parameter names if possible (e.g. rgb = thisPractice_pump.rgb)
                if thisPractice_pump != None:
                    for paramName in thisPractice_pump:
                        globals()[paramName] = thisPractice_pump[paramName]
                
                # --- Prepare to start Routine "practice_trial" ---
                # create an object to store info about Routine practice_trial
                practice_trial = data.Routine(
                    name='practice_trial',
                    components=[practice_bg, practice_bankButton, practice_reminder, practice_balloonValTxt, practice_bankedTxt, practice_balloonBody, practice_trialcount],
                )
                practice_trial.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # create starting attributes for practice_bankButton
                practice_bankButton.keys = []
                practice_bankButton.rt = []
                _practice_bankButton_allKeys = []
                # Run 'Begin Routine' code from practice_updateEarnings
                thisBalloonEarnings=(practice_pump.thisN+1)*0.05
                balloonEarnings = "This balloon value:\n$" + str(round(thisBalloonEarnings, 2))
                bankedText = "You have banked:\n$" + str(round(bankedEarnings, 2))
                practice_reminder.reset()
                practice_balloonValTxt.reset()
                practice_bankedTxt.reset()
                # Run 'Begin Routine' code from practice_setBalloonSize
                balloonBody.setPos([0, balloonSize/2-.5])
                balloonBody.setSize(balloonSize)
                practice_trialcount.reset()
                practice_trialcount.setText('Ballon number： ' + str(practice_trials.thisN+1) +'/' + str(practice_trials.nTotal))
                # store start times for practice_trial
                practice_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                practice_trial.tStart = globalClock.getTime(format='float')
                practice_trial.status = STARTED
                thisExp.addData('practice_trial.started', practice_trial.tStart)
                practice_trial.maxDuration = None
                # keep track of which components have finished
                practice_trialComponents = practice_trial.components
                for thisComponent in practice_trial.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "practice_trial" ---
                practice_trial.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine:
                    # if trial has changed, end Routine now
                    if hasattr(thisPractice_pump, 'status') and thisPractice_pump.status == STOPPING:
                        continueRoutine = False
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *practice_bg* updates
                    
                    # if practice_bg is starting this frame...
                    if practice_bg.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_bg.frameNStart = frameN  # exact frame index
                        practice_bg.tStart = t  # local t and not account for scr refresh
                        practice_bg.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_bg, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_bg.started')
                        # update status
                        practice_bg.status = STARTED
                        practice_bg.setAutoDraw(True)
                    
                    # if practice_bg is active this frame...
                    if practice_bg.status == STARTED:
                        # update params
                        pass
                    
                    # *practice_bankButton* updates
                    waitOnFlip = False
                    
                    # if practice_bankButton is starting this frame...
                    if practice_bankButton.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_bankButton.frameNStart = frameN  # exact frame index
                        practice_bankButton.tStart = t  # local t and not account for scr refresh
                        practice_bankButton.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_bankButton, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_bankButton.started')
                        # update status
                        practice_bankButton.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(practice_bankButton.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(practice_bankButton.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if practice_bankButton.status == STARTED and not waitOnFlip:
                        theseKeys = practice_bankButton.getKeys(keyList=['return', 'space'], ignoreKeys=["escape"], waitRelease=False)
                        _practice_bankButton_allKeys.extend(theseKeys)
                        if len(_practice_bankButton_allKeys):
                            practice_bankButton.keys = _practice_bankButton_allKeys[-1].name  # just the last key pressed
                            practice_bankButton.rt = _practice_bankButton_allKeys[-1].rt
                            practice_bankButton.duration = _practice_bankButton_allKeys[-1].duration
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *practice_reminder* updates
                    
                    # if practice_reminder is starting this frame...
                    if practice_reminder.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_reminder.frameNStart = frameN  # exact frame index
                        practice_reminder.tStart = t  # local t and not account for scr refresh
                        practice_reminder.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_reminder, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_reminder.started')
                        # update status
                        practice_reminder.status = STARTED
                        practice_reminder.setAutoDraw(True)
                    
                    # if practice_reminder is active this frame...
                    if practice_reminder.status == STARTED:
                        # update params
                        pass
                    
                    # *practice_balloonValTxt* updates
                    
                    # if practice_balloonValTxt is starting this frame...
                    if practice_balloonValTxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_balloonValTxt.frameNStart = frameN  # exact frame index
                        practice_balloonValTxt.tStart = t  # local t and not account for scr refresh
                        practice_balloonValTxt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_balloonValTxt, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_balloonValTxt.started')
                        # update status
                        practice_balloonValTxt.status = STARTED
                        practice_balloonValTxt.setAutoDraw(True)
                    
                    # if practice_balloonValTxt is active this frame...
                    if practice_balloonValTxt.status == STARTED:
                        # update params
                        practice_balloonValTxt.setText(balloonEarnings, log=False)
                    
                    # *practice_bankedTxt* updates
                    
                    # if practice_bankedTxt is starting this frame...
                    if practice_bankedTxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_bankedTxt.frameNStart = frameN  # exact frame index
                        practice_bankedTxt.tStart = t  # local t and not account for scr refresh
                        practice_bankedTxt.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_bankedTxt, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_bankedTxt.started')
                        # update status
                        practice_bankedTxt.status = STARTED
                        practice_bankedTxt.setAutoDraw(True)
                    
                    # if practice_bankedTxt is active this frame...
                    if practice_bankedTxt.status == STARTED:
                        # update params
                        practice_bankedTxt.setText(bankedText, log=False)
                    # Run 'Each Frame' code from practice_setBalloonSize
                    balloonSize=0.1+(practice_pump.thisN+1)*0.015
                    
                    # *practice_balloonBody* updates
                    
                    # if practice_balloonBody is starting this frame...
                    if practice_balloonBody.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_balloonBody.frameNStart = frameN  # exact frame index
                        practice_balloonBody.tStart = t  # local t and not account for scr refresh
                        practice_balloonBody.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_balloonBody, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_balloonBody.started')
                        # update status
                        practice_balloonBody.status = STARTED
                        practice_balloonBody.setAutoDraw(True)
                    
                    # if practice_balloonBody is active this frame...
                    if practice_balloonBody.status == STARTED:
                        # update params
                        practice_balloonBody.setPos([0, balloonSize/2-.5], log=False)
                        practice_balloonBody.setSize(balloonSize, log=False)
                    
                    # *practice_trialcount* updates
                    
                    # if practice_trialcount is starting this frame...
                    if practice_trialcount.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        practice_trialcount.frameNStart = frameN  # exact frame index
                        practice_trialcount.tStart = t  # local t and not account for scr refresh
                        practice_trialcount.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(practice_trialcount, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_trialcount.started')
                        # update status
                        practice_trialcount.status = STARTED
                        practice_trialcount.setAutoDraw(True)
                    
                    # if practice_trialcount is active this frame...
                    if practice_trialcount.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer, globalClock], 
                            currentRoutine=practice_trial,
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        practice_trial.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in practice_trial.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "practice_trial" ---
                for thisComponent in practice_trial.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for practice_trial
                practice_trial.tStop = globalClock.getTime(format='float')
                practice_trial.tStopRefresh = tThisFlipGlobal
                thisExp.addData('practice_trial.stopped', practice_trial.tStop)
                # Run 'End Routine' code from practice_updateEarnings
                #calculate cash 'earned'
                if practice_pump.thisN+1 == practice_maxPumps:
                    popped = True
                else:
                    popped = False
                
                # if balloon popped reset the earnings
                if popped:
                  thisBalloonEarnings=0.0
                  lastBalloonEarnings=0.0
                else:
                    lastBalloonEarnings=thisBalloonEarnings
                
                if 'return' in practice_bankButton.keys:
                    practice_pump.finished = True
                
                
                # Run 'End Routine' code from practice_setBalloonSize
                #save data
                practice_trials.addData('nPumps', practice_pump.thisN+1)
                practice_trials.addData('size', balloonSize)
                practice_trials.addData('earnings', thisBalloonEarnings)
                practice_trials.addData('popped', popped)
                
                
                # the Routine "practice_trial" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                # mark thisPractice_pump as finished
                if hasattr(thisPractice_pump, 'status'):
                    thisPractice_pump.status = FINISHED
                # if awaiting a pause, pause now
                if practice_pump.status == PAUSED:
                    thisExp.status = PAUSED
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[globalClock], 
                    )
                    # once done pausing, restore running status
                    practice_pump.status = STARTED
                thisExp.nextEntry()
                
            # completed practice_maxPumps repeats of 'practice_pump'
            practice_pump.status = FINISHED
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # get names of stimulus parameters
            if practice_pump.trialList in ([], [None], None):
                params = []
            else:
                params = practice_pump.trialList[0].keys()
            # save data for this loop
            practice_pump.saveAsExcel(filename + '.xlsx', sheetName='practice_pump',
                stimOut=params,
                dataOut=['n','all_mean','all_std', 'all_raw'])
            practice_pump.saveAsText(filename + '_practice_pump.csv', delim=',',
                stimOut=params,
                dataOut=['n','all_mean','all_std', 'all_raw'])
            
            # --- Prepare to start Routine "practice_feedback" ---
            # create an object to store info about Routine practice_feedback
            practice_feedback = data.Routine(
                name='practice_feedback',
                components=[practice_background_3, practice_feedbacktxt, practice_bankedTxt_2, practice_reminder_2, practice_trialcount_2],
            )
            practice_feedback.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # Run 'Begin Routine' code from practice_checkPopped
            # track the banked earnings
            bankedEarnings = bankedEarnings+lastBalloonEarnings
            
            #update the text 
            balloonEarnings = "This balloon value:\n$" + str(round(thisBalloonEarnings, 2))
            bankedText = "You have banked:\n$" + str(round(bankedEarnings, 2))
            
            pop_sound.setVolume(1)
            
            # play the pop sound
            if popped==True:
              feedbackText="Oops!Lost that one!"
              pop_sound.play()
            else:
              feedbackText="You banked $" + str(round(lastBalloonEarnings, 2))
              
            practice_feedbacktxt.reset()
            practice_feedbacktxt.setText(feedbackText)
            practice_bankedTxt_2.reset()
            practice_reminder_2.reset()
            practice_trialcount_2.reset()
            practice_trialcount_2.setText('Ballon number： ' + str(practice_trials.thisN+1) +'/' + str(practice_trials.nTotal))
            # store start times for practice_feedback
            practice_feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            practice_feedback.tStart = globalClock.getTime(format='float')
            practice_feedback.status = STARTED
            thisExp.addData('practice_feedback.started', practice_feedback.tStart)
            practice_feedback.maxDuration = None
            # keep track of which components have finished
            practice_feedbackComponents = practice_feedback.components
            for thisComponent in practice_feedback.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "practice_feedback" ---
            practice_feedback.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.5:
                # if trial has changed, end Routine now
                if hasattr(thisPractice_trial, 'status') and thisPractice_trial.status == STOPPING:
                    continueRoutine = False
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *practice_background_3* updates
                
                # if practice_background_3 is starting this frame...
                if practice_background_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_background_3.frameNStart = frameN  # exact frame index
                    practice_background_3.tStart = t  # local t and not account for scr refresh
                    practice_background_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_background_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_background_3.started')
                    # update status
                    practice_background_3.status = STARTED
                    practice_background_3.setAutoDraw(True)
                
                # if practice_background_3 is active this frame...
                if practice_background_3.status == STARTED:
                    # update params
                    pass
                
                # if practice_background_3 is stopping this frame...
                if practice_background_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > practice_background_3.tStartRefresh + 1.5-frameTolerance:
                        # keep track of stop time/frame for later
                        practice_background_3.tStop = t  # not accounting for scr refresh
                        practice_background_3.tStopRefresh = tThisFlipGlobal  # on global time
                        practice_background_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_background_3.stopped')
                        # update status
                        practice_background_3.status = FINISHED
                        practice_background_3.setAutoDraw(False)
                
                # *practice_feedbacktxt* updates
                
                # if practice_feedbacktxt is starting this frame...
                if practice_feedbacktxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_feedbacktxt.frameNStart = frameN  # exact frame index
                    practice_feedbacktxt.tStart = t  # local t and not account for scr refresh
                    practice_feedbacktxt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_feedbacktxt, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_feedbacktxt.started')
                    # update status
                    practice_feedbacktxt.status = STARTED
                    practice_feedbacktxt.setAutoDraw(True)
                
                # if practice_feedbacktxt is active this frame...
                if practice_feedbacktxt.status == STARTED:
                    # update params
                    pass
                
                # if practice_feedbacktxt is stopping this frame...
                if practice_feedbacktxt.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > practice_feedbacktxt.tStartRefresh + 1.5-frameTolerance:
                        # keep track of stop time/frame for later
                        practice_feedbacktxt.tStop = t  # not accounting for scr refresh
                        practice_feedbacktxt.tStopRefresh = tThisFlipGlobal  # on global time
                        practice_feedbacktxt.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_feedbacktxt.stopped')
                        # update status
                        practice_feedbacktxt.status = FINISHED
                        practice_feedbacktxt.setAutoDraw(False)
                
                # *practice_bankedTxt_2* updates
                
                # if practice_bankedTxt_2 is starting this frame...
                if practice_bankedTxt_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_bankedTxt_2.frameNStart = frameN  # exact frame index
                    practice_bankedTxt_2.tStart = t  # local t and not account for scr refresh
                    practice_bankedTxt_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_bankedTxt_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_bankedTxt_2.started')
                    # update status
                    practice_bankedTxt_2.status = STARTED
                    practice_bankedTxt_2.setAutoDraw(True)
                
                # if practice_bankedTxt_2 is active this frame...
                if practice_bankedTxt_2.status == STARTED:
                    # update params
                    practice_bankedTxt_2.setText(bankedText, log=False)
                
                # if practice_bankedTxt_2 is stopping this frame...
                if practice_bankedTxt_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > practice_bankedTxt_2.tStartRefresh + 1.5-frameTolerance:
                        # keep track of stop time/frame for later
                        practice_bankedTxt_2.tStop = t  # not accounting for scr refresh
                        practice_bankedTxt_2.tStopRefresh = tThisFlipGlobal  # on global time
                        practice_bankedTxt_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_bankedTxt_2.stopped')
                        # update status
                        practice_bankedTxt_2.status = FINISHED
                        practice_bankedTxt_2.setAutoDraw(False)
                
                # *practice_reminder_2* updates
                
                # if practice_reminder_2 is starting this frame...
                if practice_reminder_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_reminder_2.frameNStart = frameN  # exact frame index
                    practice_reminder_2.tStart = t  # local t and not account for scr refresh
                    practice_reminder_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_reminder_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_reminder_2.started')
                    # update status
                    practice_reminder_2.status = STARTED
                    practice_reminder_2.setAutoDraw(True)
                
                # if practice_reminder_2 is active this frame...
                if practice_reminder_2.status == STARTED:
                    # update params
                    pass
                
                # if practice_reminder_2 is stopping this frame...
                if practice_reminder_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > practice_reminder_2.tStartRefresh + 1.5-frameTolerance:
                        # keep track of stop time/frame for later
                        practice_reminder_2.tStop = t  # not accounting for scr refresh
                        practice_reminder_2.tStopRefresh = tThisFlipGlobal  # on global time
                        practice_reminder_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_reminder_2.stopped')
                        # update status
                        practice_reminder_2.status = FINISHED
                        practice_reminder_2.setAutoDraw(False)
                
                # *practice_trialcount_2* updates
                
                # if practice_trialcount_2 is starting this frame...
                if practice_trialcount_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_trialcount_2.frameNStart = frameN  # exact frame index
                    practice_trialcount_2.tStart = t  # local t and not account for scr refresh
                    practice_trialcount_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_trialcount_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_trialcount_2.started')
                    # update status
                    practice_trialcount_2.status = STARTED
                    practice_trialcount_2.setAutoDraw(True)
                
                # if practice_trialcount_2 is active this frame...
                if practice_trialcount_2.status == STARTED:
                    # update params
                    pass
                
                # if practice_trialcount_2 is stopping this frame...
                if practice_trialcount_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > practice_trialcount_2.tStartRefresh + 1.5-frameTolerance:
                        # keep track of stop time/frame for later
                        practice_trialcount_2.tStop = t  # not accounting for scr refresh
                        practice_trialcount_2.tStopRefresh = tThisFlipGlobal  # on global time
                        practice_trialcount_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'practice_trialcount_2.stopped')
                        # update status
                        practice_trialcount_2.status = FINISHED
                        practice_trialcount_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer, globalClock], 
                        currentRoutine=practice_feedback,
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    practice_feedback.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in practice_feedback.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "practice_feedback" ---
            for thisComponent in practice_feedback.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for practice_feedback
            practice_feedback.tStop = globalClock.getTime(format='float')
            practice_feedback.tStopRefresh = tThisFlipGlobal
            thisExp.addData('practice_feedback.stopped', practice_feedback.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if practice_feedback.maxDurationReached:
                routineTimer.addTime(-practice_feedback.maxDuration)
            elif practice_feedback.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.500000)
            # mark thisPractice_trial as finished
            if hasattr(thisPractice_trial, 'status'):
                thisPractice_trial.status = FINISHED
            # if awaiting a pause, pause now
            if practice_trials.status == PAUSED:
                thisExp.status = PAUSED
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[globalClock], 
                )
                # once done pausing, restore running status
                practice_trials.status = STARTED
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'practice_trials'
        practice_trials.status = FINISHED
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # get names of stimulus parameters
        if practice_trials.trialList in ([], [None], None):
            params = []
        else:
            params = practice_trials.trialList[0].keys()
        # save data for this loop
        practice_trials.saveAsExcel(filename + '.xlsx', sheetName='practice_trials',
            stimOut=params,
            dataOut=['n','all_mean','all_std', 'all_raw'])
        practice_trials.saveAsText(filename + '_practice_trials.csv', delim=',',
            stimOut=params,
            dataOut=['n','all_mean','all_std', 'all_raw'])
        
        # --- Prepare to start Routine "practice_finalScore" ---
        # create an object to store info about Routine practice_finalScore
        practice_finalScore = data.Routine(
            name='practice_finalScore',
            components=[practice_background_4, practice_scoremsg, text, key_resp],
        )
        practice_finalScore.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from practice_finalScoreCode
        scoreText=u"Well done! You banked a total of\n£%2.f" % bankedEarnings
        practice_scoremsg.reset()
        practice_scoremsg.setText(scoreText)
        # create starting attributes for key_resp
        key_resp.keys = []
        key_resp.rt = []
        _key_resp_allKeys = []
        # store start times for practice_finalScore
        practice_finalScore.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        practice_finalScore.tStart = globalClock.getTime(format='float')
        practice_finalScore.status = STARTED
        thisExp.addData('practice_finalScore.started', practice_finalScore.tStart)
        practice_finalScore.maxDuration = None
        # keep track of which components have finished
        practice_finalScoreComponents = practice_finalScore.components
        for thisComponent in practice_finalScore.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "practice_finalScore" ---
        practice_finalScore.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisComprehension_loop, 'status') and thisComprehension_loop.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *practice_background_4* updates
            
            # if practice_background_4 is starting this frame...
            if practice_background_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                practice_background_4.frameNStart = frameN  # exact frame index
                practice_background_4.tStart = t  # local t and not account for scr refresh
                practice_background_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(practice_background_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'practice_background_4.started')
                # update status
                practice_background_4.status = STARTED
                practice_background_4.setAutoDraw(True)
            
            # if practice_background_4 is active this frame...
            if practice_background_4.status == STARTED:
                # update params
                pass
            
            # *practice_scoremsg* updates
            
            # if practice_scoremsg is starting this frame...
            if practice_scoremsg.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                practice_scoremsg.frameNStart = frameN  # exact frame index
                practice_scoremsg.tStart = t  # local t and not account for scr refresh
                practice_scoremsg.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(practice_scoremsg, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'practice_scoremsg.started')
                # update status
                practice_scoremsg.status = STARTED
                practice_scoremsg.setAutoDraw(True)
            
            # if practice_scoremsg is active this frame...
            if practice_scoremsg.status == STARTED:
                # update params
                pass
            
            # *text* updates
            
            # if text is starting this frame...
            if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text.frameNStart = frameN  # exact frame index
                text.tStart = t  # local t and not account for scr refresh
                text.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text.started')
                # update status
                text.status = STARTED
                text.setAutoDraw(True)
            
            # if text is active this frame...
            if text.status == STARTED:
                # update params
                pass
            
            # *key_resp* updates
            waitOnFlip = False
            
            # if key_resp is starting this frame...
            if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp.frameNStart = frameN  # exact frame index
                key_resp.tStart = t  # local t and not account for scr refresh
                key_resp.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp.started')
                # update status
                key_resp.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp.status == STARTED and not waitOnFlip:
                theseKeys = key_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_allKeys.extend(theseKeys)
                if len(_key_resp_allKeys):
                    key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                    key_resp.rt = _key_resp_allKeys[-1].rt
                    key_resp.duration = _key_resp_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=practice_finalScore,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                practice_finalScore.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in practice_finalScore.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "practice_finalScore" ---
        for thisComponent in practice_finalScore.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for practice_finalScore
        practice_finalScore.tStop = globalClock.getTime(format='float')
        practice_finalScore.tStopRefresh = tThisFlipGlobal
        thisExp.addData('practice_finalScore.stopped', practice_finalScore.tStop)
        # check responses
        if key_resp.keys in ['', [], None]:  # No response was made
            key_resp.keys = None
        comprehension_loop.addData('key_resp.keys',key_resp.keys)
        if key_resp.keys != None:  # we had a response
            comprehension_loop.addData('key_resp.rt', key_resp.rt)
            comprehension_loop.addData('key_resp.duration', key_resp.duration)
        # the Routine "practice_finalScore" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "resetmoneypractice" ---
        # create an object to store info about Routine resetmoneypractice
        resetmoneypractice = data.Routine(
            name='resetmoneypractice',
            components=[],
        )
        resetmoneypractice.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_4
        bankedEarnings = 0
        # store start times for resetmoneypractice
        resetmoneypractice.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        resetmoneypractice.tStart = globalClock.getTime(format='float')
        resetmoneypractice.status = STARTED
        thisExp.addData('resetmoneypractice.started', resetmoneypractice.tStart)
        resetmoneypractice.maxDuration = None
        # keep track of which components have finished
        resetmoneypracticeComponents = resetmoneypractice.components
        for thisComponent in resetmoneypractice.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "resetmoneypractice" ---
        resetmoneypractice.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisComprehension_loop, 'status') and thisComprehension_loop.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=resetmoneypractice,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                resetmoneypractice.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in resetmoneypractice.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "resetmoneypractice" ---
        for thisComponent in resetmoneypractice.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for resetmoneypractice
        resetmoneypractice.tStop = globalClock.getTime(format='float')
        resetmoneypractice.tStopRefresh = tThisFlipGlobal
        thisExp.addData('resetmoneypractice.stopped', resetmoneypractice.tStop)
        # the Routine "resetmoneypractice" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "comprehension_check" ---
        # create an object to store info about Routine comprehension_check
        comprehension_check = data.Routine(
            name='comprehension_check',
            components=[understand_2, key_resp_comprehension],
        )
        comprehension_check.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_comprehension
        key_resp_comprehension.keys = []
        key_resp_comprehension.rt = []
        _key_resp_comprehension_allKeys = []
        # store start times for comprehension_check
        comprehension_check.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        comprehension_check.tStart = globalClock.getTime(format='float')
        comprehension_check.status = STARTED
        thisExp.addData('comprehension_check.started', comprehension_check.tStart)
        comprehension_check.maxDuration = None
        # keep track of which components have finished
        comprehension_checkComponents = comprehension_check.components
        for thisComponent in comprehension_check.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "comprehension_check" ---
        comprehension_check.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisComprehension_loop, 'status') and thisComprehension_loop.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *understand_2* updates
            
            # if understand_2 is starting this frame...
            if understand_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                understand_2.frameNStart = frameN  # exact frame index
                understand_2.tStart = t  # local t and not account for scr refresh
                understand_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(understand_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'understand_2.started')
                # update status
                understand_2.status = STARTED
                understand_2.setAutoDraw(True)
            
            # if understand_2 is active this frame...
            if understand_2.status == STARTED:
                # update params
                pass
            
            # *key_resp_comprehension* updates
            waitOnFlip = False
            
            # if key_resp_comprehension is starting this frame...
            if key_resp_comprehension.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_comprehension.frameNStart = frameN  # exact frame index
                key_resp_comprehension.tStart = t  # local t and not account for scr refresh
                key_resp_comprehension.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_comprehension, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_comprehension.started')
                # update status
                key_resp_comprehension.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_comprehension.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_comprehension.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_comprehension.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_comprehension.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_comprehension_allKeys.extend(theseKeys)
                if len(_key_resp_comprehension_allKeys):
                    key_resp_comprehension.keys = _key_resp_comprehension_allKeys[-1].name  # just the last key pressed
                    key_resp_comprehension.rt = _key_resp_comprehension_allKeys[-1].rt
                    key_resp_comprehension.duration = _key_resp_comprehension_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=comprehension_check,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                comprehension_check.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in comprehension_check.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "comprehension_check" ---
        for thisComponent in comprehension_check.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for comprehension_check
        comprehension_check.tStop = globalClock.getTime(format='float')
        comprehension_check.tStopRefresh = tThisFlipGlobal
        thisExp.addData('comprehension_check.stopped', comprehension_check.tStop)
        # check responses
        if key_resp_comprehension.keys in ['', [], None]:  # No response was made
            key_resp_comprehension.keys = None
        comprehension_loop.addData('key_resp_comprehension.keys',key_resp_comprehension.keys)
        if key_resp_comprehension.keys != None:  # we had a response
            comprehension_loop.addData('key_resp_comprehension.rt', key_resp_comprehension.rt)
            comprehension_loop.addData('key_resp_comprehension.duration', key_resp_comprehension.duration)
        # Run 'End Routine' code from comprehension_code
        if key_resp_comprehension.keys == 'y':
            comprehension_loop.finished = True  # 结束当前循环，进入正式实验
        
        
        # the Routine "comprehension_check" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        # mark thisComprehension_loop as finished
        if hasattr(thisComprehension_loop, 'status'):
            thisComprehension_loop.status = FINISHED
        # if awaiting a pause, pause now
        if comprehension_loop.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            comprehension_loop.status = STARTED
        thisExp.nextEntry()
        
    # completed 1000.0 repeats of 'comprehension_loop'
    comprehension_loop.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if comprehension_loop.trialList in ([], [None], None):
        params = []
    else:
        params = comprehension_loop.trialList[0].keys()
    # save data for this loop
    comprehension_loop.saveAsExcel(filename + '.xlsx', sheetName='comprehension_loop',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    comprehension_loop.saveAsText(filename + '_comprehension_loop.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "Preparing_to_BART_formally" ---
    # create an object to store info about Routine Preparing_to_BART_formally
    Preparing_to_BART_formally = data.Routine(
        name='Preparing_to_BART_formally',
        components=[understand3_formal_BART, key_resp_comprehension_2],
    )
    Preparing_to_BART_formally.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_comprehension_2
    key_resp_comprehension_2.keys = []
    key_resp_comprehension_2.rt = []
    _key_resp_comprehension_2_allKeys = []
    # store start times for Preparing_to_BART_formally
    Preparing_to_BART_formally.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Preparing_to_BART_formally.tStart = globalClock.getTime(format='float')
    Preparing_to_BART_formally.status = STARTED
    thisExp.addData('Preparing_to_BART_formally.started', Preparing_to_BART_formally.tStart)
    Preparing_to_BART_formally.maxDuration = None
    # keep track of which components have finished
    Preparing_to_BART_formallyComponents = Preparing_to_BART_formally.components
    for thisComponent in Preparing_to_BART_formally.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Preparing_to_BART_formally" ---
    Preparing_to_BART_formally.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *understand3_formal_BART* updates
        
        # if understand3_formal_BART is starting this frame...
        if understand3_formal_BART.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            understand3_formal_BART.frameNStart = frameN  # exact frame index
            understand3_formal_BART.tStart = t  # local t and not account for scr refresh
            understand3_formal_BART.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(understand3_formal_BART, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'understand3_formal_BART.started')
            # update status
            understand3_formal_BART.status = STARTED
            understand3_formal_BART.setAutoDraw(True)
        
        # if understand3_formal_BART is active this frame...
        if understand3_formal_BART.status == STARTED:
            # update params
            pass
        
        # *key_resp_comprehension_2* updates
        waitOnFlip = False
        
        # if key_resp_comprehension_2 is starting this frame...
        if key_resp_comprehension_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_comprehension_2.frameNStart = frameN  # exact frame index
            key_resp_comprehension_2.tStart = t  # local t and not account for scr refresh
            key_resp_comprehension_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_comprehension_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_comprehension_2.started')
            # update status
            key_resp_comprehension_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_comprehension_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_comprehension_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_comprehension_2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_comprehension_2.getKeys(keyList=['y'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_comprehension_2_allKeys.extend(theseKeys)
            if len(_key_resp_comprehension_2_allKeys):
                key_resp_comprehension_2.keys = _key_resp_comprehension_2_allKeys[-1].name  # just the last key pressed
                key_resp_comprehension_2.rt = _key_resp_comprehension_2_allKeys[-1].rt
                key_resp_comprehension_2.duration = _key_resp_comprehension_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=Preparing_to_BART_formally,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Preparing_to_BART_formally.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Preparing_to_BART_formally.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Preparing_to_BART_formally" ---
    for thisComponent in Preparing_to_BART_formally.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Preparing_to_BART_formally
    Preparing_to_BART_formally.tStop = globalClock.getTime(format='float')
    Preparing_to_BART_formally.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Preparing_to_BART_formally.stopped', Preparing_to_BART_formally.tStop)
    # check responses
    if key_resp_comprehension_2.keys in ['', [], None]:  # No response was made
        key_resp_comprehension_2.keys = None
    thisExp.addData('key_resp_comprehension_2.keys',key_resp_comprehension_2.keys)
    if key_resp_comprehension_2.keys != None:  # we had a response
        thisExp.addData('key_resp_comprehension_2.rt', key_resp_comprehension_2.rt)
        thisExp.addData('key_resp_comprehension_2.duration', key_resp_comprehension_2.duration)
    thisExp.nextEntry()
    # the Routine "Preparing_to_BART_formally" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "resetmoney" ---
    # create an object to store info about Routine resetmoney
    resetmoney = data.Routine(
        name='resetmoney',
        components=[],
    )
    resetmoney.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_2
    bankedEarnings = 0
    # store start times for resetmoney
    resetmoney.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    resetmoney.tStart = globalClock.getTime(format='float')
    resetmoney.status = STARTED
    thisExp.addData('resetmoney.started', resetmoney.tStart)
    resetmoney.maxDuration = None
    # keep track of which components have finished
    resetmoneyComponents = resetmoney.components
    for thisComponent in resetmoney.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "resetmoney" ---
    resetmoney.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=resetmoney,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            resetmoney.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in resetmoney.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "resetmoney" ---
    for thisComponent in resetmoney.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for resetmoney
    resetmoney.tStop = globalClock.getTime(format='float')
    resetmoney.tStopRefresh = tThisFlipGlobal
    thisExp.addData('resetmoney.stopped', resetmoney.tStop)
    thisExp.nextEntry()
    # the Routine "resetmoney" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials = data.TrialHandler2(
        name='trials',
        nReps=1.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('spreadsheets/conditions.xlsx'), 
        seed=1832, 
    )
    thisExp.addLoop(trials)  # add the loop to the experiment
    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
    if thisTrial != None:
        for paramName in thisTrial:
            globals()[paramName] = thisTrial[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrial in trials:
        trials.status = STARTED
        if hasattr(thisTrial, 'status'):
            thisTrial.status = STARTED
        currentLoop = trials
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
        if thisTrial != None:
            for paramName in thisTrial:
                globals()[paramName] = thisTrial[paramName]
        
        # --- Prepare to start Routine "reset_balloon" ---
        # create an object to store info about Routine reset_balloon
        reset_balloon = data.Routine(
            name='reset_balloon',
            components=[],
        )
        reset_balloon.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code
        balloonSize=0.08
        popped=False
        nPumps=0
        
        # store start times for reset_balloon
        reset_balloon.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        reset_balloon.tStart = globalClock.getTime(format='float')
        reset_balloon.status = STARTED
        thisExp.addData('reset_balloon.started', reset_balloon.tStart)
        reset_balloon.maxDuration = None
        # keep track of which components have finished
        reset_balloonComponents = reset_balloon.components
        for thisComponent in reset_balloon.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "reset_balloon" ---
        reset_balloon.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrial, 'status') and thisTrial.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=reset_balloon,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                reset_balloon.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in reset_balloon.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "reset_balloon" ---
        for thisComponent in reset_balloon.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for reset_balloon
        reset_balloon.tStop = globalClock.getTime(format='float')
        reset_balloon.tStopRefresh = tThisFlipGlobal
        thisExp.addData('reset_balloon.stopped', reset_balloon.tStop)
        # the Routine "reset_balloon" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        pump = data.TrialHandler2(
            name='pump',
            nReps=maxPumps, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=[None], 
            seed=None, 
        )
        thisExp.addLoop(pump)  # add the loop to the experiment
        thisPump = pump.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPump.rgb)
        if thisPump != None:
            for paramName in thisPump:
                globals()[paramName] = thisPump[paramName]
        
        for thisPump in pump:
            pump.status = STARTED
            if hasattr(thisPump, 'status'):
                thisPump.status = STARTED
            currentLoop = pump
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            # abbreviate parameter names if possible (e.g. rgb = thisPump.rgb)
            if thisPump != None:
                for paramName in thisPump:
                    globals()[paramName] = thisPump[paramName]
            
            # --- Prepare to start Routine "trial" ---
            # create an object to store info about Routine trial
            trial = data.Routine(
                name='trial',
                components=[background_2, bankButton, reminder, balloonValTxt, bankedTxt, balloonBody, trialcount],
            )
            trial.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # create starting attributes for bankButton
            bankButton.keys = []
            bankButton.rt = []
            _bankButton_allKeys = []
            # Run 'Begin Routine' code from updateEarnings
            thisBalloonEarnings=(pump.thisN+1)*0.05
            balloonEarnings = "This balloon value:\n$" + str(round(thisBalloonEarnings, 2))
            bankedText = "You have banked:\n$" + str(round(bankedEarnings, 2))
            reminder.reset()
            balloonValTxt.reset()
            bankedTxt.reset()
            # Run 'Begin Routine' code from setBalloonSize
            balloonBody.setPos([0, balloonSize/2-.5])
            balloonBody.setSize(balloonSize)
            trialcount.reset()
            trialcount.setText('Ballon number： ' + str(trials.thisN+1) +'/' + str(trials.nTotal))
            # store start times for trial
            trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            trial.tStart = globalClock.getTime(format='float')
            trial.status = STARTED
            thisExp.addData('trial.started', trial.tStart)
            trial.maxDuration = None
            # keep track of which components have finished
            trialComponents = trial.components
            for thisComponent in trial.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "trial" ---
            trial.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine:
                # if trial has changed, end Routine now
                if hasattr(thisPump, 'status') and thisPump.status == STOPPING:
                    continueRoutine = False
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *background_2* updates
                
                # if background_2 is starting this frame...
                if background_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    background_2.frameNStart = frameN  # exact frame index
                    background_2.tStart = t  # local t and not account for scr refresh
                    background_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(background_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'background_2.started')
                    # update status
                    background_2.status = STARTED
                    background_2.setAutoDraw(True)
                
                # if background_2 is active this frame...
                if background_2.status == STARTED:
                    # update params
                    pass
                
                # *bankButton* updates
                waitOnFlip = False
                
                # if bankButton is starting this frame...
                if bankButton.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    bankButton.frameNStart = frameN  # exact frame index
                    bankButton.tStart = t  # local t and not account for scr refresh
                    bankButton.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(bankButton, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'bankButton.started')
                    # update status
                    bankButton.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(bankButton.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(bankButton.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if bankButton.status == STARTED and not waitOnFlip:
                    theseKeys = bankButton.getKeys(keyList=['return', 'space'], ignoreKeys=["escape"], waitRelease=False)
                    _bankButton_allKeys.extend(theseKeys)
                    if len(_bankButton_allKeys):
                        bankButton.keys = _bankButton_allKeys[-1].name  # just the last key pressed
                        bankButton.rt = _bankButton_allKeys[-1].rt
                        bankButton.duration = _bankButton_allKeys[-1].duration
                        # a response ends the routine
                        continueRoutine = False
                
                # *reminder* updates
                
                # if reminder is starting this frame...
                if reminder.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    reminder.frameNStart = frameN  # exact frame index
                    reminder.tStart = t  # local t and not account for scr refresh
                    reminder.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(reminder, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'reminder.started')
                    # update status
                    reminder.status = STARTED
                    reminder.setAutoDraw(True)
                
                # if reminder is active this frame...
                if reminder.status == STARTED:
                    # update params
                    pass
                
                # *balloonValTxt* updates
                
                # if balloonValTxt is starting this frame...
                if balloonValTxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    balloonValTxt.frameNStart = frameN  # exact frame index
                    balloonValTxt.tStart = t  # local t and not account for scr refresh
                    balloonValTxt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(balloonValTxt, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'balloonValTxt.started')
                    # update status
                    balloonValTxt.status = STARTED
                    balloonValTxt.setAutoDraw(True)
                
                # if balloonValTxt is active this frame...
                if balloonValTxt.status == STARTED:
                    # update params
                    balloonValTxt.setText(balloonEarnings, log=False)
                
                # *bankedTxt* updates
                
                # if bankedTxt is starting this frame...
                if bankedTxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    bankedTxt.frameNStart = frameN  # exact frame index
                    bankedTxt.tStart = t  # local t and not account for scr refresh
                    bankedTxt.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(bankedTxt, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'bankedTxt.started')
                    # update status
                    bankedTxt.status = STARTED
                    bankedTxt.setAutoDraw(True)
                
                # if bankedTxt is active this frame...
                if bankedTxt.status == STARTED:
                    # update params
                    bankedTxt.setText(bankedText, log=False)
                # Run 'Each Frame' code from setBalloonSize
                balloonSize=0.1+(pump.thisN+1)*0.015
                
                # *balloonBody* updates
                
                # if balloonBody is starting this frame...
                if balloonBody.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    balloonBody.frameNStart = frameN  # exact frame index
                    balloonBody.tStart = t  # local t and not account for scr refresh
                    balloonBody.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(balloonBody, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'balloonBody.started')
                    # update status
                    balloonBody.status = STARTED
                    balloonBody.setAutoDraw(True)
                
                # if balloonBody is active this frame...
                if balloonBody.status == STARTED:
                    # update params
                    balloonBody.setPos([0, balloonSize/2-.5], log=False)
                    balloonBody.setSize(balloonSize, log=False)
                
                # *trialcount* updates
                
                # if trialcount is starting this frame...
                if trialcount.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    trialcount.frameNStart = frameN  # exact frame index
                    trialcount.tStart = t  # local t and not account for scr refresh
                    trialcount.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(trialcount, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'trialcount.started')
                    # update status
                    trialcount.status = STARTED
                    trialcount.setAutoDraw(True)
                
                # if trialcount is active this frame...
                if trialcount.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer, globalClock], 
                        currentRoutine=trial,
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    trial.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in trial.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "trial" ---
            for thisComponent in trial.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for trial
            trial.tStop = globalClock.getTime(format='float')
            trial.tStopRefresh = tThisFlipGlobal
            thisExp.addData('trial.stopped', trial.tStop)
            # Run 'End Routine' code from updateEarnings
            #calculate cash 'earned'
            if pump.thisN+1 == maxPumps:
                popped = True
            else:
                popped = False
            
            # if balloon popped reset the earnings
            if popped:
              thisBalloonEarnings=0.0
              lastBalloonEarnings=0.0
            else:
                lastBalloonEarnings=thisBalloonEarnings
            
            if 'return' in bankButton.keys:
                pump.finished = True
            
            
            # Run 'End Routine' code from setBalloonSize
            #save data
            trials.addData('nPumps', pump.thisN+1)
            trials.addData('size', balloonSize)
            trials.addData('earnings', thisBalloonEarnings)
            trials.addData('popped', popped)
            
            
            # the Routine "trial" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            # mark thisPump as finished
            if hasattr(thisPump, 'status'):
                thisPump.status = FINISHED
            # if awaiting a pause, pause now
            if pump.status == PAUSED:
                thisExp.status = PAUSED
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[globalClock], 
                )
                # once done pausing, restore running status
                pump.status = STARTED
        # completed maxPumps repeats of 'pump'
        pump.status = FINISHED
        
        
        # --- Prepare to start Routine "feedback" ---
        # create an object to store info about Routine feedback
        feedback = data.Routine(
            name='feedback',
            components=[background_3, feedbacktxt, bankedTxt_2, balloonValTxt_2, reminder_2, trialcount_2],
        )
        feedback.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from checkPopped
        # track the banked earnings
        bankedEarnings = bankedEarnings+lastBalloonEarnings
        
        #update the text 
        balloonEarnings = "This balloon value:\n$" + str(round(thisBalloonEarnings, 2))
        bankedText = "You have banked:\n$" + str(round(bankedEarnings, 2))
        
        pop_sound.setVolume(1)
        
        # play the pop sound
        if popped==True:
          feedbackText="Oops!Lost that one!"
          pop_sound.play()
        else:
          feedbackText="You banked $" + str(round(lastBalloonEarnings, 2))
          
        feedbacktxt.reset()
        feedbacktxt.setText(feedbackText)
        bankedTxt_2.reset()
        balloonValTxt_2.reset()
        reminder_2.reset()
        trialcount_2.reset()
        trialcount_2.setText('Ballon number： ' + str(trials.thisN+1) +'/' + str(trials.nTotal))
        # store start times for feedback
        feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        feedback.tStart = globalClock.getTime(format='float')
        feedback.status = STARTED
        thisExp.addData('feedback.started', feedback.tStart)
        feedback.maxDuration = None
        # keep track of which components have finished
        feedbackComponents = feedback.components
        for thisComponent in feedback.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "feedback" ---
        feedback.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.5:
            # if trial has changed, end Routine now
            if hasattr(thisTrial, 'status') and thisTrial.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *background_3* updates
            
            # if background_3 is starting this frame...
            if background_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                background_3.frameNStart = frameN  # exact frame index
                background_3.tStart = t  # local t and not account for scr refresh
                background_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(background_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'background_3.started')
                # update status
                background_3.status = STARTED
                background_3.setAutoDraw(True)
            
            # if background_3 is active this frame...
            if background_3.status == STARTED:
                # update params
                pass
            
            # if background_3 is stopping this frame...
            if background_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > background_3.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    background_3.tStop = t  # not accounting for scr refresh
                    background_3.tStopRefresh = tThisFlipGlobal  # on global time
                    background_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'background_3.stopped')
                    # update status
                    background_3.status = FINISHED
                    background_3.setAutoDraw(False)
            
            # *feedbacktxt* updates
            
            # if feedbacktxt is starting this frame...
            if feedbacktxt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                feedbacktxt.frameNStart = frameN  # exact frame index
                feedbacktxt.tStart = t  # local t and not account for scr refresh
                feedbacktxt.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(feedbacktxt, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'feedbacktxt.started')
                # update status
                feedbacktxt.status = STARTED
                feedbacktxt.setAutoDraw(True)
            
            # if feedbacktxt is active this frame...
            if feedbacktxt.status == STARTED:
                # update params
                pass
            
            # if feedbacktxt is stopping this frame...
            if feedbacktxt.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > feedbacktxt.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    feedbacktxt.tStop = t  # not accounting for scr refresh
                    feedbacktxt.tStopRefresh = tThisFlipGlobal  # on global time
                    feedbacktxt.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'feedbacktxt.stopped')
                    # update status
                    feedbacktxt.status = FINISHED
                    feedbacktxt.setAutoDraw(False)
            
            # *bankedTxt_2* updates
            
            # if bankedTxt_2 is starting this frame...
            if bankedTxt_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                bankedTxt_2.frameNStart = frameN  # exact frame index
                bankedTxt_2.tStart = t  # local t and not account for scr refresh
                bankedTxt_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(bankedTxt_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'bankedTxt_2.started')
                # update status
                bankedTxt_2.status = STARTED
                bankedTxt_2.setAutoDraw(True)
            
            # if bankedTxt_2 is active this frame...
            if bankedTxt_2.status == STARTED:
                # update params
                bankedTxt_2.setText(bankedText, log=False)
            
            # if bankedTxt_2 is stopping this frame...
            if bankedTxt_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > bankedTxt_2.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    bankedTxt_2.tStop = t  # not accounting for scr refresh
                    bankedTxt_2.tStopRefresh = tThisFlipGlobal  # on global time
                    bankedTxt_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'bankedTxt_2.stopped')
                    # update status
                    bankedTxt_2.status = FINISHED
                    bankedTxt_2.setAutoDraw(False)
            
            # *balloonValTxt_2* updates
            
            # if balloonValTxt_2 is starting this frame...
            if balloonValTxt_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                balloonValTxt_2.frameNStart = frameN  # exact frame index
                balloonValTxt_2.tStart = t  # local t and not account for scr refresh
                balloonValTxt_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(balloonValTxt_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'balloonValTxt_2.started')
                # update status
                balloonValTxt_2.status = STARTED
                balloonValTxt_2.setAutoDraw(True)
            
            # if balloonValTxt_2 is active this frame...
            if balloonValTxt_2.status == STARTED:
                # update params
                balloonValTxt_2.setText(balloonEarnings, log=False)
            
            # if balloonValTxt_2 is stopping this frame...
            if balloonValTxt_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > balloonValTxt_2.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    balloonValTxt_2.tStop = t  # not accounting for scr refresh
                    balloonValTxt_2.tStopRefresh = tThisFlipGlobal  # on global time
                    balloonValTxt_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'balloonValTxt_2.stopped')
                    # update status
                    balloonValTxt_2.status = FINISHED
                    balloonValTxt_2.setAutoDraw(False)
            
            # *reminder_2* updates
            
            # if reminder_2 is starting this frame...
            if reminder_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                reminder_2.frameNStart = frameN  # exact frame index
                reminder_2.tStart = t  # local t and not account for scr refresh
                reminder_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(reminder_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'reminder_2.started')
                # update status
                reminder_2.status = STARTED
                reminder_2.setAutoDraw(True)
            
            # if reminder_2 is active this frame...
            if reminder_2.status == STARTED:
                # update params
                pass
            
            # if reminder_2 is stopping this frame...
            if reminder_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > reminder_2.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    reminder_2.tStop = t  # not accounting for scr refresh
                    reminder_2.tStopRefresh = tThisFlipGlobal  # on global time
                    reminder_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'reminder_2.stopped')
                    # update status
                    reminder_2.status = FINISHED
                    reminder_2.setAutoDraw(False)
            
            # *trialcount_2* updates
            
            # if trialcount_2 is starting this frame...
            if trialcount_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                trialcount_2.frameNStart = frameN  # exact frame index
                trialcount_2.tStart = t  # local t and not account for scr refresh
                trialcount_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(trialcount_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'trialcount_2.started')
                # update status
                trialcount_2.status = STARTED
                trialcount_2.setAutoDraw(True)
            
            # if trialcount_2 is active this frame...
            if trialcount_2.status == STARTED:
                # update params
                pass
            
            # if trialcount_2 is stopping this frame...
            if trialcount_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > trialcount_2.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    trialcount_2.tStop = t  # not accounting for scr refresh
                    trialcount_2.tStopRefresh = tThisFlipGlobal  # on global time
                    trialcount_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'trialcount_2.stopped')
                    # update status
                    trialcount_2.status = FINISHED
                    trialcount_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=feedback,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                feedback.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in feedback.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "feedback" ---
        for thisComponent in feedback.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for feedback
        feedback.tStop = globalClock.getTime(format='float')
        feedback.tStopRefresh = tThisFlipGlobal
        thisExp.addData('feedback.stopped', feedback.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if feedback.maxDurationReached:
            routineTimer.addTime(-feedback.maxDuration)
        elif feedback.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.500000)
        # mark thisTrial as finished
        if hasattr(thisTrial, 'status'):
            thisTrial.status = FINISHED
        # if awaiting a pause, pause now
        if trials.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials.status = STARTED
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials'
    trials.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials.trialList in ([], [None], None):
        params = []
    else:
        params = trials.trialList[0].keys()
    # save data for this loop
    trials.saveAsExcel(filename + '.xlsx', sheetName='trials',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials.saveAsText(filename + '_trials.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "finalScore" ---
    # create an object to store info about Routine finalScore
    finalScore = data.Routine(
        name='finalScore',
        components=[background_4, scoremsg, text_2, key_resp_2],
    )
    finalScore.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from finalScoreCode
    scoreText=u"Well done! You banked a total of\n£%2.f" % bankedEarnings
    scoremsg.reset()
    scoremsg.setText(scoreText)
    # create starting attributes for key_resp_2
    key_resp_2.keys = []
    key_resp_2.rt = []
    _key_resp_2_allKeys = []
    # store start times for finalScore
    finalScore.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    finalScore.tStart = globalClock.getTime(format='float')
    finalScore.status = STARTED
    thisExp.addData('finalScore.started', finalScore.tStart)
    finalScore.maxDuration = None
    # keep track of which components have finished
    finalScoreComponents = finalScore.components
    for thisComponent in finalScore.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "finalScore" ---
    finalScore.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *background_4* updates
        
        # if background_4 is starting this frame...
        if background_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            background_4.frameNStart = frameN  # exact frame index
            background_4.tStart = t  # local t and not account for scr refresh
            background_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(background_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'background_4.started')
            # update status
            background_4.status = STARTED
            background_4.setAutoDraw(True)
        
        # if background_4 is active this frame...
        if background_4.status == STARTED:
            # update params
            pass
        
        # *scoremsg* updates
        
        # if scoremsg is starting this frame...
        if scoremsg.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            scoremsg.frameNStart = frameN  # exact frame index
            scoremsg.tStart = t  # local t and not account for scr refresh
            scoremsg.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(scoremsg, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'scoremsg.started')
            # update status
            scoremsg.status = STARTED
            scoremsg.setAutoDraw(True)
        
        # if scoremsg is active this frame...
        if scoremsg.status == STARTED:
            # update params
            pass
        
        # *text_2* updates
        
        # if text_2 is starting this frame...
        if text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_2.frameNStart = frameN  # exact frame index
            text_2.tStart = t  # local t and not account for scr refresh
            text_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_2.started')
            # update status
            text_2.status = STARTED
            text_2.setAutoDraw(True)
        
        # if text_2 is active this frame...
        if text_2.status == STARTED:
            # update params
            pass
        
        # *key_resp_2* updates
        waitOnFlip = False
        
        # if key_resp_2 is starting this frame...
        if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_2.frameNStart = frameN  # exact frame index
            key_resp_2.tStart = t  # local t and not account for scr refresh
            key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_2.started')
            # update status
            key_resp_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_2_allKeys.extend(theseKeys)
            if len(_key_resp_2_allKeys):
                key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
                key_resp_2.rt = _key_resp_2_allKeys[-1].rt
                key_resp_2.duration = _key_resp_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=finalScore,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            finalScore.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in finalScore.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "finalScore" ---
    for thisComponent in finalScore.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for finalScore
    finalScore.tStop = globalClock.getTime(format='float')
    finalScore.tStopRefresh = tThisFlipGlobal
    thisExp.addData('finalScore.stopped', finalScore.tStop)
    # check responses
    if key_resp_2.keys in ['', [], None]:  # No response was made
        key_resp_2.keys = None
    thisExp.addData('key_resp_2.keys',key_resp_2.keys)
    if key_resp_2.keys != None:  # we had a response
        thisExp.addData('key_resp_2.rt', key_resp_2.rt)
        thisExp.addData('key_resp_2.duration', key_resp_2.duration)
    thisExp.nextEntry()
    # the Routine "finalScore" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instruction_fish" ---
    # create an object to store info about Routine instruction_fish
    instruction_fish = data.Routine(
        name='instruction_fish',
        components=[background_fish, instructions_txt_fish, mouse_start, start_button_fish],
    )
    instruction_fish.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    instructions_txt_fish.reset()
    # setup some python lists for storing info about the mouse_start
    mouse_start.x = []
    mouse_start.y = []
    mouse_start.leftButton = []
    mouse_start.midButton = []
    mouse_start.rightButton = []
    mouse_start.time = []
    gotValidClick = False  # until a click is received
    # reset start_button_fish to account for continued clicks & clear times on/off
    start_button_fish.reset()
    # store start times for instruction_fish
    instruction_fish.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instruction_fish.tStart = globalClock.getTime(format='float')
    instruction_fish.status = STARTED
    thisExp.addData('instruction_fish.started', instruction_fish.tStart)
    instruction_fish.maxDuration = None
    # keep track of which components have finished
    instruction_fishComponents = instruction_fish.components
    for thisComponent in instruction_fish.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instruction_fish" ---
    instruction_fish.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *background_fish* updates
        
        # if background_fish is starting this frame...
        if background_fish.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            background_fish.frameNStart = frameN  # exact frame index
            background_fish.tStart = t  # local t and not account for scr refresh
            background_fish.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(background_fish, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'background_fish.started')
            # update status
            background_fish.status = STARTED
            background_fish.setAutoDraw(True)
        
        # if background_fish is active this frame...
        if background_fish.status == STARTED:
            # update params
            pass
        
        # *instructions_txt_fish* updates
        
        # if instructions_txt_fish is starting this frame...
        if instructions_txt_fish.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            instructions_txt_fish.frameNStart = frameN  # exact frame index
            instructions_txt_fish.tStart = t  # local t and not account for scr refresh
            instructions_txt_fish.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(instructions_txt_fish, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'instructions_txt_fish.started')
            # update status
            instructions_txt_fish.status = STARTED
            instructions_txt_fish.setAutoDraw(True)
        
        # if instructions_txt_fish is active this frame...
        if instructions_txt_fish.status == STARTED:
            # update params
            pass
        # *mouse_start* updates
        
        # if mouse_start is starting this frame...
        if mouse_start.status == NOT_STARTED and t >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            mouse_start.frameNStart = frameN  # exact frame index
            mouse_start.tStart = t  # local t and not account for scr refresh
            mouse_start.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(mouse_start, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.addData('mouse_start.started', t)
            # update status
            mouse_start.status = STARTED
            mouse_start.mouseClock.reset()
            prevButtonState = mouse_start.getPressed()  # if button is down already this ISN'T a new click
        if mouse_start.status == STARTED:  # only update if started and not finished!
            buttons = mouse_start.getPressed()
            if buttons != prevButtonState:  # button state changed?
                prevButtonState = buttons
                if sum(buttons) > 0:  # state changed to a new click
                    pass
                    x, y = mouse_start.getPos()
                    mouse_start.x.append(x)
                    mouse_start.y.append(y)
                    buttons = mouse_start.getPressed()
                    mouse_start.leftButton.append(buttons[0])
                    mouse_start.midButton.append(buttons[1])
                    mouse_start.rightButton.append(buttons[2])
                    mouse_start.time.append(mouse_start.mouseClock.getTime())
                    
                    continueRoutine = False  # end routine on response
        # *start_button_fish* updates
        
        # if start_button_fish is starting this frame...
        if start_button_fish.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            start_button_fish.frameNStart = frameN  # exact frame index
            start_button_fish.tStart = t  # local t and not account for scr refresh
            start_button_fish.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(start_button_fish, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'start_button_fish.started')
            # update status
            start_button_fish.status = STARTED
            win.callOnFlip(start_button_fish.buttonClock.reset)
            start_button_fish.setAutoDraw(True)
        
        # if start_button_fish is active this frame...
        if start_button_fish.status == STARTED:
            # update params
            pass
            # check whether start_button_fish has been pressed
            if start_button_fish.isClicked:
                if not start_button_fish.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    start_button_fish.timesOn.append(start_button_fish.buttonClock.getTime())
                    start_button_fish.timesOff.append(start_button_fish.buttonClock.getTime())
                elif len(start_button_fish.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    start_button_fish.timesOff[-1] = start_button_fish.buttonClock.getTime()
                if not start_button_fish.wasClicked:
                    # end routine when start_button_fish is clicked
                    continueRoutine = False
                if not start_button_fish.wasClicked:
                    # run callback code when start_button_fish is clicked
                    pass
        # take note of whether start_button_fish was clicked, so that next frame we know if clicks are new
        start_button_fish.wasClicked = start_button_fish.isClicked and start_button_fish.status == STARTED
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=instruction_fish,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instruction_fish.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instruction_fish.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instruction_fish" ---
    for thisComponent in instruction_fish.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instruction_fish
    instruction_fish.tStop = globalClock.getTime(format='float')
    instruction_fish.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instruction_fish.stopped', instruction_fish.tStop)
    # store data for thisExp (ExperimentHandler)
    thisExp.addData('mouse_start.x', mouse_start.x)
    thisExp.addData('mouse_start.y', mouse_start.y)
    thisExp.addData('mouse_start.leftButton', mouse_start.leftButton)
    thisExp.addData('mouse_start.midButton', mouse_start.midButton)
    thisExp.addData('mouse_start.rightButton', mouse_start.rightButton)
    thisExp.addData('mouse_start.time', mouse_start.time)
    thisExp.addData('start_button_fish.numClicks', start_button_fish.numClicks)
    if start_button_fish.numClicks:
       thisExp.addData('start_button_fish.timesOn', start_button_fish.timesOn)
       thisExp.addData('start_button_fish.timesOff', start_button_fish.timesOff)
    else:
       thisExp.addData('start_button_fish.timesOn', "")
       thisExp.addData('start_button_fish.timesOff', "")
    thisExp.nextEntry()
    # the Routine "instruction_fish" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_fish = data.TrialHandler2(
        name='trials_fish',
        nReps=100.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_fish)  # add the loop to the experiment
    thisTrials_fish = trials_fish.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_fish.rgb)
    if thisTrials_fish != None:
        for paramName in thisTrials_fish:
            globals()[paramName] = thisTrials_fish[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_fish in trials_fish:
        trials_fish.status = STARTED
        if hasattr(thisTrials_fish, 'status'):
            thisTrials_fish.status = STARTED
        currentLoop = trials_fish
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_fish.rgb)
        if thisTrials_fish != None:
            for paramName in thisTrials_fish:
                globals()[paramName] = thisTrials_fish[paramName]
        
        # --- Prepare to start Routine "trial_fish" ---
        # create an object to store info about Routine trial_fish
        trial_fish = data.Routine(
            name='trial_fish',
            components=[instruct_fish, lake1, lake2, lake3, mouse, rod, fishcountim, fishcount, fishTrialDisplay],
        )
        trial_fish.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        instruct_fish.reset()
        # setup some python lists for storing info about the mouse
        mouse.x = []
        mouse.y = []
        mouse.leftButton = []
        mouse.midButton = []
        mouse.rightButton = []
        mouse.time = []
        mouse.clicked_name = []
        gotValidClick = False  # until a click is received
        # Run 'Begin Routine' code from control_wins
        # configure the probability of win with each lake
        if len(lake1_wins) == 0:
            lake1_wins = [0,0,0,0,0, 0, 0, 1, 1, 1]#3 in 10 will win
        if len(lake2_wins) == 0:
            lake2_wins = [0,0,0,0,0, 1, 1, 1, 1, 1]# 5 in 10 will win
        if len(lake3_wins) == 0:
            lake3_wins = [0,0,1, 1,1, 1, 1, 1, 1, 1]#7 in 10 will win
        
        # shuffle the outcomes
        shuffle(lake1_wins)
        shuffle(lake2_wins)
        shuffle(lake3_wins)
        
        # temporary fix for stimuli setting each frame online in version 2024.2.4
        rod.setPos([-500, -500])
        fishcount.reset()
        fishcount.setText('Fish caught: ' + str(nfish))
        # Run 'Begin Routine' code from fishCounter
        fish_trial_index += 1
        fish_remaining = 100 - fish_trial_index
        fish_trial_text = "Fishing trial " + str(fish_trial_index) + " of 100\nRemaining chances: " + str(fish_remaining)
        
        fishTrialDisplay.setText(fish_trial_text)
        # store start times for trial_fish
        trial_fish.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        trial_fish.tStart = globalClock.getTime(format='float')
        trial_fish.status = STARTED
        thisExp.addData('trial_fish.started', trial_fish.tStart)
        trial_fish.maxDuration = None
        # keep track of which components have finished
        trial_fishComponents = trial_fish.components
        for thisComponent in trial_fish.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "trial_fish" ---
        trial_fish.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_fish, 'status') and thisTrials_fish.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instruct_fish* updates
            
            # if instruct_fish is starting this frame...
            if instruct_fish.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instruct_fish.frameNStart = frameN  # exact frame index
                instruct_fish.tStart = t  # local t and not account for scr refresh
                instruct_fish.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instruct_fish, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instruct_fish.started')
                # update status
                instruct_fish.status = STARTED
                instruct_fish.setAutoDraw(True)
            
            # if instruct_fish is active this frame...
            if instruct_fish.status == STARTED:
                # update params
                pass
            
            # *lake1* updates
            
            # if lake1 is starting this frame...
            if lake1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                lake1.frameNStart = frameN  # exact frame index
                lake1.tStart = t  # local t and not account for scr refresh
                lake1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(lake1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'lake1.started')
                # update status
                lake1.status = STARTED
                lake1.setAutoDraw(True)
            
            # if lake1 is active this frame...
            if lake1.status == STARTED:
                # update params
                pass
            
            # *lake2* updates
            
            # if lake2 is starting this frame...
            if lake2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                lake2.frameNStart = frameN  # exact frame index
                lake2.tStart = t  # local t and not account for scr refresh
                lake2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(lake2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'lake2.started')
                # update status
                lake2.status = STARTED
                lake2.setAutoDraw(True)
            
            # if lake2 is active this frame...
            if lake2.status == STARTED:
                # update params
                pass
            
            # *lake3* updates
            
            # if lake3 is starting this frame...
            if lake3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                lake3.frameNStart = frameN  # exact frame index
                lake3.tStart = t  # local t and not account for scr refresh
                lake3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(lake3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'lake3.started')
                # update status
                lake3.status = STARTED
                lake3.setAutoDraw(True)
            
            # if lake3 is active this frame...
            if lake3.status == STARTED:
                # update params
                pass
            # *mouse* updates
            
            # if mouse is starting this frame...
            if mouse.status == NOT_STARTED and t >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                mouse.frameNStart = frameN  # exact frame index
                mouse.tStart = t  # local t and not account for scr refresh
                mouse.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(mouse, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.addData('mouse.started', t)
                # update status
                mouse.status = STARTED
                mouse.mouseClock.reset()
                prevButtonState = mouse.getPressed()  # if button is down already this ISN'T a new click
            if mouse.status == STARTED:  # only update if started and not finished!
                buttons = mouse.getPressed()
                if buttons != prevButtonState:  # button state changed?
                    prevButtonState = buttons
                    if sum(buttons) > 0:  # state changed to a new click
                        # check if the mouse was inside our 'clickable' objects
                        gotValidClick = False
                        clickableList = environmenttools.getFromNames([lake1, lake2, lake3], namespace=locals())
                        for obj in clickableList:
                            # is this object clicked on?
                            if obj.contains(mouse):
                                gotValidClick = True
                                mouse.clicked_name.append(obj.name)
                                mouse.clicked_name.append(obj.name)
                        if gotValidClick:
                            x, y = mouse.getPos()
                            mouse.x.append(x)
                            mouse.y.append(y)
                            buttons = mouse.getPressed()
                            mouse.leftButton.append(buttons[0])
                            mouse.midButton.append(buttons[1])
                            mouse.rightButton.append(buttons[2])
                            mouse.time.append(mouse.mouseClock.getTime())
                        if gotValidClick:
                            continueRoutine = False  # end routine on response
            
            # *rod* updates
            
            # if rod is starting this frame...
            if rod.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rod.frameNStart = frameN  # exact frame index
                rod.tStart = t  # local t and not account for scr refresh
                rod.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rod, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rod.started')
                # update status
                rod.status = STARTED
                rod.setAutoDraw(True)
            
            # if rod is active this frame...
            if rod.status == STARTED:
                # update params
                rod.setPos([mouse.getPos()], log=False)
            
            # *fishcountim* updates
            
            # if fishcountim is starting this frame...
            if fishcountim.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fishcountim.frameNStart = frameN  # exact frame index
                fishcountim.tStart = t  # local t and not account for scr refresh
                fishcountim.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fishcountim, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fishcountim.started')
                # update status
                fishcountim.status = STARTED
                fishcountim.setAutoDraw(True)
            
            # if fishcountim is active this frame...
            if fishcountim.status == STARTED:
                # update params
                pass
            
            # *fishcount* updates
            
            # if fishcount is starting this frame...
            if fishcount.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fishcount.frameNStart = frameN  # exact frame index
                fishcount.tStart = t  # local t and not account for scr refresh
                fishcount.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fishcount, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fishcount.started')
                # update status
                fishcount.status = STARTED
                fishcount.setAutoDraw(True)
            
            # if fishcount is active this frame...
            if fishcount.status == STARTED:
                # update params
                pass
            
            # *fishTrialDisplay* updates
            
            # if fishTrialDisplay is starting this frame...
            if fishTrialDisplay.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fishTrialDisplay.frameNStart = frameN  # exact frame index
                fishTrialDisplay.tStart = t  # local t and not account for scr refresh
                fishTrialDisplay.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fishTrialDisplay, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fishTrialDisplay.started')
                # update status
                fishTrialDisplay.status = STARTED
                fishTrialDisplay.setAutoDraw(True)
            
            # if fishTrialDisplay is active this frame...
            if fishTrialDisplay.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=trial_fish,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                trial_fish.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in trial_fish.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "trial_fish" ---
        for thisComponent in trial_fish.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for trial_fish
        trial_fish.tStop = globalClock.getTime(format='float')
        trial_fish.tStopRefresh = tThisFlipGlobal
        thisExp.addData('trial_fish.stopped', trial_fish.tStop)
        # store data for trials_fish (TrialHandler)
        trials_fish.addData('mouse.x', mouse.x)
        trials_fish.addData('mouse.y', mouse.y)
        trials_fish.addData('mouse.leftButton', mouse.leftButton)
        trials_fish.addData('mouse.midButton', mouse.midButton)
        trials_fish.addData('mouse.rightButton', mouse.rightButton)
        trials_fish.addData('mouse.time', mouse.time)
        trials_fish.addData('mouse.clicked_name', mouse.clicked_name)
        # Run 'End Routine' code from control_wins
        # sample an outcome based on click 
        if mouse.clicked_name[-1] == 'lake1':
            outcome = lake1_wins[-1]
            lake1_wins.pop() # remove outcome i.e. sample without replacement
        if mouse.clicked_name[-1] == 'lake2':
            outcome = lake2_wins[-1]
            lake2_wins.pop()# remove outcome i.e. sample without replacement
        if mouse.clicked_name[-1] == 'lake3':
            outcome = lake3_wins[-1]
            lake3_wins.pop()# remove outcome i.e. sample without replacement
        
        
        # check if the outcome was a win or not
        if outcome == 1:
            fb_txt = 'You caught a fish!'
        else:
            fb_txt = 'You did not catch a fish.'
        
        # store outcome to data file
        thisExp.addData('outcome', outcome)
        
        # update nfish
        nfish += outcome
        
        # store to data file
        thisExp.addData('nfish', nfish)
        # the Routine "trial_fish" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "feedback_fish" ---
        # create an object to store info about Routine feedback_fish
        feedback_fish = data.Routine(
            name='feedback_fish',
            components=[fb_txtbox, fb_image, fishcountim_2, fishcount_2],
        )
        feedback_fish.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_fish
        # randomly pick a fish image to present if a fish caught
        if outcome == 1:
            fish_images = ['images/fish2.png', 'images/fish3.png', 'images/fish4.png']
            shuffle(fish_images)
            fish_im = fish_images[-1]
        else:
            # if no fish won show no fish
            fish_im ='images/nofish.png'
        
        # store fish image to data file
        thisExp.addData('fish_im', fish_im)
        fb_txtbox.reset()
        fb_txtbox.setText(fb_txt )
        fb_image.setImage(fish_im)
        fishcount_2.reset()
        fishcount_2.setText('Fish caught: ' + str(nfish))
        # store start times for feedback_fish
        feedback_fish.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        feedback_fish.tStart = globalClock.getTime(format='float')
        feedback_fish.status = STARTED
        thisExp.addData('feedback_fish.started', feedback_fish.tStart)
        feedback_fish.maxDuration = None
        # keep track of which components have finished
        feedback_fishComponents = feedback_fish.components
        for thisComponent in feedback_fish.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "feedback_fish" ---
        feedback_fish.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # if trial has changed, end Routine now
            if hasattr(thisTrials_fish, 'status') and thisTrials_fish.status == STOPPING:
                continueRoutine = False
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *fb_txtbox* updates
            
            # if fb_txtbox is starting this frame...
            if fb_txtbox.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fb_txtbox.frameNStart = frameN  # exact frame index
                fb_txtbox.tStart = t  # local t and not account for scr refresh
                fb_txtbox.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fb_txtbox, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fb_txtbox.started')
                # update status
                fb_txtbox.status = STARTED
                fb_txtbox.setAutoDraw(True)
            
            # if fb_txtbox is active this frame...
            if fb_txtbox.status == STARTED:
                # update params
                pass
            
            # if fb_txtbox is stopping this frame...
            if fb_txtbox.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > fb_txtbox.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    fb_txtbox.tStop = t  # not accounting for scr refresh
                    fb_txtbox.tStopRefresh = tThisFlipGlobal  # on global time
                    fb_txtbox.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fb_txtbox.stopped')
                    # update status
                    fb_txtbox.status = FINISHED
                    fb_txtbox.setAutoDraw(False)
            
            # *fb_image* updates
            
            # if fb_image is starting this frame...
            if fb_image.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fb_image.frameNStart = frameN  # exact frame index
                fb_image.tStart = t  # local t and not account for scr refresh
                fb_image.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fb_image, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fb_image.started')
                # update status
                fb_image.status = STARTED
                fb_image.setAutoDraw(True)
            
            # if fb_image is active this frame...
            if fb_image.status == STARTED:
                # update params
                pass
            
            # if fb_image is stopping this frame...
            if fb_image.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > fb_image.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    fb_image.tStop = t  # not accounting for scr refresh
                    fb_image.tStopRefresh = tThisFlipGlobal  # on global time
                    fb_image.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fb_image.stopped')
                    # update status
                    fb_image.status = FINISHED
                    fb_image.setAutoDraw(False)
            
            # *fishcountim_2* updates
            
            # if fishcountim_2 is starting this frame...
            if fishcountim_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fishcountim_2.frameNStart = frameN  # exact frame index
                fishcountim_2.tStart = t  # local t and not account for scr refresh
                fishcountim_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fishcountim_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fishcountim_2.started')
                # update status
                fishcountim_2.status = STARTED
                fishcountim_2.setAutoDraw(True)
            
            # if fishcountim_2 is active this frame...
            if fishcountim_2.status == STARTED:
                # update params
                pass
            
            # if fishcountim_2 is stopping this frame...
            if fishcountim_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > fishcountim_2.tStartRefresh + 1-frameTolerance:
                    # keep track of stop time/frame for later
                    fishcountim_2.tStop = t  # not accounting for scr refresh
                    fishcountim_2.tStopRefresh = tThisFlipGlobal  # on global time
                    fishcountim_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fishcountim_2.stopped')
                    # update status
                    fishcountim_2.status = FINISHED
                    fishcountim_2.setAutoDraw(False)
            
            # *fishcount_2* updates
            
            # if fishcount_2 is starting this frame...
            if fishcount_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                fishcount_2.frameNStart = frameN  # exact frame index
                fishcount_2.tStart = t  # local t and not account for scr refresh
                fishcount_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(fishcount_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'fishcount_2.started')
                # update status
                fishcount_2.status = STARTED
                fishcount_2.setAutoDraw(True)
            
            # if fishcount_2 is active this frame...
            if fishcount_2.status == STARTED:
                # update params
                pass
            
            # if fishcount_2 is stopping this frame...
            if fishcount_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > fishcount_2.tStartRefresh + 1-frameTolerance:
                    # keep track of stop time/frame for later
                    fishcount_2.tStop = t  # not accounting for scr refresh
                    fishcount_2.tStopRefresh = tThisFlipGlobal  # on global time
                    fishcount_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fishcount_2.stopped')
                    # update status
                    fishcount_2.status = FINISHED
                    fishcount_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer, globalClock], 
                    currentRoutine=feedback_fish,
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                feedback_fish.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in feedback_fish.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "feedback_fish" ---
        for thisComponent in feedback_fish.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for feedback_fish
        feedback_fish.tStop = globalClock.getTime(format='float')
        feedback_fish.tStopRefresh = tThisFlipGlobal
        thisExp.addData('feedback_fish.stopped', feedback_fish.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if feedback_fish.maxDurationReached:
            routineTimer.addTime(-feedback_fish.maxDuration)
        elif feedback_fish.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        # mark thisTrials_fish as finished
        if hasattr(thisTrials_fish, 'status'):
            thisTrials_fish.status = FINISHED
        # if awaiting a pause, pause now
        if trials_fish.status == PAUSED:
            thisExp.status = PAUSED
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[globalClock], 
            )
            # once done pausing, restore running status
            trials_fish.status = STARTED
        thisExp.nextEntry()
        
    # completed 100.0 repeats of 'trials_fish'
    trials_fish.status = FINISHED
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    # get names of stimulus parameters
    if trials_fish.trialList in ([], [None], None):
        params = []
    else:
        params = trials_fish.trialList[0].keys()
    # save data for this loop
    trials_fish.saveAsExcel(filename + '.xlsx', sheetName='trials_fish',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    trials_fish.saveAsText(filename + '_trials_fish.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # --- Prepare to start Routine "end_fish" ---
    # create an object to store info about Routine end_fish
    end_fish = data.Routine(
        name='end_fish',
        components=[background_5, end_txt, exit_button, text_5],
    )
    end_fish.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    end_txt.reset()
    end_txt.setText('That is the end! \nYou caught ' + str(nfish) + ' fish!\nPlease click the button below to exit!')
    # reset exit_button to account for continued clicks & clear times on/off
    exit_button.reset()
    # store start times for end_fish
    end_fish.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_fish.tStart = globalClock.getTime(format='float')
    end_fish.status = STARTED
    thisExp.addData('end_fish.started', end_fish.tStart)
    end_fish.maxDuration = None
    # keep track of which components have finished
    end_fishComponents = end_fish.components
    for thisComponent in end_fish.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_fish" ---
    end_fish.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *background_5* updates
        
        # if background_5 is starting this frame...
        if background_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            background_5.frameNStart = frameN  # exact frame index
            background_5.tStart = t  # local t and not account for scr refresh
            background_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(background_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'background_5.started')
            # update status
            background_5.status = STARTED
            background_5.setAutoDraw(True)
        
        # if background_5 is active this frame...
        if background_5.status == STARTED:
            # update params
            pass
        
        # *end_txt* updates
        
        # if end_txt is starting this frame...
        if end_txt.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            end_txt.frameNStart = frameN  # exact frame index
            end_txt.tStart = t  # local t and not account for scr refresh
            end_txt.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(end_txt, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'end_txt.started')
            # update status
            end_txt.status = STARTED
            end_txt.setAutoDraw(True)
        
        # if end_txt is active this frame...
        if end_txt.status == STARTED:
            # update params
            pass
        # *exit_button* updates
        
        # if exit_button is starting this frame...
        if exit_button.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            exit_button.frameNStart = frameN  # exact frame index
            exit_button.tStart = t  # local t and not account for scr refresh
            exit_button.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(exit_button, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'exit_button.started')
            # update status
            exit_button.status = STARTED
            win.callOnFlip(exit_button.buttonClock.reset)
            exit_button.setAutoDraw(True)
        
        # if exit_button is active this frame...
        if exit_button.status == STARTED:
            # update params
            pass
            # check whether exit_button has been pressed
            if exit_button.isClicked:
                if not exit_button.wasClicked:
                    # if this is a new click, store time of first click and clicked until
                    exit_button.timesOn.append(exit_button.buttonClock.getTime())
                    exit_button.timesOff.append(exit_button.buttonClock.getTime())
                elif len(exit_button.timesOff):
                    # if click is continuing from last frame, update time of clicked until
                    exit_button.timesOff[-1] = exit_button.buttonClock.getTime()
                if not exit_button.wasClicked:
                    # end routine when exit_button is clicked
                    continueRoutine = False
                if not exit_button.wasClicked:
                    # run callback code when exit_button is clicked
                    pass
        # take note of whether exit_button was clicked, so that next frame we know if clicks are new
        exit_button.wasClicked = exit_button.isClicked and exit_button.status == STARTED
        
        # *text_5* updates
        
        # if text_5 is starting this frame...
        if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_5.frameNStart = frameN  # exact frame index
            text_5.tStart = t  # local t and not account for scr refresh
            text_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_5.started')
            # update status
            text_5.status = STARTED
            text_5.setAutoDraw(True)
        
        # if text_5 is active this frame...
        if text_5.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=end_fish,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_fish.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_fish.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_fish" ---
    for thisComponent in end_fish.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_fish
    end_fish.tStop = globalClock.getTime(format='float')
    end_fish.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_fish.stopped', end_fish.tStop)
    thisExp.addData('exit_button.numClicks', exit_button.numClicks)
    if exit_button.numClicks:
       thisExp.addData('exit_button.timesOn', exit_button.timesOn)
       thisExp.addData('exit_button.timesOff', exit_button.timesOff)
    else:
       thisExp.addData('exit_button.timesOn', "")
       thisExp.addData('exit_button.timesOff', "")
    thisExp.nextEntry()
    # the Routine "end_fish" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "dataupload" ---
    # create an object to store info about Routine dataupload
    dataupload = data.Routine(
        name='dataupload',
        components=[],
    )
    dataupload.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for dataupload
    dataupload.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    dataupload.tStart = globalClock.getTime(format='float')
    dataupload.status = STARTED
    thisExp.addData('dataupload.started', dataupload.tStart)
    dataupload.maxDuration = None
    # keep track of which components have finished
    datauploadComponents = dataupload.components
    for thisComponent in dataupload.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "dataupload" ---
    dataupload.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer, globalClock], 
                currentRoutine=dataupload,
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            dataupload.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dataupload.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "dataupload" ---
    for thisComponent in dataupload.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for dataupload
    dataupload.tStop = globalClock.getTime(format='float')
    dataupload.tStopRefresh = tThisFlipGlobal
    thisExp.addData('dataupload.stopped', dataupload.tStop)
    thisExp.nextEntry()
    # the Routine "dataupload" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # mark experiment as finished
    endExperiment(thisExp, win=win)


def saveData(thisExp):
    """
    Save data from this experiment
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    filename = thisExp.dataFileName
    # these shouldn't be strictly necessary (should auto-save)
    thisExp.saveAsWideText(filename + '.csv', delim='auto')
    thisExp.saveAsPickle(filename)


def endExperiment(thisExp, win=None):
    """
    End this experiment, performing final shut down operations.
    
    This function does NOT close the window or end the Python process - use `quit` for this.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    """
    if win is not None:
        # remove autodraw from all current components
        win.clearAutoDraw()
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed
        win.flip()
    # return console logger level to WARNING
    logging.console.setLevel(logging.WARNING)
    # mark experiment handler as finished
    thisExp.status = FINISHED
    # run any 'at exit' functions
    for fcn in runAtExit:
        fcn()
    logging.flush()


def quit(thisExp, win=None, thisSession=None):
    """
    Fully quit, closing the window and ending the Python process.
    
    Parameters
    ==========
    win : psychopy.visual.Window
        Window to close.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    thisExp.abort()  # or data files will save again on exit
    # make sure everything is closed down
    if win is not None:
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed before quitting
        win.flip()
        win.close()
    logging.flush()
    if thisSession is not None:
        thisSession.stop()
    # terminate Python process
    core.quit()


# if running this experiment as a script...
if __name__ == '__main__':
    # call all functions in order
    thisExp = setupData(expInfo=expInfo)
    logFile = setupLogging(filename=thisExp.dataFileName)
    win = setupWindow(expInfo=expInfo)
    setupDevices(expInfo=expInfo, thisExp=thisExp, win=win)
    run(
        expInfo=expInfo, 
        thisExp=thisExp, 
        win=win,
        globalClock='float'
    )
    saveData(thisExp=thisExp)
    quit(thisExp=thisExp, win=win)
